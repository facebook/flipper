"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1202],{3905:(e,n,t)=>{t.r(n),t.d(n,{MDXContext:()=>m,MDXProvider:()=>c,mdx:()=>x,useMDXComponents:()=>p,withMDXComponents:()=>d});var r=t(67294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(){return(a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e}).apply(this,arguments)}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var m=r.createContext({}),d=function(e){return function(n){var t=p(n.components);return r.createElement(e,a({},n,{components:t}))}},p=function(e){var n=r.useContext(m),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=p(e.components);return r.createElement(m.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},h=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,o=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(t),c=i,h=d["".concat(o,".").concat(c)]||d[c]||u[c]||a;return t?r.createElement(h,l(l({ref:n},m),{},{components:t})):r.createElement(h,l({ref:n},m))}));function x(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,o=new Array(a);o[0]=h;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var m=2;m<a;m++)o[m]=t[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}h.displayName="MDXCreateElement"},83850:(e,n,t)=>{t.r(n),t.d(n,{frontMatter:()=>l,contentTitle:()=>s,metadata:()=>m,toc:()=>d,default:()=>c});var r=t(87462),i=t(63366),a=(t(67294),t(3905)),o=["components"],l={id:"linters",title:"Linters",sidebar_label:"Linters"},s=void 0,m={unversionedId:"internals/linters",id:"internals/linters",isDocsHomePage:!1,title:"Linters",description:"Flipper Desktop comes with a variety of ESLint checks pre-enabled. This allows us",source:"@site/../docs/internals/linters.mdx",sourceDirName:"internals",slug:"/internals/linters",permalink:"/docs/internals/linters",editUrl:"https://github.com/facebook/flipper/blob/main/website/../docs/internals/linters.mdx",tags:[],version:"current",frontMatter:{id:"linters",title:"Linters",sidebar_label:"Linters"},sidebar:"internals",previous:{title:"Testing RN Changes",permalink:"/docs/extending/testing-rn"}},d=[{value:"Specific Linters",id:"specific-linters",children:[{value:"<code>promise/no-nesting</code>",id:"promiseno-nesting",children:[]},{value:"<code>flipper/no-console-error-without-context</code>",id:"flipperno-console-error-without-context",children:[]},{value:"<code>promise/catch-or-return</code>",id:"promisecatch-or-return",children:[]},{value:"<code>communist-spelling/communist-spelling</code>",id:"communist-spellingcommunist-spelling",children:[]},{value:"<code>no-restricted-properties</code>",id:"no-restricted-properties",children:[]},{value:"<code>node/no-sync</code>",id:"nodeno-sync",children:[]}]}],p={toc:d};function c(e){var n=e.components,t=(0,i.Z)(e,o);return(0,a.mdx)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.mdx)("p",null,"Flipper Desktop comes with a variety of ESLint checks pre-enabled. This allows us\nto enforce sustainable coding practices and skip over discussions in code reviews."),(0,a.mdx)("h2",{id:"specific-linters"},"Specific Linters"),(0,a.mdx)("p",null,"A short and incomplete list of unusual linters we deploy, why we do it and how to fix them."),(0,a.mdx)("h3",{id:"promiseno-nesting"},(0,a.mdx)("inlineCode",{parentName:"h3"},"promise/no-nesting")),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Summary:")," Avoid nested then() or catch() statements. ",(0,a.mdx)("a",{parentName:"li",href:"https://github.com/xjamundx/eslint-plugin-promise/blob/development/docs/rules/no-nesting.md"},"More details.")),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Why:")," Nested promise chains can be difficult to read and reason about. Often, you can\nachieve the same by either returning the promise and handling them on a higher level\nor converting them to an async function.")),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"Example")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Before")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"private pushFileToiOSDevice(\n  udid: string,\n  bundleId: string,\n  destination: string,\n  filename: string,\n  contents: string,\n): Promise<void> {\n  return tmpDir({unsafeCleanup: true}).then((dir) => {\n    const filePath = path.resolve(dir, filename);\n    promisify(fs.writeFile)(filePath, contents).then(() =>\n      iosUtil.push(\n        udid,\n        filePath,\n        bundleId,\n        destination,\n        this.config.idbPath,\n      ),\n    );\n  });\n}\n")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"After")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"async pushFileToiOSDevice(\n  udid: string,\n  bundleId: string,\n  destination: string,\n  filename: string,\n  contents: string,\n): Promise<void> {\n  const dir = await tmpDir({unsafeCleanup: true});\n  const filePath = path.resolve(dir, filename);\n  await fs.writeFile(filePath, contents);\n  return iosUtil.push(\n    udid,\n    filePath,\n    bundleId,\n    destination,\n    this.config.idbPath,\n  );\n}\n")),(0,a.mdx)("p",null,"In addition to less indentation, you also maintain the promise chain\nhere, meaning that you can handle potential errors on the call-side."),(0,a.mdx)("h3",{id:"flipperno-console-error-without-context"},(0,a.mdx)("inlineCode",{parentName:"h3"},"flipper/no-console-error-without-context")),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Summary:"),' Avoid "Naked" console.error calls. Prefer ',(0,a.mdx)("inlineCode",{parentName:"li"},'console.error("Failed to connect open iOS connection socket", e)')," to ",(0,a.mdx)("inlineCode",{parentName:"li"},"console.error(e)"),"."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Why:")," We create error tasks internally for every ",(0,a.mdx)("inlineCode",{parentName:"li"},"console.error")," call. It can be hard\nto find the origin of the error without context.")),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"Example")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Before")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"try {\n    // ...\n} catch (e) {\n    console.error(e);\n}\n")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"After")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"try {\n    // ...\n} catch (e) {\n    console.error(`Failed to connect to paste host ${hostname}`, e);\n}\n")),(0,a.mdx)("h3",{id:"promisecatch-or-return"},(0,a.mdx)("inlineCode",{parentName:"h3"},"promise/catch-or-return")),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Summary:")," Ensure that each time a ",(0,a.mdx)("inlineCode",{parentName:"li"},"then()")," is applied to a promise, a\n",(0,a.mdx)("inlineCode",{parentName:"li"},"catch()")," is applied as well. Exceptions are made if you are returning that\npromise. ",(0,a.mdx)("a",{parentName:"li",href:"https://github.com/xjamundx/eslint-plugin-promise/blob/development/docs/rules/catch-or-return.md"},"More\ndetails.")),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Why:"),' Unhandled exceptions have no stack trace and will just show up as\n"Unhandled promise rejection", making them very hard to triage and reproduce. By\nalways ensuring that promises are returned (ensuring they are a chain) or\nexplicitly catching errors, we can improve the user experience by acting more\nquickly on errors.')),(0,a.mdx)("p",null,(0,a.mdx)("strong",{parentName:"p"},"Example")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Before")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},'function request() {\n    // If fetch() fails, the exception will bubble to the top.\n    fetch("https://example.com").then(res => {\n        doSomethingWith(res);\n    });\n}\n')),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"After")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},'// Option 1\nfunction request() {\n    fetch("https://example.com").then(res => {\n        doSomethingWith(res);\n    }).catch((e) => {\n        console.error("Failed to fetch from example.com", e);\n    });\n}\n\n// Option 2\nfunction request() {\n    // Allow the call-site to handle the error.\n    return fetch("https://example.com").then(res => {\n        doSomethingWith(res);\n    });\n}\n')),(0,a.mdx)("h3",{id:"communist-spellingcommunist-spelling"},(0,a.mdx)("inlineCode",{parentName:"h3"},"communist-spelling/communist-spelling")),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Summary"),": We try to avoid using British spellings for identifiers."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Why"),": This is clearly controversial, but it's very inconvenient when you have to\nbridge American and British APIs. ",(0,a.mdx)("inlineCode",{parentName:"li"},"const greyColour = COLORS.GRAY;")," is something\nnobody should have to read or write.")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Before")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"const GreyedOutOverlay = initialiseComponent();\n")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"After")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"const GrayedOutOverlay = initializeComponent();\n")),(0,a.mdx)("h3",{id:"no-restricted-properties"},(0,a.mdx)("inlineCode",{parentName:"h3"},"no-restricted-properties")),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Summary"),": Why try to avoid using ",(0,a.mdx)("inlineCode",{parentName:"li"},"electron.remote")," directly."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Why"),": Using ",(0,a.mdx)("a",{parentName:"li",href:"https://nornagon.medium.com/electrons-remote-module-considered-harmful-70d69500f31"},(0,a.mdx)("inlineCode",{parentName:"a"},"electron.remote"))," is considered harmful.\nNot only is accessing it slow, but it also makes it harder to abstract away from Electron which we're planning to do."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"How to fix it"),": For now, the best way is to use utilities whereever possible which cache the access. This is not always possible. Adding ignores for legitimate accesses is fine.")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Before")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"import electron from 'electron';\nconst portforwardingClient =\n  path.join(\n    electron.remote.app.getAppPath()\n    'PortForwardingMacApp.app',\n    'Contents',\n    'MacOS',\n    'PortForwardingMacApp'\n  );\n")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"After")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"import {getStaticPath} from './utils/pathUtils';\nconst portforwardingClient = getStaticPath(\n  path.join(\n    'PortForwardingMacApp.app',\n    'Contents',\n    'MacOS',\n    'PortForwardingMacApp',\n  ),\n);\n")),(0,a.mdx)("h3",{id:"nodeno-sync"},(0,a.mdx)("inlineCode",{parentName:"h3"},"node/no-sync")),(0,a.mdx)("ul",null,(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Summary"),": Use asynchronous methods whereever possible. ",(0,a.mdx)("a",{parentName:"li",href:"https://github.com/mysticatea/eslint-plugin-node/blob/master/docs/rules/no-sync.md"},"More details.")),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"Why"),": Synchronous method calls block the event loop. Even innocous calls like ",(0,a.mdx)("inlineCode",{parentName:"li"},"fs.existsSync()")," can cause\nframe drops for users or even long stalls."),(0,a.mdx)("li",{parentName:"ul"},(0,a.mdx)("strong",{parentName:"li"},"How to fix it"),": We have ",(0,a.mdx)("inlineCode",{parentName:"li"},"fs-extra")," as a dependency, which provides Promise-based alternatives for all ",(0,a.mdx)("inlineCode",{parentName:"li"},"fs")," functions.\nMost often, replacing a sync call with an async call and adding an ",(0,a.mdx)("inlineCode",{parentName:"li"},"await")," is all that's needed.")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"Before")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"import fs from 'fs';\nfunction ensureCertsExist() {\n    if (\n        !(\n        fs.existsSync(serverKey) &&\n        fs.existsSync(serverCert) &&\n        fs.existsSync(caCert)\n        )\n    ) {\n        return generateServerCertificate();\n    }\n}\n")),(0,a.mdx)("p",null,(0,a.mdx)("em",{parentName:"p"},"After")),(0,a.mdx)("pre",null,(0,a.mdx)("code",{parentName:"pre",className:"language-js"},"import fsExtra from 'fs-extra';\nasync function ensureCertsExist() {\n    const allExist = Promise.all([\n        fsExtra.exists(serverKey),\n        fsExtra.exists(serverCert),\n        fsExtra.exists(caCert),\n        ]).then((exist) => exist.every(Boolean));\n    if (!allExist) {\n      return this.generateServerCertificate();\n    }\n}\n")))}c.isMDXComponent=!0}}]);