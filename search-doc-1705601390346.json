{"searchDocs":[{"title":"Flipper 2021 Roadmap Update","type":0,"sectionRef":"#","url":"/blog/2021/10/14/roadmap/","content":"","keywords":"","version":null},{"title":"A short look back​","type":1,"pageTitle":"Flipper 2021 Roadmap Update","url":"/blog/2021/10/14/roadmap/#a-short-look-back","content":"During the first half of 2021, we have introduced support for connecting to physical iOS devices by leveraging idb. We have also introduced the Sandy plugin architecture, which simplifies the creation of plugins and provides a richer set of UI components by adopting Ant Design. The new architecture is strongly typed, easily unit testable and allows us to process and render data much faster, which has (at Facebook at least) significantly increased the up-time of Flipper. The underlying mechanism has been open sourced as the flipper-data-source package. And last but not least, we introduced dark mode support. ","version":null,"tagName":"h2"},{"title":"What is ahead?​","type":1,"pageTitle":"Flipper 2021 Roadmap Update","url":"/blog/2021/10/14/roadmap/#what-is-ahead","content":"Our focus for Flipper for Q4 2021 is to remove friction and make it easier to onboard new targets. This is because, in many instances, Flipper isn't used just to debug mobile apps, but also to debug many of our other products, such as native and Electron-based desktop applications, and devices like Oculus, Portal or feature phones. Looking ahead, we plan to: Move away from RSocket. RSocket is a protocol that served us well for encrypted communication between Flipper and clients. However, especially in the React Native world, the dependencies it brings has been a continuous source of build issues with any new iOS update. We are now testing internally a version of Flipper that uses secured WebSocket connections instead. The resulting simplified dependency chain should prevent a lot of current and future build issues.Introduce a headless Flipper version. The Flipper team is currently investing in decoupling all network, OS and device interaction logic from the Flipper front end. This will make it possible to run Flipper as a headless service, and embed the UI in any web-based stack. By default Flipper will remain an Electron app, but this change introduces a lot of new possibilities: It will be possible to run Flipper headless on CI systems to collect data during test runs. It will be possible to embed the Flipper UI inside IDEs to reduce context switching. To achieve this, the Flipper code base will be split into many smaller packages.Improve the Flipper marketplace. We are working on an improved Flipper plugin marketplace, to help promote plugins, and create a better understanding of what plugins do, and how they are supported.Create a reference WebSocket implementation. For Native mobile apps and React Native, there are standard packages to register plugins and connect to the Flipper desktop application. Although several WebSocket implementations exist to do the same for web apps, we don't have a standardized SDK and example project for integrating web applications with Flipper. By changing this we'll hope to make it easy for front-end engineers to leverage Flipper.Add support for React Native Windows. 'nough said. ","version":null,"tagName":"h2"},{"title":"Flipper needs you!​","type":1,"pageTitle":"Flipper 2021 Roadmap Update","url":"/blog/2021/10/14/roadmap/#flipper-needs-you","content":"Flipper is maintained by a small team at Facebook, yet serving over a hundred plugins and dozens of different targets. Our team's goal is to support Flipper as a plugin-based platform for which we maintain the infrastructure. We don't typically invest in individual plugins, but we do love plugin improvements. For example, the support for mocking network requests (on Android) was entirely contributed by the community (thanks James Harmon!). As was Protobuf support (thanks Harold Martin!). For that reason, we've marked many requests in the issue tracker as PR Welcome. Contributing changes should be as simple as cloning the repository and running yarn &amp;&amp; yarn start in the desktop/ folder. Investing in debugging tools, both generic ones or just for specific apps, will benefit iteration speed. And we hope Flipper will make it as hassle free as possible to create your debugging tools. For an overview of Flipper for React Native, and why and how to build your own plugins, we recommend checking out the Flipper: The Extensible DevTool Platform for React Native talk. Happy debugging! ","version":null,"tagName":"h2"},{"title":"Flipper is coming to your web and Node.js apps","type":0,"sectionRef":"#","url":"/blog/2022/02/21/js-flipper-announcement/","content":"","keywords":"","version":null},{"title":"What js-flipper is and why it matters​","type":1,"pageTitle":"Flipper is coming to your web and Node.js apps","url":"/blog/2022/02/21/js-flipper-announcement/#what-js-flipper-is-and-why-it-matters","content":"Flipper supports native iOS, native Android apps and React Native apps out of the box. Now with js-flipper, Flipper also supports JavaScript apps. Any JavaScript app, whether they run in your browser or on your Node.js server, can now connect to Flipper for a debugging session. js-flipper is a new NPM package that exposes a Flipper client to your JavaScript apps. Any Flipper client, in its turn, is a set of abstractions that let your device connect and talk to Flipper. Long story short, js-flipperallows you to easily write Flipper plugins for your web and Node.js apps. Here is how you can write your first simple plugin. Why does it matter? It's a huge deal for two reasons: Flipper at its core is just a device discovery service with a message bus. Its power comes from the plugins and the ecosystem.It brings us one step closer to our goal of running Flipper everywhere. Bring Flipper to your microwave! On a serious note, more platforms -&gt; bigger community -&gt; more developers -&gt; more plugins -&gt; better Flipper for everyone. Let's take a quick look at the principal architecture of Flipper:  Here is what happens there: Flipper constantly pollsADB for available Android devices and IDB for available iOS devices.If the device is running an app with an enabled Flipper client, the client tries to connect to Flipper on your laptop. It lets Flipper know that there is an app that it can talk to. Flipper and app chit-chat a bit negotiating the security and the list of supported plugins.The developer picks one of the connected apps / devices. Say, it's the app.The developer clicks one of the available plugins.The plugin starts talking to the app on the device via the message bus exposed by Flipper. The plugin asks for necessary data from the app and shows it in a pretty UI. At Meta, we have many active plugins, across a wide variety of devices, not just phones, but also Quests, desktop applications, etc. At its core, Flipper is data-agnostic and connect data flows to plugin displays. All Flipper core (we call it Flipper Server) knows is what devices and Flipper-enabled apps are out there. I hope it gets us on the same page regarding why plugins (and plugin developers!) are crucial for Flipper. Another important conclusion you could draw from the diagram is that the state of Flipper plugins is ephemeral and lives in the UI. ","version":null,"tagName":"h2"},{"title":"How Flipper talks to a mobile device​","type":1,"pageTitle":"Flipper is coming to your web and Node.js apps","url":"/blog/2022/02/21/js-flipper-announcement/#how-flipper-talks-to-a-mobile-device","content":"Let's dive a bit deeper into how exactly the device and Flipper talk. Flipper pulls device logs from ADB/IDB. For everything else, Flipper expects the app (Flipper client inside of the app) to open a WebSocket connection to Flipper. The algorithm looks like this: The app opens a WebSocket connection to Flipper.They exchange certificates. Flipper connects to the app using ADB/IDB and writes a certificate to the app storage.The app opens a secure WebSocket connection to Flipper using the certificate. Why do we even bother with the certificate exchange process? One of the potential attack vectors is that a developer could install a malicious app on the testing device. That app could spin up a WebSocket server and mask itself as Flipper. However, unlike Flipper, the malicious app can't access the file storage of another app. As a result, it can't complete the certificate exchange process. On mobile devices certificate exchange is important, so that other apps on the phone can't impersonate Flipper. For browser apps this isn't an issue as the browser already makes sure a malicious page cannot act as Flipper server. For platforms like this, we use a simplified connection algorithm: The app opens a WebSocket connection to Flipper.Bingo! js-flipper implements the second algorithm, without the certificate exchange. ","version":null,"tagName":"h2"},{"title":"Message protocol and structure​","type":1,"pageTitle":"Flipper is coming to your web and Node.js apps","url":"/blog/2022/02/21/js-flipper-announcement/#message-protocol-and-structure","content":"Once the final WebSocket connection is established, Flipper starts talking to the app: It sends getPlugins and getBackgroundPlugins messages to get a list of plugins supported by the app.Flipper displays the available plugins to the developer.Developer clicks on one of the plugins (enables a plugin).Flipper loads the UI for the plugin. Let's settle on calling the part of the plugin &quot;desktop plugin&quot; and the device part of the plugin &quot;client plugin&quot;.Flipper sends init message to the app.Client plugin onConnect code is executed. Read more about Client Plugin APIhere.Whenever a &quot;desktop plugin&quot; needs some data from the device it sends anexecute message to the &quot;client plugin&quot; on the device.&quot;Client plugin&quot; replies with the data.&quot;Client plugin&quot; might force the &quot;desktop plugin&quot; to do something as well by sending an execute message as well. However, it is rare. In the current implementation, the &quot;client plugin&quot; can never expect a reply back from the &quot;desktop plugin&quot;. In other words, consider it as an event sink, not as a way to extract some data from the &quot;desktop plugin&quot;.When the plugin is deactivated a deinit message is sent to the &quot;client plugin&quot;.Client plugin onDisconnect code is executed. The process above is for the insecure WebSocket connections we currently use in js-flipper. It is more complicated for secure WebSocket connections that require certificate exchange. Flipper expects each message to have the following structure: export interface FlipperRequest { method: string; // 'getPlugins' | 'getBackgroundPlugins' | 'init' | 'deinit' | 'execute' | 'isMethodSupported' params?: { api: string; // Plugin ID (name) // These nested `method` and `params` could be anything. // You set them yourself as you see fit to support the data exchange between the &quot;desktop plugin&quot; and the &quot;client plugin&quot;. // For example, for 'ReactNativeTicTacToe' we support 2 methods: 'SetState' and 'GetState'. // We pass a game state with a 'SetState' message. See https://fbflipper.com/docs/tutorial/javascript/#step-3-call-addplugin-to-add-your-plugin method: string; params?: unknown; }; }  The only exception is the response message the &quot;client plugin&quot; sends back when the data is requested. export type FlipperResponse = { id: number; success?: object | string | number | boolean | null; error?: { message: string; stacktrace?: string; name?: string; }; };  ","version":null,"tagName":"h2"},{"title":"Building a new client​","type":1,"pageTitle":"Flipper is coming to your web and Node.js apps","url":"/blog/2022/02/21/js-flipper-announcement/#building-a-new-client","content":"At this point, you know what messages your client needs to support in a Flipper client: getPluginsgetBackgroundPluginsinitdeinitexecute One other message we did not mention before is isMethodSupported. Its job is to reply back to a &quot;desktop plugin&quot; whether a &quot;client plugin&quot; supports one of plugin messages (that nested method field). It's useful when you have a single &quot;desktop plugin&quot; implementation, but different &quot;client plugin&quot; implementations. For example, some operations might not be supported on iOS, but are supported on Android. Alternatively, it can address version differences between the plugin installed on the device and the one loaded into Flipper. If you want to build a proper Flipper client, you also need to provide an abstraction for plugin developers. Consider matchingwhat we have for existing clients. Most of the groundwork for handling connections and doing certificate exchange is already done in ourC++ engine. Our iOS, Android, React Native clients use it under the hood. js-flipper implements everything from scratch using native browser APIs (for Node.js apps werequire developers to provide a WebSocket implementation). Here is a detailed document on how toimplement a client. You might also want to check the source code of our existing clients: iOSAndroidReact NativeJavaScript ","version":null,"tagName":"h2"},{"title":"What's next?​","type":1,"pageTitle":"Flipper is coming to your web and Node.js apps","url":"/blog/2022/02/21/js-flipper-announcement/#whats-next","content":"As of now, we do not provide any default plugins you might be used to forjs-flipper (Layout, Logs, Navigation, Crash Reporter, and others). We hope this will change in the future with the help of ur beloved open-source community! Call to action! We would like to encourage you to play with js-flipper. See how it fits your use-case and get back back to us with your feedback onGitHub. If you find yourself implementing one of your favorite Flipper plugins for js-flipper, do not hesitate and raise a PR! Plugins can be either generic or very application specific. Plugins can interact with Redux or MobX stores, read performance data or console logs from the browser. At Meta, we also see a lot of plugins that are very application specific. For example, plugins that allow logging in as specific test users with a single click, reading the internal state of NewsFeed and interacting with it, simulating photos captured by a smartphone, etc. A Flipper plugin can be any form of UI that is useful to speed up debugging and tasks on things you work on frequently! ","version":null,"tagName":"h2"},{"title":"P.S. Flipper needs you!​","type":1,"pageTitle":"Flipper is coming to your web and Node.js apps","url":"/blog/2022/02/21/js-flipper-announcement/#ps-flipper-needs-you","content":"Flipper is maintained by a small team at Meta, yet is serving over a hundred plugins and dozens of different targets. Our team's goal is to support Flipper as a plugin-based platform for which we maintain the infrastructure. We don't typically invest in individual plugins, but we do love plugin improvements. For example, the support for mocking network requests (on Android) was entirely contributed by the community (thanksJames Harmon!). As was Protobuf support (thanksHarold Martin!). For that reason, we've marked many requests in the issue tracker asPR Welcome. Contributing changes should be as simple as cloning therepository and runningyarn &amp;&amp; yarn start in the desktop/ folder. Investing in debugging tools, both generic ones or just for specific apps, will benefit iteration speed. And we hope Flipper will make it as hassle free as possible to create your debugging tools. For an overview of Flipper for React Native, and why and how to build your own plugins, we recommend checking out theFlipper: The Extensible DevTool Platform for React Nativetalk. Happy debugging! ","version":null,"tagName":"h2"},{"title":"Headless Flipper - what it means for plugin developers","type":0,"sectionRef":"#","url":"/blog/2022/05/20/preparing-for-headless-flipper/","content":"","keywords":"","version":null},{"title":"How Flipper changes​","type":1,"pageTitle":"Headless Flipper - what it means for plugin developers","url":"/blog/2022/05/20/preparing-for-headless-flipper/#how-flipper-changes","content":"Let us take a look at how it works today as an Electron app.  Here is what happens: Flipper starts as an Electron application. WebSocket server starts.Device discovery starts via adb/idb/metro.Electron shows a web view with Flipper UI (React).Flipper UI queries the device discovery service for a list of devices. At this point, Flipper can already run&quot;device&quot; plugins. These plugins do not receive a connection to a running app. They talk to the device via adb/idb/metro.An app starts on the device.Flipper Client embedded in the app connects to the WebSocket server.Flipper updates the list of known clients and reflects it in the UI.Now Flipper can run&quot;client&quot; plugins.Client plugins talk to the device application over the WebSocket connection. You can start Flipper Electron with yarn start from the /desktop folder. Here is how Flipper Headless works.  Flipper starts as a Node.js application. WebSocket server starts.Device discovery starts via adb/idb/metro.Web server starts.It serves Flipper UI to a browser.Flipper UI connects to the WebSocket server.Flipper UI sends a message over the WebSocket connection to query the device discovery service for a list of devices. At this point, Flipper can already run&quot;device&quot; plugins. These plugins do not receive a connection to a running app. They talk to the device via adb/idb/metro.An app starts on the device.Flipper Client embedded in the app connects to the WebSocket server.Flipper updates the list of known clients. It sends a message over the WebSocket connection to Flipper UI with the information about the new device.Now Flipper can run&quot;client&quot; plugins.Client plugins talk to the device application over the WebSocket bridge - the connection from Flipper UI to Flipper WebSocket server piped to the connection from the device application to the Flipper WebSocket server. You can start Flipper Electron with yarn flipper-server from the /desktopfolder. ","version":null,"tagName":"h2"},{"title":"How it affects plugins​","type":1,"pageTitle":"Headless Flipper - what it means for plugin developers","url":"/blog/2022/05/20/preparing-for-headless-flipper/#how-it-affects-plugins","content":"Plugins are hosted by Flipper UI. When it was a part of the Electron app, there was no problem. Plugins could access any Node.js APIs thanks to Electron magic. There were no constraints on what plugins could do. After making Flipper UI a proper web app running in a browser, we limited what plugins can do. They no longer can access the network stack or the file system because there are no corresponding browser APIs. Yet, we want to keep Flipper flexible and provide as much freedom to plugin developers as possible. Moreover, we could not leave the existing plugins without a clear migration path.  Since we already have a WebSocket connection between Flipper UI and Flipper Server, we can model almost any request-response and even stream-based Node.js APIs over it. So far, we exposed a curated subset of them: child_process exec fs (and fs-extra) constantsaccesspathExistsunlinkmkdirrmcopyFilestatreadlinkreadFilewriteFile We also provided a way todownload a fileor send requests to theinternal infrastructure. Please, find the complete list of available APIs onGitHub.Here are Node.js API abstractionsspecifically. As you might have noticed, all exposed APIs are of the request-response nature. They assume a short finite controlled lifespan. Yet, some plugins start additional web servers or spawn long-living child processes. To control their lifetime we need to track them on Flipper Server side and stop them whenever Flipper UI disconnects. Say hello to a new experimental feature - Flipper Server Add-ons!  Now, every flipper plugin could have &quot;server add-on&quot; meta-information. Whenever a Flipper plugin that has a corresponding Server Add-on starts, it sends a command to Flipper Server to start its Server Add-on counterpart. Flipper plugin that lives in a browser inside of Flipper UI talks to its server add-on over the WebSocket connection. Whenever a user disables a plugin, Flipper sends a command to Flipper Server to stop the add-on. At the same time, if Flipper UI crashes or the user just closes the tab, Flipper Server can kill the server add-on on its own. Flipper plugin can talk to its server add-on companion (seeonServerAddOnMessage, onServerAddOnUnhandledMessage, sendToServerAddOn inthe docs) and act whenever it starts or stops (see onServerAddOnStart,onServerAddOnStop inthe docs). Say, you wrote an ultimate library to find primes. You were cautious of the resource consumption, so you did it in Rust. You created a CLI interface for your new shiny library. Now, you want your Flipper plugin to use it. It takes a long time to find a prime and you want to keep track of the progress. You could use getFlipperLib().remoteServerContext.childProcess.exec, but it is not flexible enough to monitor progress updates that your CLI sends to stdout. Here is how you could approach it: // contract.tsx export interface ServerAddOnEvents { // Server add-on sends &quot;progress&quot; events with the progress updates progress: number; } export interface ServerAddOnMethods { // Client plugin send &quot;findPrime&quot; messages to the server add-on to start finding primes findPrime: () =&gt; Promise&lt;number&gt;; } // index.tsx (your plugin) import {usePlugin, useValue, createState, PluginClient} from 'flipper-plugin'; import {ServerAddOnEvents, ServerAddOnMethods} from './contract'; export const plugin = ( client: PluginClient&lt;{}, {}, ServerAddOnEvents, ServerAddOnMethods&gt;, ) =&gt; { const prime = createState&lt;number | null&gt;(null); const progress = createState&lt;number&gt;(0); client.onServerAddOnStart(async () =&gt; { const newPrime = await client.sendToServerAddOn('findPrime'); prime.set(newPrime); }); client.onServerAddOnStart(() =&gt; { client.onServerAddOnMessage('progress', progressUpdate =&gt; { progress.set(progressUpdate); }); }); return { prime, progress, }; }; export const Component = () =&gt; { const pluginInstance = usePlugin(plugin); const prime = useValue(pluginInstance.prime); const progress = useValue(pluginInstance.progress); return &lt;div&gt;{prime ?? `Calculating (${progress}%) done...`}&lt;/div&gt;; }; // serverAddOn.tsx import {ServerAddOn} from 'flipper-plugin'; import {exec, ChildProcess} from 'child_process'; import {ServerAddOnEvents, ServerAddOnMethods} from './contract'; const serverAddOn: ServerAddOn&lt;ServerAddOnEvents, ServerAddOnMethods&gt; = async connection =&gt; { let findPrimeChildProcess: ChildProcess | undefined; connection.receive('findPrime', () =&gt; { if (findPrimeChildProcess) { // Allow only one findPrime request at a time. Finding primes is expensive! throw new Error('Too many requests!'); } // Start our awesome Rust lib findPrimeChildProcess = exec('/find-prime-cli', {shell: true}); // Return a Promise that resolves when a prime is found. // Flipper will serialize the value the promise is resolved with and send it oer the wire. return new Promise(resolve =&gt; { // Listen to stdout of the lib for the progress updates and, eventually, the prime findPrimeChildProcess.stdout.on('data', data =&gt; { // Say, data is a stringified JSON const parsed = JSON.parse(data); if (parsed.type === 'progress') { connection.send('progress', parsed.value); return; } // Allow new requests to find new primes findPrimeChildProcess = undefined; // If it is not a progress update, then a prime is found. resolve(parsed.value); }); }); }); }; export default serverAddOn;  ","version":null,"tagName":"h2"},{"title":"Migration guide​","type":1,"pageTitle":"Headless Flipper - what it means for plugin developers","url":"/blog/2022/05/20/preparing-for-headless-flipper/#migration-guide","content":"Examine your plugins for Node.js APIs. Replace them withgetFlipperLib().remoteServerContext.* calls. // before import {mkdir} from 'fs/promises'; export const plugin = () =&gt; { const myAwesomeFn = async () =&gt; { await mkdir('/universe/dagobah'); }; return { myAwesomeFn, }; }; // after import {getFlipperLib} from 'flipper-plugin'; export const plugin = () =&gt; { const myAwesomeFn = async () =&gt; { await getFlipperLib().remoteServerContext.mkdir('/universe/dagobah'); }; return { myAwesomeFn, }; }; If your plugin uses network stack of spawns a subprocess, consider creating a Server Add-on. In your plugin's folder create a new file - serverAddOn.tsx In your plugin's package.json add fields serverAddOn andflipperBundlerEntryServerAddOn { // ... &quot;serverAddOn&quot;: &quot;dist/serverAddOn.js&quot;, &quot;flipperBundlerEntryServerAddOn&quot;: &quot;serverAddOn.tsx&quot;, // ... } Move your Node.js API calls to serverAddOn.tsx Verify your plugin works in a browser environment. Clone Flipper repo.Navigate to the desktop folder.In your terminal run yarn.Run yarn flipper-server.Load your plugin and make sure it works. ","version":null,"tagName":"h2"},{"title":"P.S. Flipper needs you!​","type":1,"pageTitle":"Headless Flipper - what it means for plugin developers","url":"/blog/2022/05/20/preparing-for-headless-flipper/#ps-flipper-needs-you","content":"Flipper is maintained by a small team at Meta, yet is serving over a hundred plugins and dozens of different targets. Our team's goal is to support Flipper as a plugin-based platform for which we maintain the infrastructure. We don't typically invest in individual plugins, but we do love plugin improvements. For that reason, we've marked many requests in the issue tracker asPR Welcome. Contributing changes should be as simple as cloning therepository and runningyarn &amp;&amp; yarn start in the desktop/ folder. Investing in debugging tools, both generic ones or just for specific apps, will benefit iteration speed. And we hope Flipper will make it as hassle free as possible to create your debugging tools. For an overview of Flipper for React Native, and why and how to build your own plugins, we recommend checking out theFlipper: The Extensible DevTool Platform for React Nativetalk. Happy debugging! ","version":null,"tagName":"h2"},{"title":"Client Plugin Lifecycle","type":0,"sectionRef":"#","url":"/docs/extending/client-plugin-lifecycle/","content":"","keywords":"","version":"Next"},{"title":"Regular plugin Lifecycle​","type":1,"pageTitle":"Client Plugin Lifecycle","url":"/docs/extending/client-plugin-lifecycle/#regular-plugin-lifecycle","content":"For regular plugins, onConnect and onDisconnect are triggered when the user opens the plugin in the Flipper UI, and when they switch to another plugin, respectively. The process is illustrated in the following diagram.  ","version":"Next","tagName":"h2"},{"title":"Background Plugin Lifecycle​","type":1,"pageTitle":"Client Plugin Lifecycle","url":"/docs/extending/client-plugin-lifecycle/#background-plugin-lifecycle","content":"For background plugins, onConnect is called when Flipper first connects, and onDisconnect when it disconnects. The user does not need to be viewing the plugin for it to send messages; they will be queued up until the next time the user opens the plugin where they will be processed. Even for background plugins, onDisconnect and onConnect may be called on a plugin (such as if the user restarts Flipper). Plugins should handle this accordingly by making sure to resend any important data to the reconnected instance. The process is illustrated in the following diagram.  danger Note that a plugin must be enabled by the user for its messages to be queued up. ","version":"Next","tagName":"h2"},{"title":"Architecture","type":0,"sectionRef":"#","url":"/docs/extending/arch/","content":"","keywords":"","version":"Next"},{"title":"Overview​","type":1,"pageTitle":"Architecture","url":"/docs/extending/arch/#overview","content":"Flipper is a Web Application which consists of a Browser interface built with HTML/CSS/JS on top of Node.JS HTTP server so that it can be packaged to run on any operating system. This desktop app connects over a TCP connection to applications running on simulators and connected devices. An application running on a device or simulator is called a 'client'. The connection is bi-directional, allowing the desktop to query information from the client as well allowing the client to push updates directly to the desktop. By querying data and responding to pushing from the client, a Flipper plugin is able to visualize data, debug problems, and change the behavior of running applications. Flipper provides the platform to build these tools and does not limit what kind of tools that may be. There are two types of plugins in Flipper: Client plugins - expose information as an API to desktop plugins whose responsibility it is to render this information in an easy-to-digest way. Client plugins are written once for each platform in the platform's native language.Desktop plugins - written only once in JavaScript using React and consume the APIs exposed by the client plugins. ","version":"Next","tagName":"h3"},{"title":"Architecture - React Native​","type":1,"pageTitle":"Architecture","url":"/docs/extending/arch/#architecture---react-native","content":"The following diagram shows a simplified visualization of the Flipper architecture when used with React Native.  ","version":"Next","tagName":"h3"},{"title":"Running Flipper with Custom Ports","type":0,"sectionRef":"#","url":"/docs/custom-ports/","content":"","keywords":"","version":"Next"},{"title":"Flipper ports - mobile apps that support certificate exchange​","type":1,"pageTitle":"Running Flipper with Custom Ports","url":"/docs/custom-ports/#flipper-ports---mobile--apps-that-support-certificate-exchange","content":"info By default, Flipper runs its servers on ports 9088 and 9089. The mobile SDKs look for servers on those ports. Each of these can be overridden by setting an environment variable, with the format: ${INSECURE_PORT},${SECURE_PORT}. To run the desktop app using custom ports, use the following: env FLIPPER_PORTS=1111,2222 ./flipper  or with a dev build: env FLIPPER_PORTS=1111,2222 yarn start  ","version":"Next","tagName":"h2"},{"title":"Android SDK​","type":1,"pageTitle":"Running Flipper with Custom Ports","url":"/docs/custom-ports/#android-sdk","content":"To configure the Android SDK for custom ports, set the flipper.ports prop to your chosen ports 1111,2222 and then launch the Android app: adb shell su 0 setprop flipper.ports 1111,2222  ","version":"Next","tagName":"h3"},{"title":"iOS SDK​","type":1,"pageTitle":"Running Flipper with Custom Ports","url":"/docs/custom-ports/#ios-sdk","content":"To configure the iOS SDK for custom ports, set the FLIPPER_PORTS environment variable in your app launch script or set it system-wide through User Defaults: xcrun simctl spawn booted defaults write &quot;Apple Global Domain&quot; &quot;com.facebook.flipper.ports&quot; -string &quot;1111,2222&quot;  ","version":"Next","tagName":"h3"},{"title":"Flipper ports - apps that do not support certificate exchange​","type":1,"pageTitle":"Running Flipper with Custom Ports","url":"/docs/custom-ports/#flipper-ports---apps-that-do-not-support-certificate-exchange","content":"rmation Flipper listens on port 8333 for unsecure (browser, Node.js) connections. To run the desktop app using custom ports, use the following: env FLIPPER_BROWSER_PORT=1111 ./flipper  or with a dev build: env FLIPPER_BROWSER_PORT=1111 yarn start  To connect to Flipper on a different port from js-flipper, you need to override its urlBase when you start it. flipperClient.start('React Tic-Tac-Toe', { urlBase: 'localhost:1111' });  ","version":"Next","tagName":"h2"},{"title":"Metro Server Ports​","type":1,"pageTitle":"Running Flipper with Custom Ports","url":"/docs/custom-ports/#metro-server-ports","content":"You can also setup Flipper to use a different Metro Server port (default=8081) using this environement variable, as follows: METRO_SERVER_PORT=3333 ./flipper  ","version":"Next","tagName":"h2"},{"title":"ADB Reverse Proxy ports​","type":1,"pageTitle":"Running Flipper with Custom Ports","url":"/docs/custom-ports/#adb-reverse-proxy-ports","content":"You can setup a different ADB port, used for reverse proxying when plugged through USB (default=5037), using the following: ANDROID_ADB_SERVER_PORT=4444 ./flipper  ","version":"Next","tagName":"h2"},{"title":"Debugging","type":0,"sectionRef":"#","url":"/docs/extending/debugging/","content":"","keywords":"","version":"Next"},{"title":"Built-in Developer Tools​","type":1,"pageTitle":"Debugging","url":"/docs/extending/debugging/#built-in-developer-tools","content":"Flipper runs in the Browser. This means you can debug Flipper using any web developer tools like Chrome's Developer Tools. In addition, to assist you with the JavaScript, the JS console displays uncaught exceptions thrown from the client plugin in response to Flipper method calls. ","version":"Next","tagName":"h2"},{"title":"Google Chrome Developer Tools​","type":1,"pageTitle":"Debugging","url":"/docs/extending/debugging/#google-chrome-developer-tools","content":"As an alternative to using built-in Developer Tools, you can also attach to the running Flipper instance from Google Chrome Developer Tools. Sometimes this is useful because the version of Dev Tools in Google Chrome is more recent than the embedded one, and it is possible to easily install additional extensions if required. To attach the running Flipper instance, open a new tab in Google Chrome, navigate to http://localhost:9222 and choose 'Flipper' in the opened list, as shown in the following screenshot  ","version":"Next","tagName":"h2"},{"title":"Visual Studio Code​","type":1,"pageTitle":"Debugging","url":"/docs/extending/debugging/#visual-studio-code","content":"If you prefer to use the same editor for both coding and debugging, you can attach to the running Flipper instance for debugging right from Visual Studio Code. Take the following steps: First, you need to install the extension 'Debugger for Chrome'.To start debugging, open the folder desktop of the Flipper repository in VSCodeExecute yarn start in a terminal to launch Flipper in development modeSelect tab Debug and Run and run task Attach to Running Renderer. By default, this task is set as the first one, so you can just press F5 to run it.  ","version":"Next","tagName":"h2"},{"title":"Plugin missing​","type":1,"pageTitle":"Debugging","url":"/docs/extending/debugging/#plugin-missing","content":"If a plugin you've created is not showing up, there might be two potential classes of problems, either there is a problem on the mobile side or on the desktop side (understanding where the problem is rooted helps in debugging it). Click on 'Plugin now showing' in the sidebar and see if your plugin is now listed. If it is not listed, the desktop side of the plugin is not loaded. One of the main reasons for this is that the plugin could not be compiled, due to some errors. Try launching Flipper from the Terminal to see some additional logs: /Applications/Flipper.app/Contents/MacOS/Flipper. A common error here is Error: fsevents unavailable (this watcher can only be used on Darwin). This can be fixed by installing watchman (brew install watchman). ","version":"Next","tagName":"h2"},{"title":"Print debugging​","type":1,"pageTitle":"Debugging","url":"/docs/extending/debugging/#print-debugging","content":"Add console.log(&quot;test phrase %&quot;, object) and then search the developer tools log in Flipper to find what the value of the object is. If the plugin is listed in the desktop app, but still is not showing up in the sidebar, the mobile app is not announcing the plugin. In this case, make sure to instantiate your plugin and add it to your FlipperClient. ","version":"Next","tagName":"h2"},{"title":"Using Deeplinks","type":0,"sectionRef":"#","url":"/docs/extending/deeplinks/","content":"","keywords":"","version":"Next"},{"title":"open-plugin​","type":1,"pageTitle":"Using Deeplinks","url":"/docs/extending/deeplinks/#open-plugin","content":"The following link format can be used to open Flipper and open a specific plugin: flipper://open-plugin?plugin-id=&lt;plugin-id&gt;&amp;client=&lt;client&gt;&amp;devices=&lt;devices&gt;&amp;payload=&lt;payload&gt; The parameters are specified as follows: plugin-id - [required] the identifier of the plugin that needs to be opened, as specified by the id field in package.json.client - [optional] the name of the application that should be opened. For device plugins, this doesn't need to be specified. If not set, the user will be prompted to select a client.devices - [optional] comma separated list of device types that are acceptable. For example, iOS,Android or Metro. If set, client and plugin-id must be running on this type of device.payload - [optional] any additional string argument to pass to the plugin. Note that this argument should be properly URL encoded. Using this deeplink format ensures that: [FB-ONLY] The user is logged in &amp; connected to Facebook.Flipper is up to date.[FB-ONLY] The specified plugin is installed.The plugin is available on the provided client / device, or will prompt the user for a valid device / client selection is made on which the plugin is available.The plugin is enabled. ","version":"Next","tagName":"h2"},{"title":"Handling deeplinks in the plugin​","type":1,"pageTitle":"Using Deeplinks","url":"/docs/extending/deeplinks/#handling-deeplinks-in-the-plugin","content":"If a plugin is opened through a deeplink, for which a payload was set, the onDeepLink handler will be triggered directly after initializing and rendering the plugin. note The same payload format can also be used to open other plugins programmatically from inside another plugin, by passing the payload as second argument to selectPlugin. ","version":"Next","tagName":"h3"},{"title":"Error Handling","type":0,"sectionRef":"#","url":"/docs/extending/error-handling/","content":"","keywords":"","version":"Next"},{"title":"Android​","type":1,"pageTitle":"Error Handling","url":"/docs/extending/error-handling/#android","content":"To gracefully handle errors in Flipper, use the following classes: FlipperResponder - an instance is provided to the client plugin on every method call, which enables it to return results. When an error occurs during a Flipper method call that can't be handled, pass the error to the responder. This will let the desktop plugin handle it, and if it doesn't, the error will be displayed in the DevTools console. ErrorReportingRunnable - a custom Runnable that catches all exceptions, stopping them from crashing the application and reports them to Flipper. These error messages will show up in the DevTools console. Executing the following block of code will always finish without error but may transfer any silent errors to the Flipper desktop app: new ErrorReportingRunnable(mConnection) { @Override public void runOrThrow() throws Exception { mightThrowException(); } }.run();  During plugin development these java stack traces are surfaced in the chrome dev console. Always use ErrorReportingRunnable for error handling instead of try/catch or, even worse, letting errors crash the app. With ErrorReportingRunnable you won't block anyone, and you won't hide any stack traces. ","version":"Next","tagName":"h2"},{"title":"C++​","type":1,"pageTitle":"Error Handling","url":"/docs/extending/error-handling/#c","content":"To gracefully handle errors in Flipper, all transactions are performed inside of a 'Try' block, which catches all exceptions, stops them from crashing the application, and reports them to the plugin Developer. This includes your own customs implementations of FlipperPlugin::didConnect() and FlipperConnection::send() and ::receive(). This means you can safely throw exceptions in your plugin code; the exception messages will be sent to the Flipper desktop app. During plugin development the exception messages are surfaced in the Chrome dev console. If your plugin performs asynchronous work in which exceptions are thrown, these exceptions will not be caught by the Flipper infrastructure. You should handle them appropriately. ","version":"Next","tagName":"h2"},{"title":"Development Setup","type":0,"sectionRef":"#","url":"/docs/extending/dev-setup/","content":"","keywords":"","version":"Next"},{"title":"IDE​","type":1,"pageTitle":"Development Setup","url":"/docs/extending/dev-setup/#ide","content":"When developing Flipper plugins, the following IDEs are recommended: TypeScript (for Flipper Desktop (plugins)): Visual Studio Code Install the &quot;ESLint&quot; (dbaeumer.vscode-eslint) extension from marketplace to enable linting.Install the &quot;Prettier&quot; (esbenp.prettier-vscode) extension to enable automatic code-formatting.If for some reason it is not working, the builtin TypeScript extension might be disabled. To enable it, to go to extensions, search for “@builtin typescript” and enable it. Android Studio (for Android plugins).XCode (for iOS plugins). ","version":"Next","tagName":"h2"},{"title":"Running Flipper from source (recommended)​","type":1,"pageTitle":"Development Setup","url":"/docs/extending/dev-setup/#running-flipper-from-source-recommended","content":"When developing Flipper plugins, it's strongly recommended to run from Flipper itself from source as well, as this yields the following benefits: Automatic transpilation and bundling of loaded plugins: ES6, TypeScript, JSX.Automatic refresh after code changes.React and Redux Dev Tools.Debugging using Chrome Dev Tools or Visual Studio Code.Additional debug information like React warnings and performance metrics. Prerequisites for a Flipper development build: node ≥ 14yarn ≥ 1.5gitwatchman To run Flipper Desktop from source: git clone https://github.com/facebook/flipper.git cd flipper/desktop yarn yarn start  Tip Start with yarn start --fast-refresh for experimental fast refreash. ","version":"Next","tagName":"h2"},{"title":"Startup options​","type":1,"pageTitle":"Development Setup","url":"/docs/extending/dev-setup/#startup-options","content":"You can use several options to customise development build instance. They can be provided as command-line args or environment variables. You can check all of them by executing yarn start --help: yarn start [args] Options: --embedded-plugins Enables embedding of plugins into Flipper bundle. If it disabled then only installed plugins are loaded. The flag is enabled by default. Env var FLIPPER_NO_EMBEDDED_PLUGINS is equivalent to the command-line option &quot;--no-embedded-plugins&quot;. [Boolean] --fast-refresh Enable Fast Refresh - quick reload of UI component changes without restarting Flipper. The flag is disabled by default. Env var FLIPPER_FAST_REFRESH is equivalent to the command-line option &quot;--fast-refresh&quot;. [Boolean] --plugin-auto-update [FB-internal only] Enable plugin auto-updates. The flag is disabled by default in dev mode. Env var FLIPPER_NO_PLUGIN_AUTO_UPDATE is equivalent to the command-line option &quot;--no-plugin-auto-update&quot; [Boolean] --enabled-plugins Load only specified plugins and skip loading rest. This is useful when you are developing only one or few plugins. Plugins to load can be specified as a comma-separated list with either plugin id or name used as identifier, e.g. &quot;--enabled-plugins network,inspector&quot;. The flag is not provided by default which means that all plugins loaded. [array] --open-dev-tools Open Dev Tools window on startup. The flag is disabled by default. Env var FLIPPER_OPEN_DEV_TOOLS is equivalent to the command-line option &quot;--open-dev-tools&quot;. If &quot;FLIPPER_UPDATE_DEV_TOOLS=true&quot; is set additionally, Flipper will try to update the dev tools from the play store. [Boolean] --dev-server-port Dev server port. 3000 by default. Env var &quot;PORT=3001&quot; is equivalent to the command-line option &quot;--dev-server-port 3001&quot;. [number] [default: 3000] --version Show version number [Boolean] --help Show help [Boolean]  You can also create an .env file in the desktop subfolder and specify any environment variables to load them automatically on yarn start so you don't need to pass command-line args every time: FLIPPER_FAST_REFRESH=true FLIPPER_OPEN_DEV_TOOLS=true FLIPPER_ENABLED_PLUGINS=flipper-messages,network,inspector  ","version":"Next","tagName":"h3"},{"title":"Guidelines for writing TypeScript​","type":1,"pageTitle":"Development Setup","url":"/docs/extending/dev-setup/#guidelines-for-writing-typescript","content":"Install 3rd party type definitions as dev dependency (for example, yarn add @types/lodash --dev) ","version":"Next","tagName":"h2"},{"title":"Submitting a diff / PR​","type":1,"pageTitle":"Development Setup","url":"/docs/extending/dev-setup/#submitting-a-diff--pr","content":"Make sure your new functionality is covered with tests and run yarn test or yarn test --watch in the desktop/ directory to verify that they pass. See the testing page for more details on writing and running tests. To ensure you don't get any lint/formatting errors, run yarn lint before submitting your diff. Some errors (especially formatting errors) can be auto-fixed by running yarn fix ","version":"Next","tagName":"h2"},{"title":"Secure Communication","type":0,"sectionRef":"#","url":"/docs/extending/establishing-a-connection/","content":"","keywords":"","version":"Next"},{"title":"Transport Protocol​","type":1,"pageTitle":"Secure Communication","url":"/docs/extending/establishing-a-connection/#transport-protocol","content":"Flipper uses WebSocket to communicate between the desktop and mobile apps. WebSocket enables bi-directional communication. ","version":"Next","tagName":"h2"},{"title":"Client-Server relationship​","type":1,"pageTitle":"Secure Communication","url":"/docs/extending/establishing-a-connection/#client-server-relationship","content":"When the desktop app starts up, it opens a secure socket on port 9088. The Flipper client will continually attempt to connect to this port on localhost to establish a connection with the desktop app. ","version":"Next","tagName":"h2"},{"title":"Certificate Exchange​","type":1,"pageTitle":"Secure Communication","url":"/docs/extending/establishing-a-connection/#certificate-exchange","content":"To avoid mobile apps from connecting to untrusted ports on localhost, a Flipper client should only connect to servers that have a valid, trusted TLS certificate. In order for the mobile app to know which certificates it can trust, it conducts a certificate exchange with the desktop app before it can make its first secure connection. This is achieved through the following steps: Desktop app starts an insecure server on port 9089.Mobile app connects to localhost:9089 and sends a Certificate Signing Request to the desktop app.Desktop app uses its private key (this is generated once and stored in ~/.flipper) to sign a client certificate for the mobile app.Along with the Certificate Signing Request, mobile app also lets the desktop app know which Certificate Exchange Medium to use: Certificate Exchange Medium = FS_ACCESS - the desktop uses ADB (for Android) or the mounted file system (for iOS simulators) to write the following files to the mobile app's private data partition: Server certificate that the mobile app can now trust.Client certificate for the mobile app to use going forward. Certificate Exchange Medium = WWW - the desktop app will use your implementation of Certificate Uploader to upload the certificates: Once uploaded, the desktop app will reply back with the device id, which can be used by the Certificate Provider on the client side to fetch those certificates. Currently, Flipper does not support WWW mode but there is work underway to start support. Now that the mobile app knows which server certificate it can trust, you can connect to the secure server. note This enables the mobile app to trust a certificate if and only if it is stored inside its internal data partition. Typically, it's only possible to write there with physical access to the device (that is, through ADB or a mounted simulator). To get the desktop app to generate a client certificate for your client and then deploy it, go through the following steps: Use a WebSocket client to connect (insecurely) to the following URL (Parameters are defined in Implementing a Flipper Client): localhost:9089/sonar?os={OS} &amp;device={DEVICE} &amp;app={APP} &amp;sdk_version={SDK_VERSION} &amp;medium={CERTIFICATE_EXCHANGE_MEDIUM} On that connection, send the following payload: Request = { &quot;method&quot;: &quot;signCertificate&quot;, &quot;csr&quot;: string, &quot;destination&quot;: string, &quot;medium&quot;: int } csr - a Certificate Signing Request the client has generated, and destination identifies a location accessible to both the client and Flipper desktop, where the certificate should be placed. The subject Common Name (CN=...) must be included in the CSR. Your CertificateProvider implementation in Flipper may use this in combination with the destination to determine where to put the certificate. This will ask Flipper desktop to generate a client certificate, using the CSR provided, and put it into the specified destination. destination - depending on the client, destination can have a different meaning: Basic example - a file path that both the desktop and the client have access to. With this, Flipper desktop could write the certificate to that path.Advanced example - an Android Client for which the destination specifies a relative path inside an app container: the Subject Common Name determines which app container. Together, these two pieces of information form an absolute file path inside an android device.For the Flipper desktop to work with a given Client type, it needs to be modified to know how to correctly interpret the destination argument and deploy certificates to it. medium - the destination field may not be relevant if your medium value is more than 1: medium=1(default) - Flipper should do certificate exchange by directly putting certificates at destination in the sandbox of the app.medium=2 - Flipper will use the Certificate Uploader and Provider to upload certificates and download it on the client side respectively. You can see the current implementations in CertificateProvider.tsx. ","version":"Next","tagName":"h2"},{"title":"Plugin structure","type":0,"sectionRef":"#","url":"/docs/extending/desktop-plugin-structure/","content":"","keywords":"","version":"Next"},{"title":"Scaffolding a new plugin​","type":1,"pageTitle":"Plugin structure","url":"/docs/extending/desktop-plugin-structure/#scaffolding-a-new-plugin","content":"","version":"Next","tagName":"h2"},{"title":"flipper-pkg​","type":1,"pageTitle":"Plugin structure","url":"/docs/extending/desktop-plugin-structure/#flipper-pkg","content":"The CLI tool flipper-pkg helps to initialize, validate, and package Flipper desktop plugins. To scaffold a new plugin run npx flipper-pkg init in the directory where you want to store the plugin sources. Note that this should typically not be inside a Flipper checkout, but rather a fresh directory which you can put under your own source control. ","version":"Next","tagName":"h3"},{"title":"Desktop Plugin structure​","type":1,"pageTitle":"Plugin structure","url":"/docs/extending/desktop-plugin-structure/#desktop-plugin-structure","content":"All Flipper Desktop plugins must be self-contained in a directory that must contain, at a minimum: package.json - the plugin packet manifest.An entry source file for your plugin (such as src/index.tsx). After scaffolding a new plugin has finished, those files will exist in the relevant directory. An example package.json file could look like the following: { &quot;$schema&quot;: &quot;https://fbflipper.com/schemas/plugin-package/v2.json&quot;, &quot;name&quot;: &quot;flipper-plugin-myplugin&quot;, &quot;id&quot;: &quot;myplugin&quot;, &quot;pluginType&quot;: &quot;client&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;dist/bundle.js&quot;, &quot;flipperBundlerEntry&quot;: &quot;src/index.tsx&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;keywords&quot;: [&quot;flipper-plugin&quot;], &quot;title&quot;: &quot;My Plugin&quot;, &quot;icon&quot;: &quot;apps&quot;, &quot;bugs&quot;: { &quot;email&quot;: &quot;you@example.com&quot; }, &quot;scripts&quot;: { &quot;lint&quot;: &quot;flipper-pkg lint&quot;, &quot;prepack&quot;: &quot;flipper-pkg lint &amp;&amp; flipper-pkg bundle&quot; }, &quot;peerDependencies&quot;: { &quot;flipper&quot;: &quot;latest&quot;, &quot;flipper-plugin&quot;: &quot;latest&quot; }, &quot;devDependencies&quot;: { &quot;flipper&quot;: &quot;latest&quot;, &quot;flipper-plugin&quot;: &quot;latest&quot;, &quot;flipper-pkg&quot;: &quot;latest&quot;, &quot;react&quot;: &quot;latest&quot;, &quot;antd&quot;: &quot;latest&quot; } }  The following are important attributes of package.json: $schema - must contain the URI identifying scheme according to which the plugin is defined. Currently, Flipper supports plugins defined by the specification version 2, while version 1 is being deprecated. name - the NPM package name. Should start with flipper-plugin- by convention so the Flipper plugins can be easily find it on NPM. id - the plugin native identifier, which must match the mobile plugin identifier returned by the getId method of your Java plugin. pluginType - Specifies the plugin type: client or device. For details, see the Anatomy of a Desktop plugin, below. main - points to the plugin bundle which is loaded by Flipper. The &quot;flipper-pkg&quot; utility uses this field to determine output location during plugin bundling. flipperBundlerEntry - points to the source entry point used for plugin code bundling. flipper-pkg takes the path specified in flipperBundlerEntry as source, transpiles and bundles it, and saves the output to the path specified in main. keywords - the field must contain the flipper-plugin keyword, otherwise Flipper won't discover the plugin. Additionally, the field can also contain any other keywords for better plugin discoverability. title - shown in the main sidebar as the human-readable name of the plugin. icon - determines the plugin icon that is displayed in the main sidebar. The list of available icons is static for now (see icons.json in GitHub). bugs - specify an email and/or URL where plugin bugs should be reported. In index.tsx you define the plugin in JavaScript, as shown in the following example: export function plugin(client) { return {}; } export function Component() { return 'hello world'; }  note Some public plugins use a FlipperPlugin base class. That format is deprecated. ","version":"Next","tagName":"h2"},{"title":"Anatomy of a Desktop plugin​","type":1,"pageTitle":"Plugin structure","url":"/docs/extending/desktop-plugin-structure/#anatomy-of-a-desktop-plugin","content":"Flipper Desktop plugins come in three possible flavors: Client plugins - connects to a specific client plugin running in an app (recommended).Device plugins - doesn't connect to a specific client and doesn't have a native counterpart but shows data about the device obtained through some other means, like device logs, device temperatures, and so on.Table plugin - a simplified version of a client plugin that merely displays incoming data from a client plugin in a table. ","version":"Next","tagName":"h2"},{"title":"Creating a Client Plugin​","type":1,"pageTitle":"Plugin structure","url":"/docs/extending/desktop-plugin-structure/#creating-a-client-plugin","content":"A plugin always exposes two elements from its entry module (typically src/index.tsx), plugin and Component, as shown in the following snippet: import {PluginClient} from 'flipper-plugin'; export function plugin(client: PluginClient) { return {}; // API exposed from this plugin } export function Component() { // Plugin UI return &lt;h1&gt;Welcome to my first plugin&lt;/h1&gt;; }  For details on how to write custom Flipper plugins, see the Building a Desktop Plugin - Custom UI tutorial page. ","version":"Next","tagName":"h3"},{"title":"Creating a Device Plugin​","type":1,"pageTitle":"Plugin structure","url":"/docs/extending/desktop-plugin-structure/#creating-a-device-plugin","content":"Flipper also supports so-called device plugins (plugins that are available for an entire device) but don't receive a connection to a running app, so are a bit more limited in general. Their entry module anatomy is as follows: import {DevicePluginClient} from 'flipper-plugin'; export function devicePlugin(client: DevicePluginClient) { return {}; // API exposed from this plugin } export function Component() { // Plugin UI return &lt;h1&gt;Welcome to my first plugin&lt;/h1&gt;; }  Client plugins must have the property pluginType set to device and should specify supported devices using the property supportedDevices in package.json. The supportedDevices property should contain an array of supported devices, each defined as a conjunction of device properties, using the following format: { &quot;os&quot;: &lt;&quot;Android&quot; | &quot;iOS&quot; | &quot;Metro&quot;&gt;, &quot;type&quot;: &lt;&quot;physical&quot; | &quot;emulator&quot;&gt;, &quot;archived&quot;: &lt;true | false&gt; }  For example, the array { &quot;os&quot;: &quot;Android&quot;, &quot;type&quot;: &quot;emulator&quot; } indicates that device must work on Android AND must be an emulator in order to debug it using the plugin. To specify that a plugin supports all types of Android devices, and physical iOS devices, and does not support imported (archived) data, the plugin package.json should look like the following: { &quot;$schema&quot;: &quot;https://fbflipper.com/schemas/plugin-package/v2.json&quot;, &quot;name&quot;: &quot;flipper-plugin-mydeviceplugin&quot;, &quot;id&quot;: &quot;mydeviceplugin&quot;, &quot;pluginType&quot;: &quot;device&quot;, &quot;supportedDevices&quot;: [ {&quot;os&quot;: &quot;Android&quot;, &quot;archived&quot;: false}, {&quot;os&quot;: &quot;iOS&quot;, &quot;type&quot;: &quot;physical&quot;, &quot;archived&quot;: false} ] ... }  rmation Generally, device plugins function in a similar manner to normal client plugins. The available APIs for device plugins are listed in the Desktop Plugin API page. ","version":"Next","tagName":"h3"},{"title":"Creating a simple table plugin​","type":1,"pageTitle":"Plugin structure","url":"/docs/extending/desktop-plugin-structure/#creating-a-simple-table-plugin","content":"Flipper provides a standard abstraction to render data received from a Client plugin in a table, see createTablePlugin in the 'Desktop Plugin API' page. ","version":"Next","tagName":"h3"},{"title":"Validation​","type":1,"pageTitle":"Plugin structure","url":"/docs/extending/desktop-plugin-structure/#validation","content":"Plugin definition can be validated using command flipper-pkg lint. The command shows all the mismatches that need to be fixed to make the plugin definition valid. ","version":"Next","tagName":"h2"},{"title":"Transpilation and bundling​","type":1,"pageTitle":"Plugin structure","url":"/docs/extending/desktop-plugin-structure/#transpilation-and-bundling","content":"Flipper has tooling for transpiling and bundling that enables the creation of plugins in plain ES6 JavaScript or TypeScript. The following are recommended: Use TypeScript for the best development experience.Use .tsx when using TypeScript, which adds support for inline React expressions. You may recall that the Flipper development build automatically transpiles and bundles plugins on loading. It's capable of all ES6 functionality, Flow annotations, TypeScript, as well as JSX, and applies the required babel-transforms. In contrast, the Flipper release build does not transpile or bundle plugins on loading. For production usage, plugins should be bundled before publishing using flipper-pkg. This utility applies the same modifications as the plugin loader of the development build. The flipper-pkg tool is published to npm and should be installed as a devDependency for the plugin package. Then, to bundle the plugin, execute the following command in its folder: yarn flipper-pkg bundle  This command reads the package.json, takes the path specified in the flipperBundleEntry field as entry point, transpiles and bundles all the required code, and outputs the produced bundle to the path specified in field main. You can get the list of other available commands by invoking flipper-pkg help, and get detailed description for any command by invoking flipper-pkg help [COMMAND]. For usage details, see the flipper-pkg page on the npmjs.com web site. ","version":"Next","tagName":"h2"},{"title":"npm dependencies​","type":1,"pageTitle":"Plugin structure","url":"/docs/extending/desktop-plugin-structure/#npm-dependencies","content":"If you need any dependencies in your plugin, you can install them using yarn add.  caution Flipper plugins must be designed to work inside browsers. For that reason, you should avoid using Node.JS APIs directly (such as modules like fs, child_process, path), or packages that depend on them. For alternative APIs, see using Node.js APIs in Flipper plugins. ","version":"Next","tagName":"h2"},{"title":"Extending the Layout Inspector","type":0,"sectionRef":"#","url":"/docs/extending/layout-inspector/","content":"","keywords":"","version":"Next"},{"title":"Android​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#android","content":"","version":"Next","tagName":"h2"},{"title":"NodeDescriptor​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#nodedescriptor","content":"To expose an object to the Layout Inspector in Flipper, you have to implement a NodeDescriptor that describes your object. For example, the ViewDescriptor describes View objects and the FragmentDescriptor describe Fragment instances. These descriptors have a set of callbacks used to expose children and data associated with the object they describe. For the full API, see See NodeDescriptor.java in GitHub. NodeDescriptor implementations should not subclass other NodeDescriptor implementations. Instead, re-use existing behavior from a more generic descriptor, it's best to use a delegate. Following are code snippets that illustrate how to use and how not to use the NodeDescriptor on Android. ","version":"Next","tagName":"h3"},{"title":"How to use the NodeDescriptor on Android​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#how-to-use-the-nodedescriptor-on-android","content":"class ViewGroupDescriptor extends NodeDescriptor&lt;ViewGroup&gt; { public String getName(ViewGroup node) { NodeDescriptor descriptor = descriptorForClass(View.class); return descriptor.getName(node); } }  ","version":"Next","tagName":"h3"},{"title":"How not to use the NodeDescriptor on Android​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#how-not-to-use-the-nodedescriptor-on-android","content":"class ViewGroupDescriptor extends ViewDescriptor&lt;ViewGroup&gt; { public String getName(ViewGroup node) { return super.getName(node); } }  ","version":"Next","tagName":"h3"},{"title":"Register a descriptor​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#register-a-descriptor","content":"Register your descriptor in the DescriptorMapping used to instantiate the InspectorFlipperPlugin: final FlipperClient client = FlipperClient.createInstance(mContext); final DescriptorMapping descriptorMapping = DescriptorMapping.withDefaults(); descriptorMapping.register(MyObject.class, new MyObjectDescriptor()); client.addPlugin(new InspectorFlipperPlugin(mContext, descriptorMapping));  ","version":"Next","tagName":"h3"},{"title":"Extending an existing descriptor​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#extending-an-existing-descriptor","content":"You may not need to create a whole new descriptor. Instead, you may just want to change extend an existing one to expose some new piece of data. In such a case, just locate the correct descriptor and edit its getData, getAttributes, and perhaps setData methods. ","version":"Next","tagName":"h3"},{"title":"iOS​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#ios","content":"","version":"Next","tagName":"h2"},{"title":"SKNodeDescriptor​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#sknodedescriptor","content":"To expose an object to the layout inspector in Sonar, you have to implement a SKNodeDescriptor that describes the object. For example, SKViewDescriptor describes UIView objects, and the SKComponentDescriptor describes CKComponent objects. These descriptors have necessary callbacks that are used to expose its children and data associated with the object they describe. For the full available API, see SKNodeDescriptor.h in GitHub. SKNodeDescriptor implementations should never be subclass other SKNodeDescriptor implementations. Instead, re-use existing behaviour by explicitly using other descriptors and delegate behaviour. Following are code snippets that illustrate how to use and how not to use the SKNodeDescriptor on iOS. ","version":"Next","tagName":"h3"},{"title":"How to use the SKNodeDescriptor on iOS​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#how-to-use-the-sknodedescriptor-on-ios","content":"@interface SKArbitraryViewDescriptor : SKNodeDescriptor&lt;ArbitraryView *&gt; @end @implementation SKArbitraryViewDescriptor - (NSString *)identifierForNode:(ArbitraryView *)node { SKNodeDescriptor *descriptor = [self descriptorForClass:[UIView class]]; return [descriptor identifierForNode:node]; } @end  ","version":"Next","tagName":"h3"},{"title":"How not to use the SKNodeDescriptor on iOS​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#how-not-to-use-the-sknodedescriptor-on-ios","content":"@interface SKArbitraryViewDescriptor : SKViewDescriptor&lt;ArbitraryView *&gt; @end @implementation SKArbitraryViewDescriptor - (NSString *)identifierForNode:(ArbitraryView *)node { return [super identifierForNode:node]; } @end  ","version":"Next","tagName":"h3"},{"title":"Register a Descriptor​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#register-a-descriptor-1","content":"In order to register your descriptor for an object, use SKDescriptorMapper. After registering all descriptors, pass on the descriptor-mapper object to the plugin during initialisation: [descriptorMapper registerDescriptor:[SKArbitraryViewDescriptor new] forClass:[ArbitraryView class]];  There's already a set of descriptors registered by default in SKDescriptorMapper. If you want to add a descriptor to the default set, you can do it in the SKDescriptorMapper. ","version":"Next","tagName":"h3"},{"title":"Extending an existing Descriptor​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#extending-an-existing-descriptor-1","content":"Sometimes, all you need is to extend the functionality of an existing descriptor. In such as case, you just need to locate the correct descriptor and edit the methods dataForNode, attributesForNode, and possibly dataMutationsForNode. ","version":"Next","tagName":"h3"},{"title":"Subdescriptors​","type":1,"pageTitle":"Extending the Layout Inspector","url":"/docs/extending/layout-inspector/#subdescriptors","content":"If you want to extend the SKComponentKitLayoutDescriptor and add an additional section based on the nodes of the SKComponentLayoutDescriptor, you can use SKSubDescriptor: #import &lt;FlipperKitLayoutComponentKitSupport/SKComponentLayoutWrapper.h&gt; NSString *YourSubDescriptor(SKComponentLayoutWrapper *)node { return @&quot;Meta data&quot;; } // At setup time, you must register it: [SKComponentLayoutDescriptor registerSubDescriptor:&amp;YourSubDescriptor forName:@&quot;Section Name&quot;];  Swift support is not yet available because you must access SKComponentLayoutWrapper to implement a subdescriptor. ","version":"Next","tagName":"h3"},{"title":"Dynamically Loading Plugins","type":0,"sectionRef":"#","url":"/docs/extending/loading-custom-plugins/","content":"Dynamically Loading Plugins Flipper loads and runs plugins it finds in a configurable location. The paths searched are specified in ~/.flipper/config.json. These pluginPaths should contain one folder for each of the plugins it stores. An example config setting and plugin file structure is shown below: ~/.flipper/config.json: { ..., &quot;pluginPaths&quot;: [&quot;~/flipper-plugins&quot;] } Plugin File example structure: ~ flipper-plugins/ my-plugin/ package.json src/index.tsx dist/bundle.js note When using npx flipper-pkg init for scaffolding, as explained in the tutorial or on the next page, the path should be configured automatically for you in most cases. Typically, the above setup is only needed if you are developing plugins. To consume plugins, it is recommended to use one of the existing distribution mechanisms","keywords":"","version":"Next"},{"title":"Using Node.js APIs","type":0,"sectionRef":"#","url":"/docs/extending/node-apis/","content":"Using Node.js APIs Flipper plugins must be designed to work inside browsers. For that reason, you should avoid using Node.JS APIs directly (with, for example, modules like fs, child_process, path), or packages that depend on the plugins. The most important Node APIs can be found by using getFlipperLib() (exposed by the flipper-plugin package). Please note that these APIs are all promisified: fs - use getFlipperLib().remoteServerContext.fs instead.child_process - use getFlipperLib().remoteServerContext.childProcess.exec. Note that this API is intended for short lived processes only.path - use import {path} from 'flipper-plugin' instead.os - use getFlipperLib().environmentInfo.os instead. For system-specific directories such as 'home' and 'desktop', use getFlipperLib().paths.homePath and similar. In the future, these APIs may be subject to further security / permission restrictions to better sandbox plugins.","keywords":"","version":"Next"},{"title":"Client Plugin API","type":0,"sectionRef":"#","url":"/docs/extending/create-plugin/","content":"","keywords":"","version":"Next"},{"title":"FlipperPlugin​","type":1,"pageTitle":"Client Plugin API","url":"/docs/extending/create-plugin/#flipperplugin","content":"The plugin implementation that runs on (mobile) applications is called the client plugin in Flipper terminology. To build a client plugin, implement the FlipperPlugin interface. The ID that is returned from your implementation needs to match the name defined in your JavaScript counterpart's package.json. AndroidiOSC++React Native (JS)React (JS) public class MyFlipperPlugin implements FlipperPlugin { private FlipperConnection mConnection; @Override public String getId() { return &quot;MyFlipperPlugin&quot;; } @Override public void onConnect(FlipperConnection connection) throws Exception { mConnection = connection; } @Override public void onDisconnect() throws Exception { mConnection = null; } @Override public boolean runInBackground() { return false; } }  ","version":"Next","tagName":"h2"},{"title":"Using FlipperConnection​","type":1,"pageTitle":"Client Plugin API","url":"/docs/extending/create-plugin/#using-flipperconnection","content":"onConnect will be called when your plugin becomes active. This will provide a FlipperConnection allowing you to register receivers for desktop method calls and respond with data. AndroidiOSC++React Native (JS)React (JS) connection.receive(&quot;getData&quot;, new FlipperReceiver() { @Override public void onReceive(FlipperObject params, FlipperResponder responder) throws Exception { responder.success( new FlipperObject.Builder() .put(&quot;data&quot;, MyData.get()) .build()); } });  ","version":"Next","tagName":"h2"},{"title":"Push data to the desktop​","type":1,"pageTitle":"Client Plugin API","url":"/docs/extending/create-plugin/#push-data-to-the-desktop","content":"You don't have to wait for the desktop to request data. You can also push data directly to the desktop. If the JS plugin subscribes to the same method, it will receive the data. AndroidiOSC++React Native (JS)React (JS) connection.send(&quot;MyMessage&quot;, new FlipperObject.Builder() .put(&quot;message&quot;, &quot;Hello&quot;) .build()  ","version":"Next","tagName":"h2"},{"title":"Using a plugin instance to send data​","type":1,"pageTitle":"Client Plugin API","url":"/docs/extending/create-plugin/#using-a-plugin-instance-to-send-data","content":"It is often useful to get an instance of a Flipper plugin to send data to it: Flipper makes this simple with built-in support. using FlipperClient to obtain a plugin instance​ Plugins should be treated as singleton instances as there can only be one FlipperClient and each FlipperClient can only have one instance of a certain plugin. The Flipper API makes this simple by offering a way to get the current client and query it for plugins. Plugins are identified by the string that their identifier method returns, in this example, 'MyFlipperPlugin'. note Null checks may be required as plugins may not be initialized, such as in production builds. AndroidiOSC++ final FlipperClient client = AndroidFlipperClient.getInstanceIfInitialized(context); if (client != null) { final MyFlipperPlugin plugin = client.getPluginByClass(MyFlipperPlugin.class); plugin.sendData(myData); }  In the above snippet, sendData is an example of a method that might be implemented by the Flipper plugin. ","version":"Next","tagName":"h3"},{"title":"Bi-directional communication demo​","type":1,"pageTitle":"Client Plugin API","url":"/docs/extending/create-plugin/#bi-directional-communication-demo","content":"A minimal communication demo for Android and iOS can be found in the 'Sample' project: Desktop implementationAndroid / iOS For React Native and JavaScript, there is a simple game of Tic Tac Toe: Desktop implementationReact Native implementation / JavaScript (React) implementation ","version":"Next","tagName":"h3"},{"title":"Background plugins​","type":1,"pageTitle":"Client Plugin API","url":"/docs/extending/create-plugin/#background-plugins","content":"In some cases, you may want to provide data to Flipper even when your plugin is not currently active. Returning true in runInBackground() results in onConnect being called as soon as Flipper connects, which enables you to use the connection at any time. For more detals, see the Client Plugin Lifecycle. The advantage of this method is that the desktop plugin can process this data in the background and fire notifications. It also reduces the number of renders and time taken to display the data when the plugin becomes active. danger Please note that a background plugin could keep some data in memory until a Flipper connection is available, such as to keep statistics about the app startup process. However, a plugin shouldn't assume it will eventually get a connection, since this depends on whether the user has enabled the plugin on the Desktop side. It's important to make sure that unbounded amounts of data are not stored! ","version":"Next","tagName":"h2"},{"title":"Plugin Distribution","type":0,"sectionRef":"#","url":"/docs/extending/plugin-distribution/","content":"","keywords":"","version":"Next"},{"title":"Publishing to npm​","type":1,"pageTitle":"Plugin Distribution","url":"/docs/extending/plugin-distribution/#publishing-to-npm","content":"Flipper plugins are essentially standard npm packages, which means you can publish them by executing yarn publish or npm publish in the plugin directory. The only requirements are: package.json and code must follow the Flipper plugin specification Code must be bundled using &quot;flipper-pkg&quot; before packing or publishing. This can be done by executing flipper-pkg bundle on prepack step: { ... &quot;devDependencies&quot;: { ... &quot;flipper-pkg&quot;: &quot;latest&quot; }, &quot;scripts&quot;: { ... &quot;prepack&quot;: &quot;flipper-pkg bundle&quot; } }  ","version":"Next","tagName":"h2"},{"title":"Packaging to File​","type":1,"pageTitle":"Plugin Distribution","url":"/docs/extending/plugin-distribution/#packaging-to-file","content":"To package a plugin as a tarball, you can use the same command as for packaging any other npm package (using yarn pack or npm pack). flipper-pkg also provides a convenient command pack that does the following: Installs the plugin dependencies.Bundles the plugin.Creates the tarball and saves it at the specified location. Example To package a plugin located at ~/flipper-plugins/my-plugin to ~/Desktop, execute the following command: flipper-pkg pack ~/flipper-plugins/my-plugin -o ~/Desktop  ","version":"Next","tagName":"h2"},{"title":"Installation from File​","type":1,"pageTitle":"Plugin Distribution","url":"/docs/extending/plugin-distribution/#installation-from-file","content":"It's possible to install plugins into Flipper from tarballs. This is useful in cases when you need to try a plugin version that is not published to npm, or if you want to distribute plugin privately. Take the following steps: Launch Flipper.Click the 'Manage Plugins' button in the bottom-left corner.Select the 'Install Plugins' tab in the opened sheet.Specify the path to the plugin package (or just drag and drop it) and click 'Install'. ","version":"Next","tagName":"h2"},{"title":"Public Flipper Releases","type":0,"sectionRef":"#","url":"/docs/extending/public-releases/","content":"","keywords":"","version":"Next"},{"title":"Kick-Off​","type":1,"pageTitle":"Public Flipper Releases","url":"/docs/extending/public-releases/#kick-off","content":"A release is kicked off by a special commit that has a subject with the formatFlipper Release vX.Y.Z (see the GitHub example). This is triggered from a bot within Facebook that runs prepare-release.sh. The only thing special about the commit is its subject line. Anyone could run the script and kick off the remaining jobs once the commit lands in main. The commit bumps the version of Flipper Desktop as well as various SDK components and libraries that are to be published to npm and other package repositories. Importantly, it is immediately followed by a 'SNAPSHOT' commit (see the GitHub example), which sets the version of our Java dependencies to X.Y.(Z+1)-SNAPSHOT (that's the patch version incremented by one and a -SNAPSHOT suffix appended). It's a weird Maven-ism that enables us to continuously publish snapshot releases from the main branch. ","version":"Next","tagName":"h2"},{"title":"Desktop Release​","type":1,"pageTitle":"Public Flipper Releases","url":"/docs/extending/public-releases/#desktop-release","content":"The release process for the desktop app is entirely driven by GitHub Actions. The entry point is the release.yml workflow, which is triggered by changes to the desktop/package.json file on the main branch. GitHub Actions has a limitation that we need to work around: it enables push events to act as triggers for a workflow, but not individual commits. This requires us to first scan through all potential commits of a push to identify commits that match the aforementioned versioning schema. This is done through a custom action. If this action is successful, the remaining steps are taken: Check out the versioning commit.Create a git tag for it.Create a GitHub release for the tag.Build releases for Linux, Mac and Windows.Upload all these releases to temporary storage.Download the release artifacts and attach them to the GitHub release.Dispatch to separate workflows for publishing Cocoapods and npm packages (see below). ","version":"Next","tagName":"h2"},{"title":"iOS Release​","type":1,"pageTitle":"Public Flipper Releases","url":"/docs/extending/public-releases/#ios-release","content":"iOS releases are run in GitHub Actions but exist as a separate workflow. They can be triggered in three ways: When a tag is pushed.By manually triggering the workflow (see the following screenshot).Through a dispatch_workflow event that is issued as a last step of the desktop release process.  The workflow follows the default Cocoapods update procedure, bumps and publishes both the Flipper and FlipperKit pod, then creates a Pull Request (PR) containing the updated references. This PR must be manually merged. note Authentication is managed through the secret environment variable COCOAPODS_TRUNK_TOKEN. ","version":"Next","tagName":"h2"},{"title":"npm releases​","type":1,"pageTitle":"Public Flipper Releases","url":"/docs/extending/public-releases/#npm-releases","content":"The JavaScript libraries published as part of a Flipper release closely follow the iOS release procedure. As with the iOS release, it's a workflow that is triggered by one of the three events, which should, in all but exceptional circumstances, be a dispatch event. The workflow is defined in publish-npm.yml. From there, we use a script to bump the versions of our Yarn workspaces, and publish all public packages (flipper, flipper-babel-transformer, ...) and our React Native bindings. note The authentication to npm is managed by a secret environment variable called FLIPPER_NPM_TOKEN. ","version":"Next","tagName":"h2"},{"title":"Android Release​","type":1,"pageTitle":"Public Flipper Releases","url":"/docs/extending/public-releases/#android-release","content":"Android has three types of jobs currently running: snapshot - runs on every commit on the main branch and publishes 'SNAPSHOT' releases to Maven Central. It runs on CircleCI.publish-android - usually triggered by a dispatch_workflow event. It uploads our Java artifacts to Maven Central and attaches the Android sample app to the release page on GitHub. It runs on GitHub Actions.android-sample - runs on every push and open pull request. It builds the sample and tutorial apps and uploads the sample APK as artifact for easy debugging and testing. The snapshot job is an outlier in that it still runs on CircleCI. This gives us some additional capacity as these jobs can take quite a while and the occasional failure due to timeouts or network errors isn't a dealbreaker. ","version":"Next","tagName":"h2"},{"title":"CircleCI Configuration​","type":1,"pageTitle":"Public Flipper Releases","url":"/docs/extending/public-releases/#circleci-configuration","content":"The Android snapshot build is run on CircleCI and configured in .circleci/config.yml. There are two potential points for breakage: Base image - used in the build instructions refers to a specific SDK version and requires occasional updating.Platform installation - runs through the sdkmanager tool of the Android SDK. It may require additional SDKs or NDKs to be installed if they're not part of the base image. One non-obvious aspect is that of authentication for uploads. The repository contains a symmetrically encrypted copy of our credentials to Sonatype (for Maven Central). The snapshot release script decodes the file on the fly by using a secret Circle CI exposes through an environment variable. ","version":"Next","tagName":"h3"},{"title":"GitHub Action Workflow​","type":1,"pageTitle":"Public Flipper Releases","url":"/docs/extending/public-releases/#github-action-workflow","content":"As with the iOS release (see above), the workflow for Android releases is triggered by three types of events: When a tag is pushed.By manually triggering the workflow.Through a dispatch_workflow event, which is issued as a last step of the desktop release process. In normal circumstances, the third event will kick off an Android release build. The workflow is defined in publish-android.yml in GitHub. We first install two NDK versions that are required by our dependencies. To publish release artifacts (non-SNAPSHOT artifacts), that Maven Central, requires them to be signed with a GnuPG key. The only requirement about the key is that it needs to be exported to a Keyserver. Ours is published to the Ubuntu Keyserver. To publish your own key, run the following: gpg --send-keys --keyserver keyserver.ubuntu.com &lt;KEY_ID&gt;  For the initial setup, the secret keyring was exported as gpg2 --export-secret-keys &lt;secret_key_id&gt; | base64 and stored as a secret on GitHub with the name GPG_KEY_CONTENTS. As part of the workflow, it is written to disk after reversing the base64 encoding. The key id and key password are subsequently stored in the gradle.properties along with the path to the key. Paths here need to be absolute, otherwise Gradle will look them up relative to the sub-projects (android/, android/sample, ...). Maven Central is managed by Sonatype. To sign up follow their Getting Started guide, which involves creating a JIRA account and opening an issue to apply for the com.facebook namespace. You will need to find an existing member of this namespace to vouch for you. While this is a bit of a task, it ensures that nobody from outside the organisation can publish under our name. The publish (previously uploadArchives) gradle task uses the OSSRH Sonatype Nexus credentials to upload all Flipper Java artifacts. This includes the core SDK as well as our plugins. The credentials are not your login to Nexus, but the user tokens you can get from your profile. This is followed by the closeAndReleaseRepository gradle task, which is part of the gradle-maven-publish-plugin. It uses the credentials to identify a 'staging repository' and automatically close it. This staging repository is identified by the SONATYPE_STAGING_PROFILE property. Sonatype usually requires people to manually go to a web UI, verify that a given release is complete and click some buttons. The plugin aims to do this for you. Troubleshooting​ There are a few potential 'troubles': Upload fails - Maven Central is (at the time of writing) overloaded with projects migrating from JCenter. The upload task attempts to retry but it can still time out. Manually re-running the job through the GitHub UI should do the trick. Closing fails - as before, this can happen because of timeouts. Retrying to close fails because of duplicate staging repositories - particularly annoying because you can't fix this through automation. It happens when artifacts are uploaded multiple times and now more than one staging repository exists. You must first drop (not close or release) the existing ones before restarting the job. Take the following steps: Go to Staging Repositories.Select the open repositories and click 'Drop'. NDK mismatch - if Gradle complains about a missing NDK, this usually indicates that a dependency has a hard requirement on a particular NDK. You can add it to the list in the sdkmanager command. Artifacts not available - Maven Central syncs with a delay of sometimes a few hours. You can check directly on the Maven2 main server if the artifacts with the new version number are uploaded. ","version":"Next","tagName":"h3"},{"title":"Implementing a Flipper Client","type":0,"sectionRef":"#","url":"/docs/extending/new-clients/","content":"","keywords":"","version":"Next"},{"title":"Establishing a connection​","type":1,"pageTitle":"Implementing a Flipper Client","url":"/docs/extending/new-clients/#establishing-a-connection","content":"Start by connecting to the Flipper server running within the desktop app. Connecting to the server registers your application with Flipper and enables plugins to interact with it. As the Flipper desktop has a different lifecycle than your app and may connect and disconnect at any time, it's important that you continue to attempt to reconnect to the Flipper server until it accepts your connection. The WebSocket protocol is used for communication between desktop and client because it enables easy certificate pinning and functionality, such as with request-response messages. In order to securely connect to Flipper, your client should first obtain a certificate. After the client certificate has been obtained, connect to the following URL with a WebSocket client: localhost:9088/sonar?os={OS} &amp;device={DEVICE} &amp;device_id={DEVICE_ID} &amp;app={APP} &amp;sdk_version={SDK_VERSION} &amp;foreground={FOREGROUND}  The URL parameters are detailed in the following table. Parameter\tDetail\tExampleOS\tThe OS from which the connection is being established. This is usually hard coded into the FlipperClient implementation. This string may be used by the Flipper desktop app to identify valid plugins as well as present in the UI to the user.\tos=Android (If your client is running on Android). DEVICE\tThe name of the device running the application.\tdevice=iPhone7 DEVICE_ID\tA unique identifier for the device. The Flipper server / desktop app may use this to coalesce multiple connections originating from the save device or present the string in the UI to differentiate between connections to different clients. APP\tThe name of the app running this client instance. The combination of OS + DEVICE_ID + APP uniquely identifies a connection.\tapp=Facebook (When connecting to a running facebook app). FOREGROUND (Optional)\tA Boolean indicating whether this connection was established with a foreground process. This is a hint to the Flipper desktop app of whether to re-focus on this connection or not. Though optional, this paramater is recommended.\tforeground=true SDK_VERSION\tA number indicating the latest protocol version with which the client is compatible. You can find the current version in the C++ connection implementation. Usually stored as a constant in the client code, this allows protocol changes to be made whilst still preserving connectivity with old clients. When Flipper desktop encounters an old SDK version, it may attempt to communicate using a matching protocol. However, backwards compatibility is not guaranteed, and you should strive to update clients on the rare occasion that the protocol version advances.\t ","version":"Next","tagName":"h2"},{"title":"Responding to messages​","type":1,"pageTitle":"Implementing a Flipper Client","url":"/docs/extending/new-clients/#responding-to-messages","content":"Flipper uses a simple Remote Procedure Call (RPC) protocol using JSON-formatted payloads: The method field of the payload indicates which method of the FlipperClient is being called. This will always be present.The payload field contains the JSON parameters for the method call. This may be omitted when no parameters are used. It is recommended that implementations gracefully ignore extra fields for the sake of backwards and forwards compatibility. Responses contain either a success object representing the return value of the RPC invocation or an error object indicating that an error occurred. ","version":"Next","tagName":"h2"},{"title":"Methods​","type":1,"pageTitle":"Implementing a Flipper Client","url":"/docs/extending/new-clients/#methods","content":"The methods detailed in the following sub-sections must be implemented by all FlipperClient implementations. The syntax used for these type definitions is Flow. All requests/responses are JSON objects. Where no Response type is specified, it's a void call - no response is expected. getPlugins​ Return the available plugins as a list of identifiers. A plugin identifier is a string which is matched with the plugin identifier of desktop javascript plugins. This allows the client to specify the plugins it supports. Request = { &quot;method&quot;: &quot;getPlugins&quot;, } Response = { &quot;success&quot;: { &quot;plugins&quot;: Array&lt;string&gt; }, }  getBackgroundPlugins​ Returns a subset of the available plugins returned by getPlugin. The background connections will automatically receive a connection from Flipper once it starts (and if the plugins are enabled), rather than waiting for the user to open the plugin. Request = { &quot;method&quot;: &quot;getBackgroundPlugins&quot;, } Response = { &quot;success&quot;: { &quot;plugins&quot;: Array&lt;string&gt; }, }  init​ Initialize a plugin. This should result in an onConnected call on the appropriate plugin. Plugins should by nature be lazy and should not be initialized up front as this may incur significant cost. The Flipper desktop client knows when a plugin is needed and should control when to initialize them. Request = { &quot;method&quot;: &quot;init&quot;, &quot;params&quot;: { &quot;plugin&quot;: string, }, }  deinit​ This is the opposite of init. A call to deinit is made when a plugin is no longer needed and should release any resources. Don't rely only on deinit to release plugin resources as Flipper may quit without having the chance to issue a deinit call. In such ases, you should also rely on the WebSocket disconnect callbacks. This call is mainly for allowing the desktop app to control the lifecycle of plugins. Request = { &quot;method&quot;: &quot;deinit&quot;, &quot;params&quot;: { &quot;plugin&quot;: string, }, }  execute​ This is the main call and how the Flipper desktop plugins and client plugins communicate. When a javascript desktop plugin issues a client request, it will be wrapped in one of these execute calls. This execute indicates that the call should be redirected to a plugin: request.params.api - the plugin id.request.params.method - the method within the plugin to execute.request.params.params - an optional params object containing the parameters to the RPC invocation. Request = { &quot;method&quot;: &quot;execute&quot;, &quot;params&quot;: { &quot;api&quot;: string, &quot;method&quot;: string, &quot;params&quot;: ?Object, }, } Response = { &quot;success&quot;: Object, } | { &quot;error&quot;: Object, }  ","version":"Next","tagName":"h3"},{"title":"Error Reporting​","type":1,"pageTitle":"Implementing a Flipper Client","url":"/docs/extending/new-clients/#error-reporting","content":"The Flipper desktop app handles error reporting. If an error occurs during the execution of an RPC invocation, it returns a serialization of it in the response so it can be attributed to the method call. If an error occurs in some other context, you can proactively send it to Flipper with the following request structure: Request = { error: { message: string, stacktrace: string, } }  While in development mode, Flipper will display any client errors next to javascript errors in the Chrome Developer Tools console. ","version":"Next","tagName":"h2"},{"title":"Testing​","type":1,"pageTitle":"Implementing a Flipper Client","url":"/docs/extending/new-clients/#testing","content":"Testing is incredibly important when building core infrastructure and tools. The following is pseudocode for tests any new FlipperClient implementation is expected to implement and correctly execute. To run tests, it's strongly recommended that you to build a mock for the WebSocket connection to mock out the desktop side of the protocol and to not have any network dependencies in your test code. test(&quot;GetPlugins&quot;, { let connection = new MockConnection(); let client = new FlipperClient(connection); let plugin = {id: &quot;test&quot;}; client.addPlugin(plugin); client.start(); connection.onReceive({ id: 1, method: &quot;getPlugins&quot;, }); assert(connection.sentMessages, contains({ id: 1, success:{ plugins: [&quot;test&quot;], }, })); });  test(&quot;InitDeinit&quot;, { let connection = new MockConnection(); let client = new FlipperClient(connection); let plugin = {id: &quot;test&quot;, connected: false}; client.addPlugin(plugin); client.start(); assertFalse(plugin.connected); connection.onReceive({ id: 1, method: &quot;init&quot;, params: { plugin: &quot;test&quot;, }, }); assertTrue(plugin.connected); connection.onReceive({ id: 1, method: &quot;deinit&quot;, params: { plugin: &quot;test&quot;, }, }); assertFalse(plugin.connected); });  test(&quot;Disconnect&quot;, { let connection = new MockConnection(); let client = new FlipperClient(connection); let plugin = {id: &quot;test&quot;, connected: false}; client.addPlugin(plugin); client.start(); assertFalse(plugin.connected); connection.onReceive({ id: 1, method: &quot;init&quot;, params: { plugin: &quot;test&quot;, }, }); assertTrue(plugin.connected); connection.disconnect(); assertFalse(plugin.connected); });  test(&quot;Execute&quot;, { let connection = new MockConnection(); let client = new FlipperClient(connection); let plugin = { id: &quot;test&quot;, reverse: (params, responder) =&gt; { responder.success({word: params.word.reverse()}); }, }; client.addPlugin(plugin); client.start(); connection.onReceive({ id: 1, method: &quot;init&quot;, params: { plugin: &quot;test&quot;, }, }); connection.onReceive({ id: 1, method: &quot;execute&quot;, params: { api: &quot;test&quot;, method: &quot;reverse&quot;, params: { word: &quot;hello&quot; }, }, }); assert(connection.sentMessages, contains({ id: 1, success:{ word: &quot;olleh&quot;, }, })); });  ","version":"Next","tagName":"h2"},{"title":"Style Guide","type":0,"sectionRef":"#","url":"/docs/extending/style-guide/","content":"Style Guide The Style Guide is only available in a browser environment.","keywords":"","version":"Next"},{"title":"Migrating a Plugin to Sandy","type":0,"sectionRef":"#","url":"/docs/extending/sandy-migration/","content":"","keywords":"","version":"Next"},{"title":"Opting in to Sandy​","type":1,"pageTitle":"Migrating a Plugin to Sandy","url":"/docs/extending/sandy-migration/#opting-in-to-sandy","content":"Converting a Flipper plugin to use Sandy is best done by running Flipper from source. For open-source users, clone the repository and run yarn install in the desktop folder. Enabling Sandy for a plugin requires two steps: The flipper-plugin should be added as peer dependency to the package.json of the plugin: &quot;peerDependencies&quot;: { &quot;flipper-plugin&quot;: &quot;*&quot; },  Make sure to run yarn install again in the desktop/ folder. Sandy is now enabled for this plugin&quot; the plugin has to be restructured to the new architecture, which you'll be able to do in the next step. ","version":"Next","tagName":"h2"},{"title":"Using Sandy for state and connection management​","type":1,"pageTitle":"Migrating a Plugin to Sandy","url":"/docs/extending/sandy-migration/#using-sandy-for-state-and-connection-management","content":"The goal of this step is to use and leave the plugin UI largely as is but convert state and connection management to use the new Sandy APIs as exposed through the flipper-plugin package. Compared to 'classic' plugins, there are a few fundamental differences when it comes to the plugin structure of Sandy plugins. A class extending from FlipperPlugin that is exported as default is no longer used to define a plugin. Instead, a plugin definition consists of two parts: A definition of the state and logic of the plugin that is exported under the name plugin: export function plugin(client: PluginClient&lt;Events, Methods&gt;) { ... }. Most of the state and all connection logic will move here.A definition of the root of the UI is exported under the name Component: export function Component() { ... } There are a few conceptual changes that are important to understand, as they are different compared to classic plugins: The plugin function is called exactly once when a plugin is set up for an application. This means that all state that is created inside the plugin definition is kept as long as the app is connected, even when the user is navigating away. It used to be necessary to use persistedState for this kind of state, but that is no longer the case. In contrast, the Component component is mounted whenever the user opens the plugin, so any state stored locally in that React component will be lost if the user navigates away. It's recommended avoiding this and, instead, store state (including selection) in the plugin definition, using the createState abstraction. The relation between plugin, its parameter client, and how to use it in your Component definition is documented in detail in the Plugin Declaration section. Please read it before continuing as it explains in detail how to manage state, handle receiving and sending data, and testing. The full set of available APIs on client is documented in the Desktop Plugin API page. This step is completed if the plugin follows the next plugin / component structure and is working again. Make sure to test extensively! ","version":"Next","tagName":"h2"},{"title":"Tips​","type":1,"pageTitle":"Migrating a Plugin to Sandy","url":"/docs/extending/sandy-migration/#tips","content":"To quickly verify the plugin compiles, the simplest way is to keep yarn tsc -w running in the desktop folder.Similarly yarn watch can be used to run the unit tests in watch mode. Use the p key to filter for your specific plugin if jest doesn't do so automatically.For an example of migrating the network plugin to use Sandy APIs, see diff D24108772 / Github commit.For an example of migrating the example plugin to use Sandy APIs, see diff D22308265 / Github commit.Other plugins that can be checked for inspiration are Logs and Network plugins.These steps typically don't change the UI much or touch other files than index.tsx. Typically, the root component needs to be changed, but most other components can remain as is. However, if a ManagedTable is used (see the next section), it might be easier to already convert the table in this step.Sandy has first class support for unit testing your plugin and mocking device interactions. Please do set up unit tests per documentation linked above!If the original plugin definition contained state, it is recommended to create one new state atoms (createState) per field in the original state, rather than having one big atom.If the original plugin definition contained persistedState, it is recommended to create one new state atoms (createState) per field in the original state, rather than having one big atom. By setting the persist option of the state, you can make sure this piece of state becomes part of the import / export functionality of Flipper. Which is important if the data stored here is relevant for bug reports.For deeply nested state updates, using state.update is often simpler than using state.set, as it uses Immer under the hood to make immutable state updates straight forward.For the same reason, you don't need to shallowly clone your state anymore, as long as state.update is used for state updates.When dealing a lot with promises, using async / await is usually simpler. ","version":"Next","tagName":"h3"},{"title":"Migration table​","type":1,"pageTitle":"Migrating a Plugin to Sandy","url":"/docs/extending/sandy-migration/#migration-table","content":"Some abstractions that used to be static methods on FlipperPlugin are now exposed from the client object. Following are a few examples: Old\tNewpersistedState\tUse createState and set the persist option persistedStateReducer\tCreate message handlers and update the state objects directly exportPersistedState\tUse the client.onExport hook getActiveNotifications\tUse client.showNotification for persistent notifications, or message / notification from antd for one-off notifications. createTablePlugin\tTBD, so these conversions can be skipped for now init\tclient.onReady ","version":"Next","tagName":"h3"},{"title":"Using Sandy / Ant.design to organise the plugin UI​","type":1,"pageTitle":"Migrating a Plugin to Sandy","url":"/docs/extending/sandy-migration/#using-sandy--antdesign-to-organise-the-plugin-ui","content":"The goal of this step is to update the UI of the plugin to use Sandy / Ant Design components. These will provide a more consistent user experience, usually provide better UX and they support dark mode! Roughly speaking this typically involves replacing all imported components with their modern counterpart. For Sandy plugins, components can be found here: Interactive data displaying components are exposed from flipper-plugin: DataTable (for tables), DataInspector (for JSON trees) and ElementInspector (for element trees).flipper-plugin also provides the primitives to organise the Layout of the plugin.Practically all other, more generic components are provided by Ant Design, a proven mature open source component library, which is much richer than the components that are offered from flipper. In Sandy, the layout is typically built by using a combination of the following: Layout.Top (or .Right, .Left, .Bottom), which divides all available space in a fixed and dynamic sectionLayout.Scrollable, which takes all available space and provides scrollbars if its content is still greater,Layout.Container which organizes paddings, borders and spacing between elements etc. Generally, it's recommended not to use margins; use padding and gap instead. Ideally, use theme.spacing to get standard numbers for margins and paddings instead of hard-coded numbers. This will help with achieving consistency in look and feel. ","version":"Next","tagName":"h2"},{"title":"Design resources​","type":1,"pageTitle":"Migrating a Plugin to Sandy","url":"/docs/extending/sandy-migration/#design-resources","content":"There are three important resources to check for documentation on the components available: Flipper style guide - a general overview of the Flipper design system that demonstrates colors, typography and creating layouts including some examples.Ant Design component overviewAPI reference documentation for the components provided by flipper-plugin ","version":"Next","tagName":"h3"},{"title":"Old and new components​","type":1,"pageTitle":"Migrating a Plugin to Sandy","url":"/docs/extending/sandy-migration/#old-and-new-components","content":"For conversion, the following table maps the old components to the new ones: Old flipper component\tNew component\tProviding package\tNotesDetailsSidebar\tDetailsSidebar\tflipper-plugin\tas-is Sidebar\tLayout.Top (or .Right, .Left, .Bottom)\tflipper-plugin\tSet the resizable flag to allow the user to resize the pane. FlexColumn / Pane / View\tLayout.Container\tflipper-plugin\tUse the gap property to provide some spacing between the children! FlexRow\tLayout.Horizontal\tflipper-plugin\tUse the gap property to provide some spacing between the children! Scrollable\tLayout.ScrollContainer\tflipper-plugin Link\tTypography.Link\tantd Text / Heading\tTypography.Text / Typography.Title\tantd Button\tButton\tantd Glyph\tIcon\tantd ManagedDataTable\tDataTable\tflipper-plugin\tRequires state to be provided by a createDataSource ManagedDataInspector / DataInspector\tDataInspector\tflipper-plugin ManagedElementInspector / ElementInspector\tElementInspector\tflipper-plugin Panel\tPanel\tflipper-plugin Tabs / Tab\tTabs / Tab\t`flipper-plugin\tNote that Tab's title property is now called tab. Most other components, such as select elements, tabs, and date-pickers can all be found in the Ant documentation. ","version":"Next","tagName":"h3"},{"title":"Theming & custom styled components​","type":1,"pageTitle":"Migrating a Plugin to Sandy","url":"/docs/extending/sandy-migration/#theming--custom-styled-components","content":"Creating your own components / styling using styled is still supported. But ideally, you should need custom styled components a lot less! Since Sandy plugins are expected to support dark mode, (use the settings pane to quickly toggle), it's recommended not to use hard-coded colors. Instead, use one of the semantic colors that are provided through the theme object that can be imported from flipper-plugin. Ideally, there should be no hard-coded colors anymore either, and little need to use width: 100% / height: 100% anywhere, as needing those typically signals a layout issue. Tip It's recommended to keep components as much as possible outside the entry file, as components defined outside the index.tsx file will benefit from fast refresh. ","version":"Next","tagName":"h3"},{"title":"Wrapping up​","type":1,"pageTitle":"Migrating a Plugin to Sandy","url":"/docs/extending/sandy-migration/#wrapping-up","content":"This step of the process is completed as soon as there are no imports from the flipper package anymore. Don't forget to remove flipper from the peerDependencies in the package.json section if present. If you have any questions, feel free to reach out to the Flipper Support Workplace group. ","version":"Next","tagName":"h3"},{"title":"Power Search","type":0,"sectionRef":"#","url":"/docs/extending/power-search/","content":"","keywords":"","version":"Next"},{"title":"Simplified config​","type":1,"pageTitle":"Power Search","url":"/docs/extending/power-search/#simplified-config","content":"Power search provides a list of default predicates for every column data type. You can specify the column data type like this: import {DataTableColumn} from 'flipper-plugin' type MyRow = { timestamp: number; eventType: string; } const columns: DataTableColumn&lt;MyRow&gt;[] = [ { key: 'timestamp', title: 'Timestamp', sortable: true, powerSearchConfig: {type: 'dateTime'}, }, { key: 'eventType', title: 'Event', powerSearchConfig: {type: 'enum'} }, ]  Complete list of possible &quot;types&quot;. ","version":"Next","tagName":"h2"},{"title":"Advanced config​","type":1,"pageTitle":"Power Search","url":"/docs/extending/power-search/#advanced-config","content":"If the default list of predicates is not tailored enouhg for your use-case, you can provide a list of predicates explicitly. import {DataTableColumn, dataTablePowerSearchOperators} from 'flipper-plugin' type MyRow = { timestamp: number; eventType: string; } const EVENT_TYPE_ENUM_LABELS = { yodaValue: 'Yoda Label', lukeValue: 'Luke Label' } const columns: DataTableColumn&lt;MyRow&gt;[] = [ { key: 'timestamp', title: 'Timestamp', sortable: true, powerSearchConfig: [ dataTablePowerSearchOperators.same_as_absolute_date_no_time(), ] }, { key: 'eventType', title: 'Event', powerSearchConfig: { // You can also provide power search config as an object operators: [ dataTablePowerSearchOperators.enum_is(EVENT_TYPE_ENUM_LABELS), dataTablePowerSearchOperators.enum_is_not(EVENT_TYPE_ENUM_LABELS), ], // It could have exra options // See https://github.com/facebook/flipper/blob/main/desktop/flipper-plugin/src/ui/data-table/DataTableWithPowerSearch.tsx#L157 } }, ]  ","version":"Next","tagName":"h2"},{"title":"Using legacy search​","type":1,"pageTitle":"Power Search","url":"/docs/extending/power-search/#using-legacy-search","content":"While we would encourage using the new power search, some plugins might decide to stick to the legacy experience. To do that you have to use different imports from 'flipper-plugin': MasterDetailLegacy instead of MasterDetail, DataTableLegacy instead of DataTable, DataTableColumnLegacy instead of DataTable, DataTableManagerLegacy instead of DataTableManager. import {MasterDetailLegacy, DataTableColumnLegacy} from 'flipper-plugin'; const columns: DataTableColumnLegacy&lt;MyRow&gt;[] = [ // colun definition ] export const Component = () =&gt; { return &lt;MasterDetailLegacy columns={columns} /* ...other props */ /&gt; }  ","version":"Next","tagName":"h2"},{"title":"Examples​","type":1,"pageTitle":"Power Search","url":"/docs/extending/power-search/#examples","content":"You can see a live examplse of how you can provide the power search config here: LogsNetworkIntern-only.  You can find the complete list of supported operators here. ","version":"Next","tagName":"h2"},{"title":"Styling Components","type":0,"sectionRef":"#","url":"/docs/extending/styling-components/","content":"","keywords":"","version":"Next"},{"title":"Basic tags​","type":1,"pageTitle":"Styling Components","url":"/docs/extending/styling-components/#basic-tags","content":"For basic building blocks (views, texts, and so on), you can use the styled object, as shown below: import {styled} from 'flipper-plugin'; const MyView = styled.div({ fontSize: 10, color: colors.red }); const MyText = styled.span({ ... }); const MyImage = styled.img({ ... }); const MyInput = styled.input({ ... });  ","version":"Next","tagName":"h2"},{"title":"Extending Flipper Components​","type":1,"pageTitle":"Styling Components","url":"/docs/extending/styling-components/#extending-flipper-components","content":"In some cases, it's required to customize Ant or Flipper's components in some way. For example, changing colors, alignment, or wrapping behavior. Flippers components can be wrapped using the styled function which allows adding or overwriting existing style rules. import {Layout, styled} from 'flipper-plugin'; const Container = styled(Layout.Container)({ alignItems: 'center', }); function MyComponent { return &lt;Container&gt;...&lt;/Container&gt;; }  ","version":"Next","tagName":"h2"},{"title":"CSS​","type":1,"pageTitle":"Styling Components","url":"/docs/extending/styling-components/#css","content":"The CSS-in-JS object passed to the styled components takes any CSS rule but uses came-cased keys for the properties. Pixel-values can be numbers. Any other values need to be strings. The style object can also be returned from a function for dynamic values. Props can be passed to the styled component using React, as follows: const MyView = styled.div( props =&gt; ({ fontSize: 10, color: =&gt; (props.disabled ? 'red' : 'black'), }) ); // usage &lt;MyView disabled /&gt;  Pseudo-classes can be as follows: '&amp;:hover': {color: 'red'}`  Children can be matched by using normal CSS selectors. This makes it possible to customize Ant components as well: '.ant-btn-primary': {color: 'yellow'}  ","version":"Next","tagName":"h2"},{"title":"Colors​","type":1,"pageTitle":"Styling Components","url":"/docs/extending/styling-components/#colors","content":"The theme module contains all standard colors used by Flipper. All available colors can be previewed in the style guide. The colors exposed here handles dark mode automatically, so it's recommended to use those colors over hardcoded ones. import {theme} from 'flipper-plugin'  ","version":"Next","tagName":"h2"},{"title":"Implementing Layout Inspection","type":0,"sectionRef":"#","url":"/docs/extending/supporting-layout/","content":"","keywords":"","version":"Next"},{"title":"Node​","type":1,"pageTitle":"Implementing Layout Inspection","url":"/docs/extending/supporting-layout/#node","content":"Node is the core data type of the layout inspector. The Flipper desktop plugin visualizes a tree of nodes with associated data and attributes. Any UI or data model which can be modeled as a tree of nodes can be inspected using the layout inspector. Data associated with the nodes can also be edited. type NodeId = string; type InspectorValue = { __type__: 'auto' | 'text' | 'number' | 'boolean' | 'enum' | 'color', __mutable__: boolean, value: number | string | boolean, }; type Node = { id: NodeId, name: string, data: ?{string: Object}, children: Array&lt;NodeId&gt;, attributes: ?Array&lt;{name: string, value: string}&gt;, decoration: ?string, };  ","version":"Next","tagName":"h2"},{"title":"Node Parameters​","type":1,"pageTitle":"Implementing Layout Inspection","url":"/docs/extending/supporting-layout/#node-parameters","content":"Following is a description of the parameters used in the above node: id - a stable, globally unique, node identifier.name - the user-facing identifier for this node. It does not need to be unique. Typically, the class name of the node is used as the node's name.data - a set of named JSON objects representing data associated with the node. This 'data' is rendered as immutable, by default, to the user of the plugin but can be made mutable by wrapping any value in a 'InspectorValue' with the __mutable__ attribute set to true. The 'InspectorValue' can also be used to change the parsed type of the value, such as parsing a number as a color to show the value in a color picker. children - a list of identifiers pointing to children of this node. This is a list of identifiers instead of a list of nodes to allow nodes to be lazily fetched and instantiated.attributes- a list of key-value pairs, which are displayed alongside the name in the Layout Inspector.decoration - a string identifying the optional icon used to decorate a node in the Layout Inspector. Adding new decoration options requires adding an icon file to the Sonar desktop app. Currently, ComponentKit and Litho decorations are supported. ","version":"Next","tagName":"h3"},{"title":"Plugin Interface​","type":1,"pageTitle":"Implementing Layout Inspection","url":"/docs/extending/supporting-layout/#plugin-interface","content":"interface ClientLayoutPlugin { Node getRoot(); GetNodesResponse getNodes({ids: Array&lt;NodeId&gt;}); GetAllNodesResponse getAllNodes(); void setData({id: NodeId, path: Array&lt;string&gt;, value: any}); void setHighlighted({id: ?NodeId}); void setSearchActive({active: boolean}); GetSearchResultsResponse getSearchResults({query: string}); }; interface DesktopLayoutPlugin { void invalidate({id: NodeId}); void select({path: Array&lt;NodeId&gt;}); }; type GetNodesResponse = { elements: Array&lt;Node&gt; }; type GetAllNodesResponse = { elements: Array&lt;Node&gt;, rootElement: NodeId }; type GetSearchResultsResponse = { results: ?SearchResultNode, query: string }; type SearchResultNode = { id: NodeId, isMatch: boolean, element: Node, children: ?Array&lt;SearchResultNode&gt; } type NodeId = string;  ","version":"Next","tagName":"h2"},{"title":"Interface methods​","type":1,"pageTitle":"Implementing Layout Inspection","url":"/docs/extending/supporting-layout/#interface-methods","content":"getRoot - returns the root node of your hierarchy. This is the entry point of Flipper's traversal of your layout.getNodes - maps a set of Node Ids to their corresponding nodes. This call is used to, among other things, query the children of a node.getAllNodes - similar to 'getNodes', this should return all nodes in the current layout tree. Ordinarily, nodes are requested lazily, however this exists for taking snapshots of the current state.setData - set the data of an mutable data object returned as part of the data field of a node: The id parameter identifies the node.The path parameter is an index path into an object, such as ['bounds', 'left'].The value parameter is a value of appropriate type to be used as an override. setHighlighted - marks a node as highlighted. It is expected that implementations add a colored overlay to the node identified by id on screen, so that as the user browses the layout tree in Flipper, they can easily see on the client display the nodes with which they are interacting. Passing a null id parameter removes the current highlight without highlighting a new node.setSearchActive - the user has clicked on the crosshair button in Sonar. This feature allows the user to click on an element in the client UI to cause Flipper to highlight the corresponding node in the layout tree. A colored overlay should be shown over the whole screen until setSearchActive is called with active: false. While setSearchActive is true. Clicking an element in the client UI should trigger a select call to the Flipper desktop, with the path of ids from root to selected node, for example, select(['node1', 'node6', 'node65']) to select a grandchild of node1.getSearchResults - executes a query on all nodes in the tree and returns a subtree of the layout tree that contains all matching nodes and those on the path from root. A parent that does not itself match the query but exists on the path to a node that does, should have the attribute isMatch: false and only the matching nodes should have isMatch: true. Nodes not on the path from root to a match need not be included in the returned tree. Be careful not to confuse this method with the unrelated setSearchActive, which unfortunately shares a similar name. note Whenever a node or subtree changes, it is expected that the client sends a invalidate command to the desktop app over the active connection. This invalidates the cache of the subtree anchored by the node with the given id. ","version":"Next","tagName":"h3"},{"title":"Testing React Native Changes in the Sample App","type":0,"sectionRef":"#","url":"/docs/extending/testing-rn/","content":"","keywords":"","version":"Next"},{"title":"Publishing a Local Release​","type":1,"pageTitle":"Testing React Native Changes in the Sample App","url":"/docs/extending/testing-rn/#publishing-a-local-release","content":"First, create a unique version number. This step is optional but is helpful to prevent accidentally testing against the wrong version. In the top-level gradle.properties, change the version: ... # POM publishing constants VERSION_NAME=0.44.99-SNAPSHOT # Change this one. GROUP=com.facebook.flipper ...  Now, run ./gradlew installArchives -PRELEASE_SIGNING_ENABLED=false in the root of the repository. This will place the artifact files in your local ~/.m2/repository folder. ","version":"Next","tagName":"h2"},{"title":"Using the new Release​","type":1,"pageTitle":"Testing React Native Changes in the Sample App","url":"/docs/extending/testing-rn/#using-the-new-release","content":"Usually, you need to change your project to also pick up files in mavenLocal(). As this is already done, you can directly change the FLIPPER_VERSION to the previously used identifier in react-native/ReactNativeFlipperExample/android/gradle.properties: # Version of flipper SDK to use with React Native FLIPPER_VERSION=0.30.2 FLIPPER_VERSION=0.44.99-SNAPSHOT  Now run yarn android to rebuild, install and launch the RN sample app. To test further changes, rerun the ./gradlew installArchives -PRELEASE_SIGNING_ENABLED=false and yarn android steps. ","version":"Next","tagName":"h2"},{"title":"Full Diff​","type":1,"pageTitle":"Testing React Native Changes in the Sample App","url":"/docs/extending/testing-rn/#full-diff","content":"For a quick overview, here are the two changes you need to make: diff --git a/gradle.properties b/gradle.properties index 1ccd002a..100a7169 100644 --- a/gradle.properties +++ b/gradle.properties @@ -4,7 +4,7 @@ # LICENSE file in the root directory of this source tree. # POM publishing constants -VERSION_NAME=0.44.1-SNAPSHOT +VERSION_NAME=0.44.99-SNAPSHOT GROUP=com.facebook.flipper POM_URL=https://github.com/facebook/flipper POM_SCM_URL=https://github.com/facebook/flipper.git diff --git a/react-native/ReactNativeFlipperExample/android/gradle.properties b/react-native/ReactNativeFlipperExample/android/gradle.properties index 495c12e8..bc815d0e 100644 --- a/react-native/ReactNativeFlipperExample/android/gradle.properties +++ b/react-native/ReactNativeFlipperExample/android/gradle.properties @@ -30,4 +30,4 @@ android.useAndroidX=true android.enableJetifier=true # Version of flipper SDK to use with React Native -FLIPPER_VERSION=0.30.2 +FLIPPER_VERSION=0.44.99-SNAPSHOT  ","version":"Next","tagName":"h2"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/features/","content":"","keywords":"","version":"Next"},{"title":"Build your own plugin​","type":1,"pageTitle":"Introduction","url":"/docs/features/#build-your-own-plugin","content":"The Flipper desktop app and the mobile native SDK establish a connection that is used to send data to and from the device. Flipper does not make any restrictions on what kind of data is being sent. This enables a lot of different use-cases where you want to better understand what is going inside your app. For example, you can visualize the state of local caches, events happening or trigger actions on your app from the desktop. If there is no plugin that does exactly what you want, you can build your own plugin tailored to your needs. A plugin always consists of the native implementation sending and receiving data and the desktop plugin visualizing data: the native implementations are written in Java, Objective-C, or C++, the desktop UI is written in React. To learn more and build your own plugin, see the Creating Plugins section of the Flipper Docs. ","version":"Next","tagName":"h2"},{"title":"Crash Reporter Plugin","type":0,"sectionRef":"#","url":"/docs/features/plugins/crash-reporter/","content":"Crash Reporter Plugin → See setup instructions for the Crash Reporter plugin The Crash Reporter plugin shows a notification in Flipper whenever an app crashes. For Android, clicking on the 'Open in Logs' button jumps to the relevant row in the Logs plugin containing the crash information, as shown in the following screenshots.","keywords":"","version":"Next"},{"title":"Logs Plugin","type":0,"sectionRef":"#","url":"/docs/features/plugins/device-logs/","content":"","keywords":"","version":"Next"},{"title":"Databases Plugin","type":0,"sectionRef":"#","url":"/docs/features/plugins/databases/","content":"","keywords":"","version":"Next"},{"title":"Plugin functionality​","type":1,"pageTitle":"Databases Plugin","url":"/docs/features/plugins/databases/#plugin-functionality","content":"The plugin provides the following functionality: Browse table data.Examine table structure.Execute queries.Mark queries as favorites.Read the logs of previously executed queries. ","version":"Next","tagName":"h2"},{"title":"Examine table structure​","type":1,"pageTitle":"Databases Plugin","url":"/docs/features/plugins/databases/#examine-table-structure","content":"The following screenshot shows the structure of the 'ranking' table.  ","version":"Next","tagName":"h3"},{"title":"Execute queries​","type":1,"pageTitle":"Databases Plugin","url":"/docs/features/plugins/databases/#execute-queries","content":"The following screenshot shows the recordset resulting from execution of the 'statusranking' query.  ","version":"Next","tagName":"h3"},{"title":"Plugin functionality​","type":1,"pageTitle":"Logs Plugin","url":"/docs/features/plugins/device-logs/#plugin-functionality","content":"","version":"Next","tagName":"h2"},{"title":"Filtering​","type":1,"pageTitle":"Logs Plugin","url":"/docs/features/plugins/device-logs/#filtering","content":"The search bar can be used to search for logs and act as a filter for certain types. From the context menu on the table headers, you can show additional information, such as timestamp, PID or TID. Clicking on a tag, PID or TID in the table filters only for logs with the same value. ","version":"Next","tagName":"h3"},{"title":"Expression Watcher​","type":1,"pageTitle":"Logs Plugin","url":"/docs/features/plugins/device-logs/#expression-watcher","content":"The Expression Watcher in the sidebar can be used to 'watch' for certain logs to happen and count how often they occur. An expression can be a simple string, or a regular expression, matched against the logs. When the notify checkbox is enabled, Flipper sends notifications once the log is being processed. This lets you know when the 'watcher' triggered, even if Flipper is in the background. ","version":"Next","tagName":"h3"},{"title":"Testing","type":0,"sectionRef":"#","url":"/docs/extending/testing/","content":"","keywords":"","version":"Next"},{"title":"Writing tests​","type":1,"pageTitle":"Testing","url":"/docs/extending/testing/#writing-tests","content":"This section covers desktop plugins and client plugins. ","version":"Next","tagName":"h2"},{"title":"Desktop plugins​","type":1,"pageTitle":"Testing","url":"/docs/extending/testing/#desktop-plugins","content":"Flipper uses Jest as a unit testing framework. Writing unit tests for Flipper Desktop plugins is covered in detail in the Building a Desktop Plugin tutorial. The flipper-plugin package provide several test utilities to make testing more convenient. ","version":"Next","tagName":"h3"},{"title":"Client plugins​","type":1,"pageTitle":"Testing","url":"/docs/extending/testing/#client-plugins","content":"AndroidiOS Start by creating your first test file in this directory MyFlipperPluginTest.java. In the test method body, is the plugin to be tested as well as a FlipperConnectionMock. The following example asserts that the plugin's connected status is what is expected: @RunWith(RobolectricTestRunner.class) public class MyFlipperPluginTest { @Test public void myTest() { final MyFlipperPlugin plugin = new MyFlipperPlugin(); final FlipperConnectionMock connection = new FlipperConnectionMock(); plugin.onConnect(connection); assertThat(plugin.connected(), equalTo(true)); } } There are two mock classes that are used to construct tests: FlipperConnectionMock and FlipperResponderMock. Together these can be used to write very powerful tests to verify the end-to-end functionality of your plugin. For example, you can test if, for a given incoming message, your plugin responds as expected: @Test public void myTest() { final MyFlipperPlugin plugin = new MyFlipperPlugin(); final FlipperConnectionMock connection = new FlipperConnectionMock(); final FlipperResponderMock responder = new FlipperResponderMock(); plugin.onConnect(connection); final FlipperObject params = new FlipperObject.Builder() .put(&quot;phrase&quot;, &quot;flipper&quot;) .build(); connection.receivers.get(&quot;myMethod&quot;).onReceive(params, responder); assertThat(responder.successes, hasItem( new FlipperObject.Builder() .put(&quot;phrase&quot;, &quot;ranos&quot;) .build())); }  ","version":"Next","tagName":"h2"},{"title":"Running (Flipper) tests​","type":1,"pageTitle":"Testing","url":"/docs/extending/testing/#running-flipper-tests","content":"This section covers running tests on the Flipper Desktop and with the Flipper SDK. ","version":"Next","tagName":"h2"},{"title":"Flipper Desktop​","type":1,"pageTitle":"Testing","url":"/docs/extending/testing/#flipper-desktop","content":"Run yarn jest or yarn jest --watch in the desktop directory of your Flipper checkout. ","version":"Next","tagName":"h3"},{"title":"Flipper SDK​","type":1,"pageTitle":"Testing","url":"/docs/extending/testing/#flipper-sdk","content":"Android (Java)​ Gradle​ In the root directory of the checkout: ./gradlew android:test  ","version":"Next","tagName":"h3"},{"title":"React Native​","type":1,"pageTitle":"Testing","url":"/docs/extending/testing/#react-native","content":"For details, see the Testing React Native Changes page. ","version":"Next","tagName":"h3"},{"title":"Images Plugin","type":0,"sectionRef":"#","url":"/docs/features/plugins/fresco/","content":"","keywords":"","version":"Next"},{"title":"LeakCanary Plugin","type":0,"sectionRef":"#","url":"/docs/features/plugins/leak-canary/","content":"LeakCanary Plugin → See setup instructions for the LeakCanary plugin The LeakCanary plugin provides Developers with Flipper support for LeakCanary, an open source memory leak detection library. Leaks detected by LeakCanary appear automatically in Flipper. Each leak displays a hierarchy of objects, beginning with the garbage collector root and ending at the leaked class. Selecting any object in this list displays contents of the object's various fields.","keywords":"","version":"Next"},{"title":"Cache Inspector​","type":1,"pageTitle":"Images Plugin","url":"/docs/features/plugins/fresco/#cache-inspector","content":"Images are grouped by the different caching layers they are stored in. The current fill rate of the cache is shown and you can choose to selectively clear caches. ","version":"Next","tagName":"h2"},{"title":"Attribution​","type":1,"pageTitle":"Images Plugin","url":"/docs/features/plugins/fresco/#attribution","content":"Images can be annotated with attributes that can help to determine the context in which an image was loaded and displayed. You can use that information to filter by a particular surface or only inspect images that are in the critical path of your application (such as during a cold start). ","version":"Next","tagName":"h2"},{"title":"Leak Tracking​","type":1,"pageTitle":"Images Plugin","url":"/docs/features/plugins/fresco/#leak-tracking","content":"Dealing with large resources can require special APIs to be used that circumvent usual garbage collection. The plugin enables the tracking of CloseableReferences for Fresco on Android that weren't properly closed, which can help you improve the performance of your app. ","version":"Next","tagName":"h2"},{"title":"Layout Plugin","type":0,"sectionRef":"#","url":"/docs/features/plugins/inspector/","content":"","keywords":"","version":"Next"},{"title":"Quick edits​","type":1,"pageTitle":"Layout Plugin","url":"/docs/features/plugins/inspector/#quick-edits","content":"In addition to enabling you to view the hierarchy and inspect each item's properties, the Layout Inspector also enables you to edit almost everything, such as layout attributes, background colors, props, and state. This allows you to quickly tweak paddings, margins, and colors until you are happy with them, all without re-compiling. This can save you many hours implementing a new design. ","version":"Next","tagName":"h2"},{"title":"Target mode​","type":1,"pageTitle":"Layout Plugin","url":"/docs/features/plugins/inspector/#target-mode","content":"You can enable 'target mode' by clicking on the crosshairs icon (see screenshot, above). After which, you can touch any view on the device and the Layout Inspector will jump to the correct position within your layout hierarchy. tip Target mode also works with Talkback running. ","version":"Next","tagName":"h2"},{"title":"Accessibility mode (Android-only)​","type":1,"pageTitle":"Layout Plugin","url":"/docs/features/plugins/inspector/#accessibility-mode-android-only","content":"You can enable 'accessibility mode' by clicking on the accessibility icon (see screenshot, above). This shows the accessibility view hierarchy next to the normal hierarchy. In the hierarchy, the currently accessibility-focused view is highlighted in green, and any accessibility-focusable elements have a green icon next to their name. The hierarchy's context menu also allows you to focus accessibility services on certain elements. When selecting an element in one hierarchy, the corresponding element in the other will also be highlighted. The hierarchies expand and collapse in sync and searching through the main hierarchy works in accessibility mode as well. When accessibility mode is enabled, the sidebar shows special properties that are used by accessibility services to determine their functionality. This includes items such as content-description, clickable, focusable, and long-clickable, among others. ","version":"Next","tagName":"h2"},{"title":"Talkback​","type":1,"pageTitle":"Layout Plugin","url":"/docs/features/plugins/inspector/#talkback","content":"The accessibility mode sidebar also includes a panel with properties derived specifically to show Talkback's interpretation of a view (with logic ported over from Google's Talkback source). While generally accurate, this is not guaranteed to be accurate for all situations. It is always better to turn Talkback on for verification. ","version":"Next","tagName":"h3"},{"title":"Navigation Plugin","type":0,"sectionRef":"#","url":"/docs/features/plugins/navigation/","content":"Navigation Plugin → See setup instructions for the Navigation plugin The Navigation Plugin enables users to quickly navigate to deep links within their mobile applications to help speed up the development cycle. The plugin is designed to integrate easily within your existing navigation framework or as a standalone tool. Users can bookmark deep-links and jump to them via the button in the toolbar, as shown in the following screenshot. Navigation events within the app can also be logged to Flipper, which enables the user to view past navigation events and jump straight to them or export the navigation events for reporting.","keywords":"","version":"Next"},{"title":"Network Plugin","type":0,"sectionRef":"#","url":"/docs/features/plugins/network/","content":"Network Plugin → See setup instructions for the Network plugin The Network plugin provides the Network Inspector, which is used to inspect outgoing network traffic in your apps. You can easily browse all requests being made and their responses. The plugin also supports gzipped responses. All requests sent from the device are listed in the plugin. Clicking on a request shows details such as headers and body. You can filter the table for domain, method or status by clicking on the corresponding value in the table. The following screenshot shows the Network Inspector in action.","keywords":"","version":"Next"},{"title":"Shared Preferences Viewer Plugin","type":0,"sectionRef":"#","url":"/docs/features/plugins/preferences/","content":"Shared Preferences Viewer Plugin → See setup instructions for the Shared Preferences Viewer plugin The Shared Preferences Viewer plugin enables you to easily inspect and modify the data contained within your app's shared preferences, as shown in the following screenshot. All changes to the given shared preference file automatically appear in Flipper. You may also edit the values in Flipper and have them synced to your device. This can be done by clicking on the value of the specific key you wish to edit, editing the value and then pressing enter.","keywords":"","version":"Next"},{"title":"Sandbox Plugin","type":0,"sectionRef":"#","url":"/docs/features/plugins/sandbox/","content":"Sandbox Plugin → See setup instructions for the Sandbox plugin The Sandbox plugin enables Developers to test changes in their apps by pointing them to a sandbox environment. It provides a simple UI to set and modify the URL to a development host that acts as a sandbox directly on the desktop, which prevents you from entering potentially long and complicated URLs inside your app.","keywords":"","version":"Next"},{"title":"UI Debugger Plugin","type":0,"sectionRef":"#","url":"/docs/features/plugins/ui-debugger/","content":"UI Debugger Plugin The UIDebugger is a replacement for the Layout inspector. It streams the full hierarchy of the running app to flipper desktop in near real time. We display a 2D visualization with all of your view and component bounds overlayed on top. You can focus on a particular view or component from the context menu. Additionally, you can pause incoming updates to focus on a particular frame. You can inspect what views the hierarchy is made up of as well as what properties each view has; this is useful when debugging issues with your product. We currently support the following platforms and frameworks: Android and LithoiOS and ComponentKit It integrates with these frameworks to present components in the hierarchy just as if they were native views, exposing all the layout properties, props, and state of the components.","keywords":"","version":"Next"},{"title":"Share Flipper Data","type":0,"sectionRef":"#","url":"/docs/features/share-flipper-data/","content":"","keywords":"","version":"Next"},{"title":"Export Flipper data​","type":1,"pageTitle":"Share Flipper Data","url":"/docs/features/share-flipper-data/#export-flipper-data","content":"note You can export Flipper's data in a .flipper file. To export Flipper data, take the following steps: An active device needs to be connected to Flipper, so ensure you've selected the device you want to export in Flipper's device dropdown. From the Menu Bar, select 'File' → 'Export&quot;' then save it wherever you like. The exported data can now be shared with your colleagues. caution Bear in mind that the file will include all the data available to the plugins (such as access tokens in recorded network requests)! ","version":"Next","tagName":"h2"},{"title":"Import Flipper data​","type":1,"pageTitle":"Share Flipper Data","url":"/docs/features/share-flipper-data/#import-flipper-data","content":"Opening a .flipper file imports all the data and allows you to use Flipper as if the device was connected. However, the device is marked as 'offline' (see the following screenshot). Since the device is not present, this means that while you are able to see all the data, you can't interact with it (for example, changing a view's background color).  For advanced users, Flipper also provides a URL handler to import data. For example, linking to flipper://import/?url={LINK_TO_FLIPPER_FILE} will launch Flipper and display the downloaded data. ","version":"Next","tagName":"h2"},{"title":"React Native Support","type":0,"sectionRef":"#","url":"/docs/features/react-native/","content":"","keywords":"","version":"Next"},{"title":"Device type: React Native​","type":1,"pageTitle":"React Native Support","url":"/docs/features/react-native/#device-type-react-native","content":"In Flipper, the dedicated device type, 'React Native', connects to a locally running Metro instance to interact with your React Native app. This device is detected as soon as you fire up a Metro instance by running yarn run ios or yarn run android in your project. If Metro is connected, two new buttons appear in Flipper’s main toolbar: 'Reload' and 'Open Dev Menu': both do exactly as their name suggests. The 'React Native' device feature two plugins out of the box: 'Logs' and 'React DevTools', as shown in the following screenshot.  The React DevTools allows you to inspect the component tree and tune the props and state of your React components. The Logs plugins allow you to search, filter and place watch expressions on your logging output. This offers a much richer way to interact with your logs compared to the terminal output of Metro! ","version":"Next","tagName":"h2"},{"title":"Native plugins for React Native​","type":1,"pageTitle":"React Native Support","url":"/docs/features/react-native/#native-plugins-for-react-native","content":"Beyond the React Native-specific Flipper plugins described above, with Flipper you also inherit the plugin eco-system that exists for native Android and iOS apps. This means that you are able to use plugins that are also aimed at native apps for your React Native app. Example plugins include: Device logsDevice crash reporterInspecting network requestsInspecting app local databasesInspecting device preferencesInspecting cached imagesInspecting native layout elements ","version":"Next","tagName":"h2"},{"title":"Writing JavaScript plugins for React Native + Flipper​","type":1,"pageTitle":"React Native Support","url":"/docs/features/react-native/#writing-javascript-plugins-for-react-native--flipper","content":"One of the advantages of Flipper is its extensibility. Many teams across Meta already have written their own one-off plugins that help with analysing very specific use cases. Writing plugins for Flipper doesn't require any native code, as the Flipper SDK is exposed directly to JavaScript through the react-native-flipper package. The following screenshot shows an example Flipper plugin, where a game of Tic Tac Toe uses Flipper and some emulators.  If you'd like to build a specific (or generic) extension for Flipper, take a look at the following pointers: Building a React Native Flipper PluginBuilding a Desktop Plugin note Plugins for Flipper can be distributed through NPM so sharing them is trivial. ","version":"Next","tagName":"h2"},{"title":"Community React Native plugins for Flipper​","type":1,"pageTitle":"React Native Support","url":"/docs/features/react-native/#community-react-native-plugins-for-flipper","content":"The React Native community has also started to build plugins for Flipper. Reactotron's Flipper plugin is an example of a standalone React Native desktop app that is ported to work as a Flipper plugin. For more information, see the Better React Native Debugging with Reactotron in Flipper web page. If you've got your own Flipper plugin for React Native that you'd like to advertise, please send the Litho team a pull request! ","version":"Next","tagName":"h3"},{"title":"Desktop App","type":0,"sectionRef":"#","url":"/docs/getting-started/","content":"","keywords":"","version":"Next"},{"title":"Installation​","type":1,"pageTitle":"Desktop App","url":"/docs/getting-started/#installation","content":"note The desktop part of Flipper doesn't need a setup. Simply download the latest build for Mac, Linux or Windows and launch it. If you're on macOS, you can run brew install --cask flipper to let homebrew manage installation and upgrades (simply run brew upgrade to upgrade when a new version is released, although it might take a few hours up to a day for the package to be upgraded on homebrew). To work properly with mobile apps, Flipper requires the following: Working installation of Android development tools[Where applicable] Working installation of iOS development toolsOpenSSL binary on your $PATH. A compatible OpenSSL for Windows can be downloaded from slproweb.com or from Chocolatey with choco install openssl. If you are hacking a JS app, you should be good to go without any extra dependencies installed. Information [Experimental] Alternatively, it is possible to run a browser based version of Flipper directly from NPM by using npx flipper-server. ","version":"Next","tagName":"h2"},{"title":"Troubleshooting​","type":1,"pageTitle":"Desktop App","url":"/docs/getting-started/#troubleshooting","content":"If you run into problems, take a look at the Troubleshooting section. Failing that, have a look at GitHub Issues. ","version":"Next","tagName":"h2"},{"title":"Desktop Plugin API","type":0,"sectionRef":"#","url":"/docs/extending/flipper-plugin/","content":"","keywords":"","version":"Next"},{"title":"Properties​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#properties","content":"device​ Returns the Device this plugin is connected to. appName​ The name of the application, for example 'Facebook', 'Instagram' or 'Slack'. appId​ A string that uniquely identifies the current application and is based on a combination of the application name and device serial on which the application is running. pluginKey​ A key that uniquely identifies this plugin instance and captures the current device/client/plugin combination. connected​ isConnected​ Returns whether there is currently an active connection; 'true' for any of the following: The device is still connected.The client is still connected.The plugin is currently selected by the user or the plugin is running in the background. The connected field provides the atom that can be used in combination with useValue to subscribe to future updates in a component. In contrast, isConnected returns a boolean that merely captures the current state. ","version":"Next","tagName":"h3"},{"title":"Events​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#events","content":"onMessage​ Usage: client.onMessage(event: string, callback: (params) =&gt; void) Subscribes the plugin to a specific event that is fired from the client plugin (using connection.send). Typically used to update some of the state. For background plugins that are currently not active in the UI, messages won't arrive immediately, but are queued until the user opens the plugin. Example: type Events = { newRow: { id: number; title: string; url: string; }; }; export function plugin(client: PluginClient&lt;Events, {}&gt;) { const rows = createState&lt;Record&lt;string, Row&gt;&gt;({}, {persist: 'rows'}); client.onMessage('newRow', (row /* type will be inferred correctly */) =&gt; { rows.update((draft) =&gt; { draft[row.id] = row; }); }); // etc }  The Flipper Sample application contains a plugin that demonstrates these API, see the bi-directional-communication-demo. onActivate​ Usage: client.onActivate(callback: () =&gt; void) Called when the plugin is selected by the user and mounted into the Flipper Desktop UI. See also the closely related onConnect event. Unlike onConnect, onActivate triggers for archived / imported devices. onDeactivate​ Usage: client.onDeactivate(callback: () =&gt; void) Triggered when the plugin is unmounted from the Flipper Desktop UI because the user navigates to some other plugin. In the case the plugin is destroyed while being active, onDeactivate will still be called. onConnect​ Usage: client.onConnect(callback: () =&gt; void) Triggered once the connection with the plugin on the client is established, and, for example, send can be called safely. Typically, this occurs when the plugin is activated (opened) in the Flipper Desktop. However, for background plugins, this happens immediately after the plugin has been instantiated. This lifecycle is never triggered for archived / imported devices, onDisconnect​ Usage: client.onDisconnect(callback: () =&gt; void) Triggered once the connection with the plugin on the client has been lost. Typically, this occurs when the user leaves the plugin in the Flipper Desktop, when the plugin is disabled, or when the app or device has disconnected. However, for background plugins, this event won't fire when the user merely navigates somewhere else. In that case, onDeactivate can be used instead. onDestroy​ Usage: client.onDestroy(callback: () =&gt; void) Called when the plugin is unloaded. This happens if the device or client has been disconnected, or when the user disables the plugin. Note that there is no corresponding onCreate event, since the function body of the plugin definition acts already as 'what needs to be done when the plugin is loaded/enabled'. onDeepLink​ Usage: client.onDeepLink(callback: (payload: unknown) =&gt; void) Triggerred when the users navigates to this plugin using a deeplink, either from an external flipper:// plugin URL, or because the user was linked here from another plugin. onExport​ Usage: client.onExport(callback: (idler, onStatusMessage) =&gt; Promise&lt;state&gt;) Overrides the default serialization behavior of this plugin. Should return a promise with persistable state that is to be stored, or nothing at all. This process is async, so it is possible to first fetch some additional state from the device. Serializable is defined as 'non-cyclic data, consisting purely of primitive values, plain objects, arrays or Date, Set or Map objects'. If nothing is returned, the handler will be run, and after the handler has finished the persist keys of the different states will be used as export basis. onImport​ Usage: client.onImport(callback: (snapshot) =&gt; void) Overrides the default de-serialization behavior of this plugin. Use it to update the state based on the snapshot data. This hook will be called immediately after constructing the plugin instance. To synchonize the types of the data between onImport and onExport, it's possible to provide a type as generic to both hooks. The next example stores counter under the count field and stores it as string rather than as number. type SerializedState = { count: string; } export function plugin(client: PluginClient) { const counter = createState(0); client.onExport&lt;SerializedState&gt;(() =&gt; { return { count: &quot;&quot; + counter.get() } }) client.onImport&lt;SerializedState&gt;((data) =&gt; { counter.set(parseInt(data.count, 10)); }); }  onUnhandledMessage​ Usage: client.onUnhandledMessage(callback: (event: string, params) =&gt; void) This method subscribes to all messages arriving from the devices which is not handled by an onMessage handler. This handler is untyped, and onMessage should be favored over using onUnhandledMessage if the event name is known upfront. onServerAddOnStart​ Experimental! Usage: client.onServerAddOnStart(callback: () =&gt; void) Triggered when a server add-on starts. You should send messages to the server add-on only after it connects. Do not forget to stop all communication when the add-on stops. onServerAddOnStop​ Experimental! Usage: client.onServerAddOnStop(callback: () =&gt; void) Triggered when a server add-on stops. You should stop all communication with the server add-on when the add-on stops. onServerAddOnMessage​ Experimental! Usage: client.onServerAddOnMessage(event: string, callback: (params) =&gt; void) This subscribes the plugin to a specific event that is fired from the server add-on. Example: type ServerAddOnEvents = { newRow: { id: number; title: string; url: string; }; }; export function plugin(client: PluginClient&lt;{}, {}, ServerAddOnEvents&gt;) { const rows = createState&lt;Record&lt;string, Row&gt;&gt;({}, {persist: 'rows'}); client.onServerAddOnMessage('newRow', (row /* type will be inferred correctly */) =&gt; { rows.update((draft) =&gt; { draft[row.id] = row; }); }); // etc }  onServerAddOnUnhandledMessage​ Experimental! Usage: client.onServerAddOnUnhandledMessage(callback: (event: string, params) =&gt; void) Subscribe to all messages arriving from the server add-ons not handled by another listener. This handler is untyped, and onMessage should be favored over using onUnhandledMessage if the event name is known upfront. onReady​ The onReady event is triggered immediately after a plugin has been initialized and any pending state was restored. This event fires after onImport / the interpretation of any persist flags and indicates that the initialization process has finished. This event does not signal that the plugin is loaded in the UI yet (see onActivated) and does fire before deeplinks (see onDeeplink) are handled. If a plugin has complex initialization logic it is recommended to put it in the onReady hook, as an error in the onReady hook won't cause the plugin not to be loaded. ","version":"Next","tagName":"h3"},{"title":"Methods​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#methods","content":"send​ Usage: client.send(method: string, params: object): Promise&lt;object&gt; If the plugin is connected, send can be used to invoke a method on the client implementation of the plugin. Note that if client.isConnected returns false, calling client.send will throw an exception. This is the case if for example the connection with the device or application was lost. Generally, one should guard client.send calls with a check to client.isConnected. Example: type Methods = { currentLogs(params: {since: number}): Promise&lt;string[]&gt;; }; export function plugin(client: PluginClient&lt;{}, Methods&gt;) { const logs = createState&lt;string[]&gt;([]) client.onConnect(async () =&gt; { try { const currentLogs = await client.send('currentLogs', { since: Date.now() }) logs.set(currentLogs) } catch (e) { console.error(&quot;Failed to retrieve current logs: &quot;, e) } }) //etc }  The Flipper Sample application contains a plugin that demonstrates these API, see bi-directional-communication-demo. addMenuEntry​ Usage: client.addMenuEntry(...entry: MenuEntry[]) This method can be used to add menu entries to the Flipper main menu while this plugin is active. It supports registering global keyboard shortcuts as well. Example: client.addMenuEntry({ label: 'Reset Selection', accelerator: 'CmdOrCtrl+R' handler: () =&gt; { // Event handling } }  The accelerator argument is optional but describes the keyboard shortcut. It is possible to leave out the label, and accelerator fields if a pre-defined action is set, which configures all three of them. The currently pre-defined actions are &quot;Clear&quot;, &quot;Go To Bottom&quot; and &quot;Create Paste&quot;. Example of using a pre-defined action: client.addMenuEntry({ action: 'createPaste', handler: async () =&gt; { // Event handling } })  isPluginAvailable​ Usage: isPluginAvailable(pluginId: string): boolean Returns true if a plugin with the given id is available by for consumption, that is: supported by the current application / device and enabled by the user. selectPlugin​ Usage: selectPlugin(pluginId: string, deeplinkPayload?: unknown): void Opens a different plugin by id, optionally providing a deeplink to bring the target plugin to a certain state. supportsMethod​ Usage: client.supportsMethod(method: string): Promise&lt;Boolean&gt; Method must be called within onConnect, otherwise will throw error. Resolves to true if the client supports the specified method. Useful when adding functionality to existing plugins, when connectivity to older clients is still required. Also useful when client plugins are implemented on multiple platforms and don't all have feature parity. showNotification​ Usage: client.showNotification(notification) Shows an urgent, system wide notification, that will also be registered in Flipper's notification pane. For on-screen notifications, we recommend using either the message or notification API from antd directly. Clicking the notification will open the sending plugin. If the action id is set, it will be used as deeplink. The notification interface is defined as: interface Notification { id: string; title: string; message: string | React.ReactNode; severity: 'warning' | 'error'; timestamp?: number; category?: string; action?: string; };  writeTextToClipboard​ Usage: writeTextToClipboard(text: string) Writes text to the OS-level clipboard. createPaste​ note This is a Facebook only method. Usage: client.createPaste(value: string): Promise&lt;string|undefined&gt; Creates a Facebook Paste (similar to a GitHub Gist) for the given value. The returned promise either contains a string with the URL of the paste, or undefined if the process failed. Details of the failure will be communicated back directly to the user through Flipper notifications. For example, if the user is currently not signed in. GK​ note This is a Facebook only method. Usage: client.GK(gatekeeper: string): boolean Returns true if the current user is part of the given GK. false in all other cases. logger​ Logger instance that logs information to the console, but also to the internal logging (in FB only builds) and which can be used to track performance (see useLogger). sendToServerAddOn​ Usage: client.sendToServerAddOn(method: string, params: object): Promise&lt;object&gt; Send a message to the server add-on. Example: type ServerAddOnMethods = { currentLogs(params: {since: number}): Promise&lt;string[]&gt;; }; export function plugin(client: PluginClient&lt;{}, {}, {}, ServerAddOnMethods}&gt;) { const logs = createState&lt;string[]&gt;([]) client.onServerAddOnStart(async () =&gt; { try { const currentLogs = await client.sendToServerAddOn('currentLogs', { since: Date.now() }) logs.set(currentLogs) } catch (e) { console.error(&quot;Failed to retrieve current logs: &quot;, e) } }) //etc }  For an example of how to use server add-ons, see the React DevTools plugin. ","version":"Next","tagName":"h3"},{"title":"DevicePluginClient​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#devicepluginclient","content":"","version":"Next","tagName":"h2"},{"title":"Properties​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#properties-1","content":"device - returns the Device this plugin is connected to. ","version":"Next","tagName":"h3"},{"title":"Events​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#events-1","content":"The following DevicePluginClient events are identical to those with the same name for the PluginClient (each of the following events links to the relative PluginClient description): onDestroyonActivateonDeactivateonDeepLinkonExportonImportonServerAddOnStartonServerAddOnStoponServerAddOnMessageonServerAddOnUnhandledMessage ","version":"Next","tagName":"h3"},{"title":"Methods​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#methods-1","content":"The following DevicePluginClient methods are identical to those with the same name for the PluginClient (each of the following methods links to the relative PluginClient description): addMenuEntrycreatePasteshowNotificationisPluginAvailableselectPluginsendToServerAddOn ","version":"Next","tagName":"h3"},{"title":"Device​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#device-1","content":"Device captures the metadata of the device the plugin is currently connected to. Device objects are passed into the supportsDevice method of a device plugin and are available as the device field on a DevicePluginClient ","version":"Next","tagName":"h2"},{"title":"Properties​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#properties-2","content":"Property\tDatatype\tDescription\tValuesos\tString\tOperating System of the device.\t'iOS', 'Android', 'Windows','MacOS', or 'Metro' deviceType\tString\tWhether the device is a physical device or an emulator.\t'emulator' or 'physical' isArchived\tBoolean\tA flag: true indicates the current device is coming from an import Flipper snapshot, and not an actually connected device.\tTrue or False isConnected\tBoolean\tA flag: true indicates the connection to the device is still alive.\tTrue or False ","version":"Next","tagName":"h3"},{"title":"Events​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#events-2","content":"onLogEntry​ Usage: device.onLogEntry(callback: (logEntry: DeviceLogEntry) =&gt; void) Use this event to subscribe to the log stream that is emitted by the device. For Android, this is using adb behind the scenes, for iOS idb, for Metro it connects to the webserver for the Metro log output, etc. The DeviceLogEntry exposes the following fields: Field\tDatatypedate\tDate type\tstring message\tstring pid\tnumber tid\tnumber app\tstring tag\tstring Possible values for type are: 'unknown', 'verbose', 'debug', 'info', 'warn', 'error', and 'fatal'. ","version":"Next","tagName":"h3"},{"title":"State Management​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#state-management","content":"State in Sandy plugins is stored in small containers that hold immutable values and can be consumed in React components using the useValue hook. ","version":"Next","tagName":"h2"},{"title":"Methods​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#methods-2","content":"createState​ Usage: createState&lt;T&gt;(initialValue: T, options?): StateAtom&lt;T&gt; The createState method can be used to create a small state container that lives inside a Sandy plugin. Its value should be treated as immutable and is initialized by default using the initialValue parameter. Options​ Optionally, options can be provided when creating state. Supported options: persist: string - if the persist value is set, this state container is serialized when a Flipper snapshot export is being made. When a snapshot is imported into Flipper, and plugins are initialized, this state container loads its initial value from the snapshot, rather than using the initialValue parameter. The persist key should be unique within the plugin and only be set if the state stored in this container is serializable and won't become unreasonably large. See also exportState and initialState in the TestUtils section of the 'Utlities' page.persistToLocalStorage: boolean - indicates if this option is set in combination with the persist option. The atom stores its state in local storage instead of as part of the plugin import / export. State stored in local storage is shared between the same plugin across multiple clients/ devices, but not actively synced. Serializable is defined as: non-cyclic data, consisting purely of primitive values, plain objects and arrays. Precisely as the root, Date, Set or Map objects are allowed as well but shouldn't appear deeper in the tree. The state atom object​ A state atom object is returned by createState, exposing the following methods: get(): T - returns the current value stored. If you want to use the atom object in a React component, consider using the useValue hook instead, to make sure the component is notified about future updates of this atom.set(newValue: T) - stores a new value into the atom. If the new value is not reference-equal to the previous one, all observing components are notified.update(updater: (draft: Draft&lt;T&gt;) =&gt; void) - updates the current state using an Immer recipe. In the updater, the draft object can be safely (deeply) mutated. Once the updater finishes, Immer will compute a new immutable object based on the changes, and store that. This is often simpler than using a combination of get and set if deep updates need to be made to the stored object.subscribe(listener: (value: T, prevValue: T) =&gt; void): () =&gt; void - subscribes a listener function to the state updates. The Listener function receives the next and previous value on each update. The method also returns function which can be called to unsubscribe the listener from further updates.unsubscribe(listener: (value: T, prevValue: T) =&gt; void): void - unsubscribes a listener function from the state updates if it was subscribed before. Example​ import {createState} from 'flipper-plugin' const rows = createState&lt;string[]&gt;([], {persist: 'rows'}); const selectedID = createState&lt;string | null&gt;(null, {persist: 'selection'}); // Listener is called on each rows.set() and rows.update() call until unsubscribed. const unsubscribe = rows.subscribe((value, prevValue) =&gt; { console.log(`Rows state updated. New length: ${value.length}. Prev length: ${prevValue.length}.`); }); rows.set([&quot;hello&quot;]) // Listener will be notified about the change console.log(rows.get().length) // 1 unsubscribe(); // Do not notify listener anymore rows.update(draft =&gt; { // Listener won't be notified about the change draft.push(&quot;world&quot;) }) console.log(rows.get().length) // 2  createDataSource​ Usage: createDataSource&lt;T&gt;(initialSet?: T[], options?): DataSource&lt;T&gt; Most Flipper plugins follow the basic concept of receiving events from the device, store them, and being able to tail, filter and search them. To optimise for this situation, there is a dedicated createDataSource abstraction which creates a DataSource.DataSource is a data collection that is heavily optimized for append and update, which stores items based on insertion order, but also allows for efficient by-id lookups. Each DataSource exposes a default view property, which contains a DataSourceView. A DataSourceView is a materialized view that can be sorted, filtered and windowed, and is kept incrementally up to date with the underlying DataSource. When using the DataTable component, this view will be managed by the table automatically, giving plugin users the capability to freely sort, filter, search and tail your datasource. Alternatively, you could also pass in a different view(like from additionalViews) to the DataTable component which allows for different filters, searches, etc. than the default view. Valid options are: key - if a key is set, the given field of the records is assumed to be unique, and its value can be used to perform lookups and upserts.limit - the maximum number of records that this DataSource will store. If the limit is exceeded, the oldest records will automatically be dropped to make place for the new ones. Defaults to 100.000 records.persist - see the createState persist option: If set, this data source will automatically be part of Flipper imports / exports; it's recommended to set this option.indices - If set, secondary indices will be maintained for this table that allows fast lookups. Indices is an array of keys with 1 or more items. See getAllRecordsByIndex for more details. All records stored in a data source should be treated as being immutable. To update a record, replace it with a new value using the update or upsert operations. Example​ export function devicePlugin(client: DevicePluginClient) { const rows = createDataSource&lt;ExtendedLogEntry&gt;([], { limit: 200000, persist: 'logs', }); client.device.onLogEntry(entry =&gt; { rows.append(entry); }); return { rows, } }  DataSource​ Stores large amounts of records efficiently. For an introducrion, see createDataSource. limit​ The maximum number of records that can be stored in this DataSource to constrain memory usage. Defaults to 100.000 rows. If the limit is exceeded, the oldest 10% of records is dropped. This field is writable but does not immediately truncate if changed. view​ Returns the currently active default view on the data source. Note that be default it is windowed on the impractical [0, 0) range. For more details, see DataSourceView. additionalViews​ Holds additional DataSourceView on this DataSource. It contains key of viewId: string and value of DataSourceView&lt;T, KeyType&gt;. The default view in DataSource has DEFAULT_VIEW_ID = '0', so all additionalViews cannot use this as the viewId. This is a readonly array and additional views are appended to the array by calling getAdditionalView(viewId: string) with a new viewId size​ The total number of records stored in this data source. records​ Usage: records(): T[]. Returns all values stored in this data source in a defensive copy. Note that this operation performs O(n), so typically one should operate on a subset of the records using size and get. get​ Usage: get(index: number): T. Returns the record at the given index, which is insertion order based. This operation does not take into consideration the current view. See also view.get to get a record based on visible position. To look items up based on their id, use getById. getById​ Usage: getById(key: string): T | undefined (for example, users.getById(&quot;jane&quot;). Returns the record associated with the given key, or undefined. This method can only be used if the key option was passed to createDataSource. keys​ Usage: keys(), returns an iterator that will iterate all keys in the data source. For example, to create an array of all keys: const usernames = Array.from(users.keys()). This method can only be used if the key option was passed to createDataSource. entries​ Usage: entries(). Similar to keys(), but will return an iterator that generate entry tuples, in the shape of [key, value]. [Symbol.iterator]​ DataSource supports the iterator protocol, so to visit all stored records one can use for (const user of users) {....}. getIndexOfKey​ Usage: getById(key: string): number. Returns the insertion index of the record associated with the given key, or -1. This method can only be used if the key option was passed to createDataSource. append​ Usage: append(record: T). Appends a new record to the data collection. This method will throw if a duplicate key is inserted. Use upsert to automatically append or update. Mutations like append will be reflected in the view automatically. update​ Usage: update(index: number, record: T). Replaces the given record in the data sources. delete​ Usage: delete(index: number). Remove the record at the given index from the datasource. Note that if a the key option of the datasource is set, this operation degrades to O(n) performance and should typically be avoided. deleteById​ Usage: delete(key: string): boolean. Removes the record with the given key. Returns true if the record existed and has been removed. This operation is O(n) expensive and should generally be avoided. shift​ Usage: shift(amount: number). Removes the first amount records from the datasource. This is generally a performant operation. clear​ Usage: clear(). Removes all records from this data source. getAdditionalView​ Usage: getAdditionalView(viewId: string). Gets an additional DataSourceView of the DataSource by passing in an identifier viewId. If there already exists a DataSourceView with the viewId, we simply return that view instead. getAllRecordsByIndex​ Usage: getAllRecordsByIndex({ indexedAttribute: value, indexAttribute2: value2, .... }) This method allows fast lookups for objects that match specific attributes exactly. Returns all items matching the specified index query. Note that the results are unordered, unless records have not been updated using upsert / update, in that case insertion order is maintained. If no index has been specified for this exact keyset in the indexQuery (see options.indices), this method will throw. Example: const ds = createDataSource([eatCookie, drinkCoffee, submitBug], { key: 'id', indices: [ ['title'] ['id', 'title'], ['title', 'done'], ], }); // Find first element with title === cookie (or undefined) const todo = ds.getFirstRecordByIndex({ title: 'cookie', }) // Find all elements where title === cookie, and done === false const todos = ds.getAllRecordsByIndex({ title: 'cookie', done: false, })  DataSourceView​ A materialized view on a DataSource, which can apply windowing, sorting and filtering and will be kept incrementally up to date with the underlying datasource. Note that the default window is empty, so after obtaining a DataSourceView one should typically call setWindow. For an introduction, see [createDataSource]. The DataSourceView API is important if are creating your own visualization of a DataSource. However, if a DataSource is visualized using a DataTable, there is typically no need to directly interact with this API. datasource​ A reference to the underlying DataSource. windowStart​ See setWindow. windowEnd​ See setWindow. size​ The total size of the current view after applying filtering. Note that size does not reflect windowing. To get the window size use: windowEnd - windowStart. To get the total amount of records, without respecting the current filter, use datasource.size. isSorted​ Returns true if a sort criterium is set. isFiltered​ Returns true if a filter criterium is set. isRevered​ Return true if the current view will be shown in reverse order. output​ Usage: output(): T[] or output(start, end): T[]. Returns a defensive copy of all items visible in the provided range window. If start and end are omitted, the current window will be used. To get all items visible in the current view, ignoring the window, use view.output(0, view.size). [Symbol.iterator]​ DataSourceView supports the iterator protocol, so the currently visible output can be iterated using for example for (const user in users.view) { ... }. The iterator will always apply the current window. setWindow​ Usage: setWindow(start, end). This method sets the current visible window to the specified range (which will include start, but not end, so [start, end)). Setting a window impacts the default behavior of output and iterator and, more importantly, the behavior of any listener: update events that happen outside the window will not be propagated to any listeners, and shift events will describe whether the happened in, before, or after the current window. Windowing will always be applied only after applying any filters, sorting and reversing. setFilter​ Usage: setFilter(filter: (record: T) =&gt; boolean). Applies a filter to the current records. This will typically reduce size of this view. Example: users.view.setFilter(user =&gt; user.age &gt;= 18). setSortBy​ Usage: setSortBy(field: string) or setSortBy(sortBy: (irecord: T) =&gt; primitive). For example: users.view.setSortBy(&quot;age&quot;) or users.viewSetSortBy(user =&gt; ${user.lastName} ${user.firstName}). setSortBy will cause the data source to be sorted by the given field or criterium function. Sort is implemented efficiently by using a binary search to insert / remove newly arriving records, rather than performing a full sort. But this means that the sort function should be stable and pure. Sorting will always happen in ascending order, and if duplicate sort values appear, the insertion order will take precedence. To sort in descending order, use setReversed. If a view doesn't have sorting specified, it will always show records in insertion order. toggleRevered​ Usage: toggleReversed(). Toggles the output order between ascending and descending. setReversed​ Usage: setReversed(ascending: boolean). Defines whether the output colletion is shown normal (ascending) or reverse (descending) order. reset​ Usage: reset(). Resets the window, filtering, sorting and reverse to their defaults. Note that this puts the window back to [0, 0) as well, meaning now records will be part of the output. get​ Usage: get(index: number). Returns the record at the given position in the output. The index parameter respects sorting, filtering and reversing, but does not respect any window offset. So get(0) will return the first record in the datasource according to the given filtering, sorting and reversing, while get(windowStart) will return the first of the records visible in the current window. setListener​ Usage: setListener(callback: undefined | (event: OutputChange) =&gt; void). Sets up a listener that will get notified whenever the output or size of this view changes. This can be used to, for example, update the UI and is used by DataTable under the hood. The following events can be emitted. These events respect the current sorting, filtering and reversing. The shift location is expressed relatively to the current window. Now update events that are outside the current window will be emitted. reset events are typically emitted if a change happened that cannot be expressed in a limited number of shifts / updates. Such as changing sorting or filtering, calling clear() or reset(), or doing a large shift. Currently only one listener is allowed at a time. Please contact the Flipper oncall if that doesn't suffice. type OutputChange = | { type: 'shift'; index: number; // the position at which records were inserted or removed location: 'before' | 'in' | 'after'; // relative to current window delta: number; // how many records were inserted (positive number) or removed (negative number) newCount: number; // the new .size of the DataSourceView } | { // an item, inside the current window, was changed type: 'update'; index: number; } | { // something big and awesome happened. Drop earlier updates to the floor and start again // like: clear, filter or sorting change, etc type: 'reset'; newCount: number; };  ","version":"Next","tagName":"h3"},{"title":"React Hooks​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#react-hooks","content":"","version":"Next","tagName":"h2"},{"title":"Methods​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#methods-3","content":"usePlugin​ Usage: const instance = usePlugin(plugin) Can be used by any component in the plugin, and gives the current instance that corresponds with the currently loaded plugin. The plugin parameter isn't actually used; it verifies that a component is used correctly inside a mounted component and helps with type inference. The returned instance method corresponds to the object that is returned from the plugin / devicePlugin definition. See the Tutorial for how this hook is used in practice. useValue​ Usage: const currentValue = useValue(stateAtom) Returns the current value of a state atom, and also subscribes the current component to future changes of the atom (in contrast to using stateAtom.get() directly). See the Tutorial for how this hook is used in practice. useLogger​ Usage: const logger = useLogger() Provides the default logger that can be used for console logging, error reporting and performance measurements. In internal Meta builds, this is wired up to the internal statistic reporting. Use logger rather than using console directly. The logger API is defined as: interface Logger { track(type: TrackType, event: string, data?: any, plugin?: string): void; trackTimeSince( mark: string, eventName?: string | null | undefined, data?: any, ): void; info(data: any, category: string): void; warn(data: any, category: string): void; error(data: any, category: string): void; debug(data: any, category: string): void; }  useTrackedCallback​ Usage: const eventHandler = useTrackedCallback(&quot;Interaction description&quot;, handlerFunction, deps) Utility that wraps React's useCallback with tracking capabilities. The API is similar, except that the first argument describes the interaction handled by the given event handler. For more information, see Tracked in the UI Components page. useMemoize​ Slight variation on useMemo that encourages to create hoistable memoization functions, which encourages reuse and testability by no longer closing over variables that are used by the memoized function, but rather receiving them as arguments so that these functions beome pure. function MyComponent() { const {findMetroDevice} = props; const connections = useSomeHook(); const metroDevice = useMemoize( findMetroDevice, [connections.devices], ); // etc } export function findMetroDevice(findMetroDevice, deviceList) { return deviceList.find(findMetroDevice); }  useLocalStorageState​ Like useState, but the value will be stored in local storage under the given key and read back upon initialization. The hook signature is similar to useState, except that the first argument is the storage key. The storage key will be scoped automatically to the current plugin and any additional tracking scopes. (See TrackingScope in the 'UI Components' page). const [showWhitespace, setShowWhitespace] = useLocalStorageState( `showWhitespace`, true );  ","version":"Next","tagName":"h3"},{"title":"UI components​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#ui-components","content":"","version":"Next","tagName":"h2"},{"title":"Layout.*​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#layout","content":"Layout elements can be used to organize the screen layout. See the Style Guide for more details. ","version":"Next","tagName":"h3"},{"title":"HighlightContext​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#highlightcontext","content":"","version":"Next","tagName":"h3"},{"title":"HighlightProvider​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#highlightprovider","content":"React context provider for Highlight context. All wrapped componets can access context or use the useHighligher helper. Example &lt;HighlightProvider text={searchTerm} highlightColor={theme.searchHighlightBackground.yellow}&gt; &lt;HighlightedText text='Lorem itsum'/&gt; &lt;/HighlightProvider&gt;  ","version":"Next","tagName":"h3"},{"title":"useHighlighter​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#usehighlighter","content":"Hook to be used inside a Highlight context to render text with highlighting applied. Example function HighlightedText(props: {text: string}) { const highlightManager: HighlightManager = useHighlighter(); return &lt;span&gt;{highlightManager.render(props.text)}&lt;/span&gt;; }  ","version":"Next","tagName":"h3"},{"title":"PowerSearch​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#powersearch","content":"","version":"Next","tagName":"h3"},{"title":"DataTable​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#datatable","content":"","version":"Next","tagName":"h3"},{"title":"DataFormatter​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#dataformatter","content":"","version":"Next","tagName":"h3"},{"title":"DataInspector​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#datainspector","content":"","version":"Next","tagName":"h3"},{"title":"DataDescription​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#datadescription","content":"","version":"Next","tagName":"h3"},{"title":"MarkerTimeline​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#markertimeline","content":"","version":"Next","tagName":"h3"},{"title":"ElementsInspector​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#elementsinspector","content":"","version":"Next","tagName":"h3"},{"title":"ElementAttribute​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#elementattribute","content":"","version":"Next","tagName":"h3"},{"title":"ElementData​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#elementdata","content":"","version":"Next","tagName":"h3"},{"title":"ElementExtraInfo​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#elementextrainfo","content":"","version":"Next","tagName":"h3"},{"title":"ElementID​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#elementid","content":"","version":"Next","tagName":"h3"},{"title":"ElementSearchResultSet​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#elementsearchresultset","content":"","version":"Next","tagName":"h3"},{"title":"ElementsInspectorElement​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#elementsinspectorelement","content":"","version":"Next","tagName":"h3"},{"title":"ElementsInspectorProps​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#elementsinspectorprops","content":"","version":"Next","tagName":"h3"},{"title":"TimelineDataDescription​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#timelinedatadescription","content":"","version":"Next","tagName":"h3"},{"title":"dataTablePowerSearchOperators​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#datatablepowersearchoperators","content":"","version":"Next","tagName":"h3"},{"title":"MasterDetailLegacy​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#masterdetaillegacy","content":"","version":"Next","tagName":"h3"},{"title":"DataTableLegacy​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#datatablelegacy","content":"Coming soon ","version":"Next","tagName":"h3"},{"title":"MasterDetail​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#masterdetail","content":"The MasterDetail provides a default setup for a DataTable in combination with a sidebar, and some super common features like keyboard shortcuts, paste integration, and clear / pause-resume buttons. The MasterDetail component accepts all DataTable props, and beyond that the following props. The sidebarPosition prop controls here to display the details of the currently selected record: 'main' (default): show the details in the standard, centrally controlled right sidebar'right': show a resizable pane to the right'bottom': show a resizable pane to the bottom'none': don't show details at all sidebarComponent: Component that accepts a 'record' prop that is used to render details.If none is provided, a standard DataInspector component will be used to display the entire record.sidebarSize: Default size of the sidebar.selection: If provided, this atom will be used to store selection in.isPaused: If provided, this atom will be used to store pause/resume state in, and a pause/resume toggle will be shown`enableClear: If set, a clear button will be shown. By default, this will clear the dataSource (if any).onClear: Callback to be called when clear action is used.enableMenuEntries: If provided, standard menu entries will be created for clear, goToBottom and createPaste. ","version":"Next","tagName":"h3"},{"title":"Panel​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#panel","content":"A collapsible UI region. The collapsed state of the pane will automatically be persisted so that the collapsed state is restored the next time user visits the plugin again. Note that the children of a Panel should have some size, either a fixed or a natural size. Elements that grow to their parent size will become invisible. For demos and property documentation see the 'Flipper style guide'. ","version":"Next","tagName":"h3"},{"title":"Tabs​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#tabs","content":"","version":"Next","tagName":"h3"},{"title":"Tab​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#tab","content":"The Tabs and Tab component re-expose the TabControl as provided by Antd, and support the same properties. For more details, see the official Ant Design docs. The following additional property is supported: grow. If set, the tab control will use all available vertical space. By default false. ","version":"Next","tagName":"h3"},{"title":"Toolbar​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#toolbar","content":"A horizontal panel to organize buttons and alike. Basically a Layout.Horizontal with a border, padding, gap and wrapping enabled. ","version":"Next","tagName":"h3"},{"title":"CodeBlock​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#codeblock","content":"A preformatted paragraph that supports wrapping, preserves whitespace and uses monospace. ","version":"Next","tagName":"h3"},{"title":"DataList​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#datalist","content":"The DataList can be used to display a set of items efficiently, and where a single item can be selected. Properties: items: Items to display. Per item at least a title and unique id should be provided.value: The current selectiononSelectonRenderItem: A custom render function. By default, the component will render the title in bold and description (if any) below it.type: default or `dropdown. Defines the styling of the component. By default shows a list, but alternatively the items can be displayed in a drop downscrollable: By default the data list will take all available space and scroll if items aren't otherwise visible. By setting scrollable={false} the list will only take its natural size ","version":"Next","tagName":"h3"},{"title":"Dialog​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#dialog","content":"The Dialog namespace provides a set of utility to prompt the user with feedback of input. Rather than spawning dialogs by hand, the benefit of the Dialog utilities is that they all return promises capture the results. The promises returned by Dialog will resolve to false if the user intentionally closed the dialog (typically by using cancel / escape / clicking the close button). The promises returned by Dialog utilities will expose a close() method that can be used to programmatically close a dialog. In which case the pending promise will resolve to false as well. General properties accepted by the Dialog utility: title - Overrides the title of the dialog, defaults to empty.width - Overrides the default width (400) for dialogs. Number in pixels.okText - Overrides the caption of the OK buttoncancelText - Overrides the caption of the Cancel button Available utilities Dialog.confirm(options): Promise&lt;boolean&gt;. Show a confirmation dialog twithino the user. Options: message: Description of what the user is confirming. Dialog.prompt(options): Promise&lt;string | false&gt;. Inspired by window.prompt. Prompt the user for some input. Options: message: Text accompanying the inputdefaultValueonConfirm(value) =&gt; Promise&lt;string&gt;. Can be used to transform the inputted value before resolving the prompt promise. If the handler throws, this will be shown as validation error in the dialog. Dialog.loading(options): Promise&lt;void&gt;. Shows a dialog with a loading spinner. This dialog cannot be closed by the user, so instead .close() should be called programmatically on the returned promise. message: Message to display with the loading spinner. Dialog.show&lt;T&gt;(options): Promise&lt;T | false. Low level building block to build dialogs. Options: children: React Element to render as children of the dialog.onConfirm: () =&gt; Promise&lt;T&gt;. Handler to handle the OK button, which should produce the value the Dialog.show call will resolve to. Dialog.alert(options) show a small dialog, inspired by window.alert. Returns a Promise&lt;void&gt;. Options: type, determines style. One of: 'info' | 'error' | 'warning' | 'success'.message parameter to specify the content of the dialog. ","version":"Next","tagName":"h3"},{"title":"Spinner​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#spinner","content":"Shows a loading spinner. Accept an optional size to make the spinner larger / smaller. ","version":"Next","tagName":"h3"},{"title":"NUX​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#nux","content":"An element that can be used to provide a New User eXperience: Hints that give a one-time introduction to new features to the current user. For more details, see the Style Guide. ","version":"Next","tagName":"h3"},{"title":"FileSelector​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#fileselector","content":"Enables file uploading. Shows an input with an upload button. User can select and upload files by clicking on the button, on the input, by pressing enter when the input is focused, and by dropping a file on the input. The input's value is a path to a file or its name if path is not available (in browsers). Exports FileSelector components with the following props: label - placeholder text displayed in the input when it is empty.onChange - callback called when new files are selected or when the existing selection is reset.multi - [optional] allows selecting multiple files at once.extensions - [optional] list of allowed file extensions.required - [optional] boolean to mark the file selection input as required.encoding - [optional] imported file encoding. Default: UTF-8.className - [optional] class name string.style - [optional] CSS styles object. ","version":"Next","tagName":"h3"},{"title":"DetailSidebar​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#detailsidebar","content":"An element that can be passed children which will be shown in the right sidebar of Flipper. Horizontal scrolling will be enabled by default. To fine-tune the default dimensions use width and minWidth. It doesn't really matter where exactly this component is used in your layout, as the contents will be moved to the main Flipper chrome, rather than being rendered in place. ","version":"Next","tagName":"h3"},{"title":"theme object​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#theme-object","content":"Provides a standard set of colors and spacings, used by the Flipper Style Guide. The colors exposed here support dark mode. ","version":"Next","tagName":"h3"},{"title":"Utilities​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#utilities","content":"","version":"Next","tagName":"h2"},{"title":"suggestNewPlugin​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#suggestnewplugin","content":"Display a pop-up prompting users switch to a new plugin ","version":"Next","tagName":"h3"},{"title":"getFlipperLib​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#getflipperlib","content":"A set of globally available utilities such as opening links, interacting with the clipboard (see the following example), and many more. Example: getFlipperLib().writeTextToClipboard(&quot;hello from Flipper&quot;);  The full set of utilities is listed in FlipperLib.tsx. Since the Node.js system API's cannot be used directly by Flipper plugins (when running in a browser), the utilties exposed on getFlipperLib().remoteServerContext should be used instead, as detailed in Using Node.js APIs. ","version":"Next","tagName":"h3"},{"title":"createTablePlugin​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#createtableplugin","content":"A utility to create a plugin that consists of a main table and details JSON view with minimal effort. For an example, see the Building a Desktop Plugin - Showing a Table tutorial. createTablePlugin creates a plugin that handles receiving data from the client and displaying it in a table. The table handles selection of items, sorting, filtering and rendering a sidebar where more detailed information can be presented about the selected row. The plugin expects to be able to subscribe to the method argument and receive single data objects. Each data object represents a row in the table. An optional resetMethod argument can be provided that replaces the current rows with the data provided. This is useful when connecting to Flipper for this first time, or reconnecting to the client in an unknown state. Since the createTablePlugin defines both the plugin and Component for the plugin in one go, making the result is most easily done by using module.exports = createTablePlugin(....) so that both are exported from the plugin package. Valid options are: method: string - the event that is sent from the corresponding client plugin and should be collected.resetMethod?: string - an event name, that, when sent from the client, should clear the current table.columns: DataTableColumn - a description of the columns to display (see DataTable in the 'UI Components' page.key?: string - if set, the specified field of the incoming data will be treated as unique identifier. Receiving new data for existing rows will replace the existing rows. Without this property the table will only be appended.onCopyRows?: (rows) =&gt; string - a function that can be used to customize how records are copied to the clipboard. By default, they are JSON.stringify-ed.buildRow?: (rawData) =&gt; row - a function that can be used to preprocess the incoming data before it is handed off to the table.renderSidebar?: (row) =&gt; React.Element - a function that can be used to customize how the sidebar is rendered. ","version":"Next","tagName":"h3"},{"title":"batched​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#batched","content":"","version":"Next","tagName":"h3"},{"title":"batch​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#batch","content":"Usage: batch(() =&gt; { /* state updates */ }) Low-level utility to batch state updates to reduce the number of potential re-renders by React. Wraps React's unstable_batchedUpdates. Event handlers provided by React or flipper-plugin already apply batch automatically, so using this utility is only recommended when updating plugin state in an asynchronous process. ","version":"Next","tagName":"h3"},{"title":"produce​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#produce","content":"A convenience re-export of produce from Immer. The update method of the state atoms returned by createState automatically applies produce to its updater function. ","version":"Next","tagName":"h3"},{"title":"renderReactRoot​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#renderreactroot","content":"Usage: renderReactRoot(handler: (unmount: () =&gt; void) =&gt; React.ReactElement) Renders an element outside the current DOM tree. This is a low-level utility that can be used to render for example Modal dialogs. The provided handler function should return the root element to be rendered. Once the element can be removed from the DOM, the unmount callback should be called. Example: renderReactRoot((unmount) =&gt; ( &lt;RequiredParametersDialog onHide={unmount} uri={filteredQuery} requiredParameters={params} onSubmit={navigateTo} /&gt; ));  ","version":"Next","tagName":"h3"},{"title":"sleep​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#sleep","content":"Usage: await sleep(1000) Creates a promise that automatically resolves after the specified number of milliseconds. ","version":"Next","tagName":"h3"},{"title":"timeout​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#timeout","content":"Usage await timeout(1000, promise, message?) ","version":"Next","tagName":"h3"},{"title":"styled​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#styled","content":"A convenience re-export of styled from emotion. ","version":"Next","tagName":"h3"},{"title":"textContent​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#textcontent","content":"Given a string or React element, returns a text representation of that element, that is suitable as plain text. ","version":"Next","tagName":"h3"},{"title":"path​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#path","content":"A set of utilizities to handle file paths. A subset of Node.js' path. path.basename(path[, ext])​ path {string}ext {string} An optional file extensionReturns: {string} The path.basename() method returns the last portion of a path, similar to the Unix basename command. Trailing directory separators are ignored. path.basename('/foo/bar/baz/asdf/quux.html'); // Returns: 'quux.html' path.basename('/foo/bar/baz/asdf/quux.html', '.html'); // Returns: 'quux'  path.extname(path)​ path {string}Returns: {string} The path.extname() method returns the extension of the path, from the last occurrence of the . (period) character to end of string in the last portion of the path. If there is no . in the last portion of the path, or if there are no . characters other than the first character of the basename of path (see path.basename()) , an empty string is returned. path.extname('index.html'); // Returns: '.html' path.extname('index.coffee.md'); // Returns: '.md' path.extname('index.'); // Returns: '.' path.extname('index'); // Returns: '' path.extname('.index'); // Returns: '' path.extname('.index.md'); // Returns: '.md'  path.join([...paths])​ ...paths {string} A sequence of path segmentsReturns: {string} The path.join() method joins all given path segments together using the platform-specific separator as a delimiter, then normalizes the resulting path. Zero-length path segments are ignored. If the joined path string is a zero-length string then '.' will be returned, representing the current working directory. path.join('/foo', 'bar', 'baz/asdf', 'quux', '..'); // Returns: '/foo/bar/baz/asdf'  path.normalize(path)​ path {string}Returns: {string} The path.normalize() method normalizes the given path, resolving '..' and'.' segments. When multiple, sequential path segment separation characters are found (e.g./), they are replaced by a single instance of /. Trailing separators are preserved. If the path is a zero-length string, '.' is returned, representing the current working directory. path.normalize('/foo/bar//baz/asdf/quux/..'); // Returns: '/foo/bar/baz/asdf'  ","version":"Next","tagName":"h3"},{"title":"uuid​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#uuid","content":"Usage: uuid() Returns UUID V4. ","version":"Next","tagName":"h3"},{"title":"safeStringify​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#safestringify","content":"Usage: safeStringify(dataStructure) Serialises the given data structure using JSON.stringify, but doesn't throw if the processes failed, but rather returns a &lt;unserializable ...&gt; string. ","version":"Next","tagName":"h3"},{"title":"createControlledPromise​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#createcontrolledpromise","content":"Creates a promise and functions to resolve/reject it externally. Also provides its current state. Returns: // When the promise is pending type Res&lt;T&gt; = { promise: Promise&lt;T&gt;; resolve: (...res: T extends void ? [] : [T]) =&gt; void; reject: (reason: unknown) =&gt; void; state: 'pending'; promiseVal: undefined; } | { promise: Promise&lt;T&gt;; resolve: (...res: T extends void ? [] : [T]) =&gt; void; reject: (reason: unknown) =&gt; void; state: 'resolved'; // Resolved value promiseVal: T; } | { promise: Promise&lt;T&gt;; resolve: (...res: T extends void ? [] : [T]) =&gt; void; reject: (reason: unknown) =&gt; void; state: 'rejected'; // Rejection reason promiseVal: unknown; }  Usage: const controllerPromise = createControlledPromise() someService.on('event', (val) =&gt; controllerPromise.resolve(val)) await controllerPromise.promise  ","version":"Next","tagName":"h3"},{"title":"isAtom​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#isatom","content":"Usage: isAtom(value) Checks if value is an Atom. Returns boolean. ","version":"Next","tagName":"h3"},{"title":"reportPluginFailures​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#reportpluginfailures","content":"Wraps a promise together with a description of the action that's performed and the name of the plugin to track success rates and duration of the actions. This is a no-op for the open-source version of Flipper as we do not collect any data from users. Example usage: import {reportPluginFailures} from 'flipper-plugin'; const lastCreatedBisect: PreviousBisects = await reportPluginFailures( graphQLQuery( `query MyQuery { viewer { data (first: 1) { nodes { id date_created } } } }`, 60 * 1000, ), 'queryMyQuery', 'myplugin', );  ","version":"Next","tagName":"h3"},{"title":"tryCatchReportPluginFailures​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#trycatchreportpluginfailures","content":"See above for reportPluginFailures. This takes a callback and wraps it in a try/catch block instead of expecting a promise. ","version":"Next","tagName":"h3"},{"title":"tryCatchReportPluginFailuresAsync​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#trycatchreportpluginfailuresasync","content":"Same as tryCatchReportPluginFailures but for async functions. ","version":"Next","tagName":"h3"},{"title":"TestUtils​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#testutils","content":"The object TestUtils as exposed from flipper-plugin exposes utilities to write unit tests for Sandy plugins. Different utilities are exposed depending on whether you want to test a client or device plugin, and whether or not the component should be rendered or only the logic itself is going to be tested. It is recommended to follow the Tutorial first, as it explains how unit tests should be setup. ","version":"Next","tagName":"h2"},{"title":"Starting a plugin​","type":1,"pageTitle":"Desktop Plugin API","url":"/docs/extending/flipper-plugin/#starting-a-plugin","content":"Usage: const runner = TestUtils.startPlugin(pluginModule, options?)const runner = TestUtils.renderPlugin(pluginModule, options?)const runner = TestUtils.startDevicePlugin(devicePluginModule, options?)const runner = TestUtils.renderDevicePlugin(devicePluginModule, options?) Starts a client plugin in a fully mocked environment, but without rendering support. The pluginModule is an object that has a plugin (or devicePlugin and supportsDevice) and Component property. Typically, it is invoked with startPlugin(PluginUnderTest), where PluginUnderTest is loaded like import * as PluginUnderTest from &quot;../index.tsx&quot; (the path to the actual definition). However, it doesn't have to be loaded with an entire module, and a local object with the same signature can be constructed as well. startPlugin options​ The options argument is optional, but can specify the following fields: initialState: Can be used to start the plugin in a certain state, rather than in the default state. initialState should be an object that specifies for all the state atoms that have the persist option set, their initial value. For example: { initialState: { rows: [&quot;hello&quot;, &quot;world&quot;]}}, where rows matches the persist key of an atom.isArchived: boolean: Setting this flag, will set the isArchived on the mocked device as well. Set it if you want to test the behavior of your plugin for imported devices (see also Device.isArchived). Defaults to false.isBackgroundPlugin: This makes sure the test runner emits life-cycle events in a way that is typical for background plugins. Defaults to false. The notable difference in behavior is that calling .active() on the test runner won't trigger the connect event to be fired, nor the .deactivate() the disconnect event.startUnactivated: This does not activate the plugin; connect needs to be explicitly called. This can be used in case setting mock implementation for onSend is required to make sure Client plugin works as expected. Defaults to false.GKs: A string array of gatekeeper names for which client.GK will true inside the test. By default GKs are assumed to be disabled inside unit tests. The test runner object​ startPlugin returns an object that can be used to inspect and interact with your plugin instance. Again, see the tutorial how to interact with this object in general. The test runner is a bag full of utilities, but typically it is fine to just destructure the utilities relevant for the test. Exposed members: instance: The object (public API) returned from your plugin definition. You will typically use this in most tests, either to trigger updates or to inspect the current state of the plugin.exportState(): Grabs the current state of all persist enabled state atoms. The object format returned here is the same as in the initialState option.activate(): Emulate the onActivate event. By default, startPlugin already starts the plugin in activated state and calling activate to test the onActivate event should be preceded by a deactivate() call first.deactivate(): Emulates a user navigating away from the plugin.destroy(): Emulates the plugin being cleaned up, for example because the plugin is disabled by the user, or because the device / client has disconnected. After calling destroy the current runner is unusable.triggerDeepLink(payload): Emulates a deepLink being triggered and fires the onDeepLink event.triggerMenuEntry(label): Emulates the user clicking a menu entry in the Flipper main menu.flipperLib: An object that exposed jest.fn() mocks for all built-in Flipper APIs that can be called by your plugin. So, assertions can be made that the plugin did actually invoke those methods. For example: expect(runner.flipperLib.createPaste).toBeCalledWith(&quot;test message&quot;). Currently supported mocks: createPaste, enableMenuEntries. The following members are available when using the render... variant rather than the start... variant: renderer: This object can be used to query the DOM and further interact with it. It is provided by react-testing-library, and further documented in the render Result page.act: Use this function to wrap interactions with the plugin under test into a transaction, after which the DOM updates will be flushed by React. See also the React.js act() documentation. The following members are only available for Client plugins: sendEvent(event, params): Emulates an event being sent by the client plugin. Will trigger the corresponding onMessage handler in the plugin.sendEvents({ method: string, params: object}[]): Like sendEvent, but sends multiple events at once.onSend: A jest.fn() that can be used to assert that client.send() was called by the plugin under test. For example, expect(runner.onSend).toBeCalledWith('currentLogs', { since: 0}).connect(): Triggers the onConnect() event. (For non-background plugins activate() could as well be used for this).disconnect(): Triggers the onDisconnect() event. (For non-background plugins deactivate() could as well be used for this). The following members are only available for Device plugins: sendLogEntry(logEntry): Emulates a log message arriving from the device. Triggers the client.device.onLogEntry listener. ","version":"Next","tagName":"h3"},{"title":"Adding Flipper to Android apps with Gradle","type":0,"sectionRef":"#","url":"/docs/getting-started/android-native/","content":"","keywords":"","version":"Next"},{"title":"Dependencies​","type":1,"pageTitle":"Adding Flipper to Android apps with Gradle","url":"/docs/getting-started/android-native/#dependencies","content":"Flipper is distributed via Maven Central: add the dependencies to your build.gradle file. You should also explicitly depend on SoLoader instead of relying on transitive dependency resolution, which is getting deprecated with Gradle 5. There is a 'no-op' implementation of some oft-used Flipper interfaces, which you can use to make it easier to strip Flipper from your release builds: repositories { mavenCentral() } dependencies { debugImplementation 'com.facebook.flipper:flipper:0.245.0' debugImplementation 'com.facebook.soloader:soloader:0.10.5' releaseImplementation 'com.facebook.flipper:flipper-noop:0.245.0' }  danger The flipper-noop package provides a limited subset of the APIs provided by the flipper package and does not provide any plugin stubs. It's recommended that you keep all Flipper instantiation code in a separate build variant to ensure it doesn't accidentally make it into your production builds. To see how to organise your Flipper initialization into debug and release variants, check this sample app. Alternatively, have a look at the third-party flipper-android-no-op repository, which provides empty implementations for several Flipper plugins. ","version":"Next","tagName":"h2"},{"title":"Application setup​","type":1,"pageTitle":"Adding Flipper to Android apps with Gradle","url":"/docs/getting-started/android-native/#application-setup","content":"Now you can initialize Flipper in your Application's onCreate method, which involves initializing SoLoader (for loading the C++ part of Flipper) and starting a FlipperClient. KotlinJava import com.facebook.flipper.android.AndroidFlipperClient import com.facebook.flipper.android.utils.FlipperUtils import com.facebook.flipper.core.FlipperClient import com.facebook.flipper.plugins.inspector.DescriptorMapping import com.facebook.flipper.plugins.inspector.InspectorFlipperPlugin class MyApplication : Application { override fun onCreate() { super.onCreate() SoLoader.init(this, false) if (BuildConfig.DEBUG &amp;&amp; FlipperUtils.shouldEnableFlipper(this)) { val client = AndroidFlipperClient.getInstance(this) client.addPlugin(InspectorFlipperPlugin(this, DescriptorMapping.withDefaults())) client.start() } } }  ","version":"Next","tagName":"h2"},{"title":"Diagnostics​","type":1,"pageTitle":"Adding Flipper to Android apps with Gradle","url":"/docs/getting-started/android-native/#diagnostics","content":"It's recommended that you add the following activity to the manifest, which can help diagnose integration issues and other problems: &lt;activity android:name=&quot;com.facebook.flipper.android.diagnostics.FlipperDiagnosticActivity&quot; android:exported=&quot;true&quot;/&gt;  ","version":"Next","tagName":"h2"},{"title":"Android snapshots​","type":1,"pageTitle":"Adding Flipper to Android apps with Gradle","url":"/docs/getting-started/android-native/#android-snapshots","content":"note Android snapshot releases are published directly off main. You can get the latest version by adding the Maven Snapshot repository to your sources and pointing to the most recent -SNAPSHOT version. repositories { maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' } } dependencies { debugImplementation 'com.facebook.flipper:flipper:0.245.1-SNAPSHOT' debugImplementation 'com.facebook.soloader:soloader:0.10.5' releaseImplementation 'com.facebook.flipper:flipper-noop:0.245.1-SNAPSHOT' }  ","version":"Next","tagName":"h2"},{"title":"Enabling plugins​","type":1,"pageTitle":"Adding Flipper to Android apps with Gradle","url":"/docs/getting-started/android-native/#enabling-plugins","content":"Finally, you need to add plugins to your Flipper client. Above, the Layout Inspector plugin has been added to get you started. See the Network Plugin and Layout Inspector Plugin pages for information on how to add them, and also enable Litho or ComponentKit support. For examples of integrating other plugins, take a look at the sample apps in the GitHub repo. ","version":"Next","tagName":"h2"},{"title":"Issues or questions​","type":1,"pageTitle":"Adding Flipper to Android apps with Gradle","url":"/docs/getting-started/android-native/#issues-or-questions","content":"If you encounter any issues or have any questions, refer to the Troubleshooting section. ","version":"Next","tagName":"h2"},{"title":"Adding Flipper to Generic iOS Apps","type":0,"sectionRef":"#","url":"/docs/getting-started/ios-native/","content":"","keywords":"","version":"Next"},{"title":"CocoaPods​","type":1,"pageTitle":"Adding Flipper to Generic iOS Apps","url":"/docs/getting-started/ios-native/#cocoapods","content":"The following configuration assumes CocoaPods 1.9+: project 'MyApp.xcodeproj' flipperkit_version = '0.233.0' target 'MyApp' do platform :ios, '10.0' # It is likely that you'll only want to include Flipper in debug builds, # in which case you add the `:configuration` directive: pod 'FlipperKit', '~&gt;' + flipperkit_version, :configuration =&gt; 'Debug' pod 'FlipperKit/FlipperKitLayoutComponentKitSupport', '~&gt;' + flipperkit_version, :configuration =&gt; 'Debug' pod 'FlipperKit/SKIOSNetworkPlugin', '~&gt;' + flipperkit_version, :configuration =&gt; 'Debug' pod 'FlipperKit/FlipperKitUserDefaultsPlugin', '~&gt;' + flipperkit_version, :configuration =&gt; 'Debug' # ...unfortunately at this time that means you'll need to explicitly mark # transitive dependencies as being for debug build only as well: pod 'Flipper-DoubleConversion', :configuration =&gt; 'Debug' pod 'Flipper-Folly', :configuration =&gt; 'Debug' pod 'Flipper-Glog', :configuration =&gt; 'Debug' pod 'Flipper-PeerTalk', :configuration =&gt; 'Debug' pod 'CocoaLibEvent', :configuration =&gt; 'Debug' pod 'boost-for-react-native', :configuration =&gt; 'Debug' pod 'OpenSSL-Universal', :configuration =&gt; 'Debug' pod 'CocoaAsyncSocket', :configuration =&gt; 'Debug' # ...except, of course, those transitive dependencies that your # application itself depends, e.g.: pod 'ComponentKit', '~&gt; 0.31' # If you use `use_frameworks!` in your Podfile, # uncomment the below $static_framework array and also # the pre_install section. This will cause Flipper and # it's dependencies to be built as a static library and all other pods to # be dynamic. # # NOTE Doing this may lead to a broken build if any of these are also # transitive dependencies of other dependencies and are expected # to be built as frameworks. # # $static_framework = ['FlipperKit', 'Flipper', 'Flipper-Folly', # 'CocoaAsyncSocket', 'ComponentKit', 'Flipper-DoubleConversion', # 'Flipper-Glog', 'Flipper-PeerTalk', 'Flipper-RSocket', 'Yoga', 'YogaKit', # 'CocoaLibEvent', 'OpenSSL-Universal', 'boost-for-react-native', 'Flipper-Fmt'] # # pre_install do |installer| # Pod::Installer::Xcode::TargetValidator.send(:define_method, :verify_no_static_framework_transitive_dependencies) {} # installer.pod_targets.each do |pod| # if $static_framework.include?(pod.name) # def pod.build_type; # Pod::BuildType.static_library # end # end # end # end end  ","version":"Next","tagName":"h2"},{"title":"For pure Objective-C projects​","type":1,"pageTitle":"Adding Flipper to Generic iOS Apps","url":"/docs/getting-started/ios-native/#for-pure-objective-c-projects","content":"For pure Objective-C projects, add the following to your settings: /usr/lib/swift as the first entry of the LD_RUNPATH_SEARCH_PATHS Add the following in LIBRARY_SEARCH_PATHS &quot;\\&quot;$(TOOLCHAIN_DIR)/usr/lib/swift/$(PLATFORM_NAME)\\&quot;&quot;, &quot;\\&quot;$(TOOLCHAIN_DIR)/usr/lib/swift-5.0/$(PLATFORM_NAME)\\&quot;&quot;, If, after following the above two steps, there are still errors such as Undefined symbol _swift_getFunctionReplacement, then set DEAD_CODE_STRIPPING to YES. The reference for this fix is in the Swift forum This is done to overcome a bug with Xcode 11 which fails to compile Swift code when bitcode is enabled. Flipper transitively depends on YogaKit, which is written in Swift. For more information about this issue, refer to the Swift code tweet and Github issue. Install the dependencies by running pod install. You can now import and initialize Flipper in yourAppDelegate. ObjCSwift #import &lt;FlipperKit/FlipperClient.h&gt; #import &lt;FlipperKitLayoutPlugin/FlipperKitLayoutPlugin.h&gt; #import &lt;FlipperKitLayoutComponentKitSupport/FlipperKitLayoutComponentKitSupport.h&gt; #import &lt;FlipperKitUserDefaultsPlugin/FKUserDefaultsPlugin.h&gt; #import &lt;FlipperKitNetworkPlugin/FlipperKitNetworkPlugin.h&gt; #import &lt;SKIOSNetworkPlugin/SKIOSNetworkAdapter.h&gt; @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { FlipperClient *client = [FlipperClient sharedClient]; SKDescriptorMapper *layoutDescriptorMapper = [[SKDescriptorMapper alloc] initWithDefaults]; [FlipperKitLayoutComponentKitSupport setUpWithDescriptorMapper: layoutDescriptorMapper]; [client addPlugin: [[FlipperKitLayoutPlugin alloc] initWithRootNode: application withDescriptorMapper: layoutDescriptorMapper]]; [client addPlugin:[[FKUserDefaultsPlugin alloc] initWithSuiteName:nil]]; [client addPlugin: [[FlipperKitNetworkPlugin alloc] initWithNetworkAdapter:[SKIOSNetworkAdapter new]]]; [client start]; ... } @end  ","version":"Next","tagName":"h2"},{"title":"Enabling plugins​","type":1,"pageTitle":"Adding Flipper to Generic iOS Apps","url":"/docs/getting-started/ios-native/#enabling-plugins","content":"Finally, you need to add plugins to your Flipper client. The Layout Inspector plugin is shown above to get you started. See Network Plugin and Layout Inspector Plugin for information on how to add them and enable Litho or ComponentKit support. You can check the sample apps in the GitHub repo for examples of integrating other plugins. ","version":"Next","tagName":"h2"},{"title":"Issues or questions​","type":1,"pageTitle":"Adding Flipper to Generic iOS Apps","url":"/docs/getting-started/ios-native/#issues-or-questions","content":"If you encounter any issues or have any questions, refer to the Troubleshooting section. ","version":"Next","tagName":"h2"},{"title":"Virtual devices","type":0,"sectionRef":"#","url":"/docs/features/virtual-devices/","content":"Virtual devices You can use flipper to launch iOS simulators and Android emulators. Select &quot;Virtual devices&quot; from the flipper menu From the opened modal you can select available virtual devices. Select the one you want and it will shortly open and connect to Flipper. You can also &quot;favorite&quot; your most used devices to always display them in the top of the list.","keywords":"","version":"Next"},{"title":"React Native App - Automatic Setup","type":0,"sectionRef":"#","url":"/docs/getting-started/react-native/","content":"","keywords":"","version":"Next"},{"title":"Using the latest Flipper SDK​","type":1,"pageTitle":"React Native App - Automatic Setup","url":"/docs/getting-started/react-native/#using-the-latest-flipper-sdk","content":"By default, React Native might ship with an outdated Flipper SDK. To make sure you are using the latest version, determine the latest released version of Flipper by running npm info flipper. Latest version of Flipper requires react-native 0.69+! If you use react-native &lt; 0.69.0, please, downgrade react-native-flipper to 0.162.0 (see this GitHub issue for details). Android: Bump the FLIPPER_VERSION variable in android/gradle.properties, for example: FLIPPER_VERSION=0.245.0.Run ./gradlew clean in the android directory. iOS: react-native version =&gt; 0.69.0 Call FlipperConfiguration.enabled with a specific version in ios/Podfile, for example: :flipper_configuration =&gt; FlipperConfiguration.enabled([&quot;Debug&quot;], { 'Flipper' =&gt; '0.190.0' }),.Run pod install --repo-update in the ios directory. react-native version &lt; 0.69.0 Call use_flipper with a specific version in ios/Podfile, for example: use_flipper!({ 'Flipper' =&gt; '0.245.0' }).Run pod install --repo-update in the ios directory. ","version":"Next","tagName":"h3"},{"title":"Manual Setup​","type":1,"pageTitle":"React Native App - Automatic Setup","url":"/docs/getting-started/react-native/#manual-setup","content":"If you are not using a default React Native template or cannot use the upgrade tool, you can find instructions for how to integrate Flipper into your projects in the following guides: React Native for AndroidReact Native for iOS ","version":"Next","tagName":"h2"},{"title":"Troubleshooting Introduction","type":0,"sectionRef":"#","url":"/docs/getting-started/troubleshooting/","content":"","keywords":"","version":"Next"},{"title":"How to file an issue or ask a question?​","type":1,"pageTitle":"Troubleshooting Introduction","url":"/docs/getting-started/troubleshooting/#how-to-file-an-issue-or-ask-a-question","content":"If you are still blocked after checking Troubleshooting guide you may file an issue on GitHubwith the chrome DevTools logs and the output from the diagnostics screen, if relevant.  ","version":"Next","tagName":"h2"},{"title":"Set up your JavaScript App","type":0,"sectionRef":"#","url":"/docs/getting-started/javascript/","content":"","keywords":"","version":"Next"},{"title":"Dependencies​","type":1,"pageTitle":"Set up your JavaScript App","url":"/docs/getting-started/javascript/#dependencies","content":"Flipper JavaScript SDK is distributed via NPM. To add it to your app, use either the following: npm install js-flipper  or yarn add js-flipper  ","version":"Next","tagName":"h2"},{"title":"Application Setup​","type":1,"pageTitle":"Set up your JavaScript App","url":"/docs/getting-started/javascript/#application-setup","content":"Flipper SDK works in browser and Node.js environments: browsers - works out-of-the-box if your browser supports WebSockets.node.js - requires a compatible WebSocket implementation (such as ws). caution You MUST NOT start Flipper client in production. In browser environments, you should think about not including it in the final production build at all. To setup Flipper in your browser, use the following: import flipperClient from 'js-flipper'; // Start the client and pass your app name flipperClient.start('My cool browser app');  Following is how you can do it in your Node.js app: import flipperClient from 'js-flipper'; // Say, you decided to go with 'ws' as your WebSocket implementation // https://github.com/websockets/ws import WebSocket from 'ws'; // Start the client and pass your app name // You might ask yourself why there is the second argument `{ origin: 'localhost:' }` // Flipper Desktop verifies the `Origin` header for every WS connection. You need to set it to one of the whitelisted values (see `VALID_WEB_SOCKET_REQUEST_ORIGIN_PREFIXES`). flipperClient.start('My cool nodejs app', { websocketFactory: url =&gt; new WebSocket(url, {origin: 'localhost:'}) });  flipperClient accepts an options object as a second parameter to its start method. The following code shows what you can pass to it: interface FlipperClientOptions { // Make the client connect to a different URL urlBase?: string; // Override WebSocket implementation (Node.js folks, it is for you!) websocketFactory?: (url: string) =&gt; FlipperWebSocket; // Override how errors are handled (it is simple `console.error` by default) onError?: (e: unknown) =&gt; void; // Timeout after which client tries to reconnect to Flipper reconnectTimeout?: number; }  ","version":"Next","tagName":"h2"},{"title":"Enabling plugins​","type":1,"pageTitle":"Set up your JavaScript App","url":"/docs/getting-started/javascript/#enabling-plugins","content":"Flipper is just a communication channel between the desktop app and your application; its true power comes from its plugins. All plugins must be added to the client. Client communicates the list of available plugins to the desktop upon connection. You can add a plugin by calling the following: flipperClient.addPlugin(/* your plugin */)  Refer to the documentation on creating plugins to write your own! ","version":"Next","tagName":"h2"},{"title":"Troubleshooting Android Issues","type":0,"sectionRef":"#","url":"/docs/getting-started/troubleshooting/android/","content":"","keywords":"","version":"Next"},{"title":"Stuck in \"Currently Connecting...\"​","type":1,"pageTitle":"Troubleshooting Android Issues","url":"/docs/getting-started/troubleshooting/android/#stuck-in-currently-connecting","content":"There are sadly many non-deterministic reasons why Flipper may not be able to connect. It can often help to restart all pieces related to the connection: Kill the app on the emulator and restart it.Restart the emulator.Restart adb with adb kill-server &amp;&amp; adb start-server.The nuclear option: Restart your computer (especially when USB connectivity is involved) ","version":"Next","tagName":"h2"},{"title":"In-app diagnostics​","type":1,"pageTitle":"Troubleshooting Android Issues","url":"/docs/getting-started/troubleshooting/android/#in-app-diagnostics","content":"The Flipper SDK includes an in-app connection diagnostics screen to help you diagnose problems. Replace &lt;APP_PACKAGE&gt; below with the package name of your app, for example, such as com.facebook.flipper.sample. On a terminal, run the following: adb shell am start -n &lt;APP_PACKAGE&gt;/com.facebook.flipper.android.diagnostics.FlipperDiagnosticActivity  This will only work if you added FlipperDiagnosticActivity to your AndroidManifest.xml. See getting started for help. ","version":"Next","tagName":"h2"},{"title":"Exception from call site #4 bootstrap method​","type":1,"pageTitle":"Troubleshooting Android Issues","url":"/docs/getting-started/troubleshooting/android/#exception-from-call-site-4-bootstrap-method","content":"Build error after including the Flipper dependency: Exception from call site #4 bootstrap method  This can happen because we include OkHttp3 as dependency which makes use of Java 8 features. There are two ways of dealing with this: Enable Java 8 support Add this to your Gradle config: android { compileOptions { targetCompatibility = &quot;8&quot; sourceCompatibility = &quot;8&quot; } }  Exclude the OkHttp3 dependency Alternatively, if you don't plan on making use of OkHttp, you can exclude the dependency from the build entirely: debugImplementation('com.facebook.flipper:flipper:*') { exclude group: 'com.squareup.okhttp3' }  ","version":"Next","tagName":"h2"},{"title":"Duplicate class com.facebook.jni.*​","type":1,"pageTitle":"Troubleshooting Android Issues","url":"/docs/getting-started/troubleshooting/android/#duplicate-class-comfacebookjni","content":"This can occur when mixing different versions of FBJNI, a library we use to interact with native C++ code. Speficially, this can happen when the versions 0.0.x and 0.1.x are mixed. Version 0.1.0 of FBJNI switched to using Google Prefab for distributing native artifacts, which made the split into combined, &quot;java-only&quot; and &quot;header&quot; packages redundant and only requires a single dependency in your projects. When including both &quot;fbjni-java-only:0.0.1&quot; and &quot;fbjni:0.1.0&quot; in one project, you will now duplicate class errors during the build process. You must ensure that only one of the two versions is used in your entire dependency tree. Start by looking at ./gradlew :myapp:dependencies to see where the different version requirements come from. Then exclude the FBJNI dependency from one of them, as follows: implementation(&quot;com.facebook.react:react-native:+&quot;) { exclude group:'com.facebook.fbjni' }  ","version":"Next","tagName":"h2"},{"title":"React Native - Manual Android Setup","type":0,"sectionRef":"#","url":"/docs/getting-started/react-native-android/","content":"","keywords":"","version":"Next"},{"title":"Dependencies​","type":1,"pageTitle":"React Native - Manual Android Setup","url":"/docs/getting-started/react-native-android/#dependencies","content":"Flipper is distributed via Maven Central: add the dependencies to your build.gradle file. You should also explicitly depend on SoLoader` instead of relying on transitive dependency resolution, which is getting deprecated with Gradle 5. repositories { mavenCentral() } dependencies { debugImplementation('com.facebook.flipper:flipper:0.35.0') { exclude group:'com.facebook.fbjni' } debugImplementation('com.facebook.flipper:flipper-network-plugin:0.35.0') { exclude group:'com.facebook.flipper' } }  These exclusions are currently necessary to avoid some clashes with FBJNI shared libraries. ","version":"Next","tagName":"h2"},{"title":"Application Setup​","type":1,"pageTitle":"React Native - Manual Android Setup","url":"/docs/getting-started/react-native-android/#application-setup","content":"For maximum flexibility, it's recommended you move the Flipper initialization to a separate class that lives in a debug/ folder, so that Flipper code never gets referenced in a release build. import android.content.Context; import com.facebook.flipper.android.AndroidFlipperClient; import com.facebook.flipper.android.utils.FlipperUtils; import com.facebook.flipper.core.FlipperClient; import com.facebook.flipper.plugins.inspector.DescriptorMapping; import com.facebook.flipper.plugins.inspector.InspectorFlipperPlugin; import com.facebook.react.ReactInstanceManager; import okhttp3.OkHttpClient; public class ReactNativeFlipper { public static void initializeFlipper(Context context, ReactInstanceManager reactInstanceManager) { if (FlipperUtils.shouldEnableFlipper(context)) { final FlipperClient client = AndroidFlipperClient.getInstance(context); client.addPlugin(new InspectorFlipperPlugin(context, DescriptorMapping.withDefaults())); } } }  Note that this only enables the Layout Inspector plugin. For details of more plugins, see the React Native template. In your Application implementation, call the static method using reflection. This gives us a lot of flexibility, but can be quite noisy. Alternatively, recreate an empty ReactNativeFlipper class in a release/ folder, so you can call into the method directly. public class MainApplication extends Application implements ReactApplication { // ... @Override public void onCreate() { super.onCreate(); SoLoader.init(this, /* native exopackage */ false); initializeFlipper(this, getReactNativeHost().getReactInstanceManager()); } /** * Loads Flipper in React Native templates. Call this in the onCreate method with something like * initializeFlipper(this, getReactNativeHost().getReactInstanceManager()); * * @param context * @param reactInstanceManager */ private static void initializeFlipper( Context context, ReactInstanceManager reactInstanceManager) { if (BuildConfig.DEBUG) { try { /* We use reflection here to pick up the class that initializes Flipper, since Flipper library is not available in release mode */ Class&lt;?&gt; aClass = Class.forName(&quot;com.example.ReactNativeFlipper&quot;); aClass .getMethod(&quot;initializeFlipper&quot;, Context.class, ReactInstanceManager.class) .invoke(null, context, reactInstanceManager); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchMethodException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } catch (InvocationTargetException e) { e.printStackTrace(); } } } }  ","version":"Next","tagName":"h2"},{"title":"Further Steps​","type":1,"pageTitle":"React Native - Manual Android Setup","url":"/docs/getting-started/react-native-android/#further-steps","content":"To create your own plugins and integrate with Flipper using JavaScript, take a look at the Building a React Native Plugin tutorial! ","version":"Next","tagName":"h2"},{"title":"Install Android SDK","type":0,"sectionRef":"#","url":"/docs/getting-started/troubleshooting/install-android-sdk/","content":"Install Android SDK Make sure Android Studio is installed. Launch Android Studio If it is reported as &quot;damaged&quot;, open Applications directory in Finder, right click Android Studio.app and select &quot;Open&quot; Do not send statistics to google &quot;Next&quot; to download SDK &quot;Next&quot; to download selected SDK &quot;Next&quot; to verify settings Accept License Agreement and click &quot;Finish&quot; Wait for install to finish (about 2 minutes)&quot;Finish&quot; for Downloading Components","keywords":"","version":"Next"},{"title":"Troubleshooting General Issues","type":0,"sectionRef":"#","url":"/docs/getting-started/troubleshooting/general/","content":"","keywords":"","version":"Next"},{"title":"Flipper won't launch on Mac​","type":1,"pageTitle":"Troubleshooting General Issues","url":"/docs/getting-started/troubleshooting/general/#flipper-wont-launch-on-mac","content":"If the window is appearing, try opening the Chrome DevTools within Flipper. To do so, from the View menu select 'Toggle Developer Tools' or press CMD+Option+I and check if there are any errors on the console.Launch Flipper from the command line using /Applications/Flipper.app/Contents/MacOS/Flipper. This should give you some logs, that might be helpful when debugging.Delete ~/.flipper and try relaunching Flipper.Delete Flipper from your applications folder and re-install it.If you're using yarn start to run from source, make sure all dependencies are installed correctly by running yarn install. ","version":"Next","tagName":"h2"},{"title":"No plugins showing up for your device​","type":1,"pageTitle":"Troubleshooting General Issues","url":"/docs/getting-started/troubleshooting/general/#no-plugins-showing-up-for-your-device","content":"Check your device isn't on the list of known incompatibilities.Make sure your version of Flipper is up to date.Make sure the mobile SDK you are using is relatively recent (&lt;1 month old).Open Chrome dev tools within Flipper. To do so, from the View menu select Toggle Developer Tools or press CMD+Option+I and check if there are any errors on the console.Delete ~/.flipper.Uninstall and reinstall the mobile app.Make sure the time and date are set correctly on your mobile device and desktop computer.If no app plugins are showing up, there may be a connectivity issue between Flipper and your app. Check connection issues to see if anything is failing. ","version":"Next","tagName":"h2"},{"title":"Known Incompatibilities​","type":1,"pageTitle":"Troubleshooting General Issues","url":"/docs/getting-started/troubleshooting/general/#known-incompatibilities","content":"The following devices are known to be incompatible or face issues with Flipper: Some Samsung devices (Tracking Issue).Genymotion emulators on Android 8+ are reported to have issues. ","version":"Next","tagName":"h2"},{"title":"I see \"No emulators available\"​","type":1,"pageTitle":"Troubleshooting General Issues","url":"/docs/getting-started/troubleshooting/general/#i-see-no-emulators-available","content":"For Android, you first need to set up Android Virtual Devices, called AVDs. You can do this in Android Studio using the Virtual Device Manager. For iOS, after installing Xcode, you should have a default set of simulators set up. However, it is possible to delete them and there is no easy way to restore them afterwards. You can usea script like this one to recreate the default set. ","version":"Next","tagName":"h2"},{"title":"React Native - Manual iOS Setup","type":0,"sectionRef":"#","url":"/docs/getting-started/react-native-ios/","content":"","keywords":"","version":"Next"},{"title":"Dependencies​","type":1,"pageTitle":"React Native - Manual iOS Setup","url":"/docs/getting-started/react-native-ios/#dependencies","content":"","version":"Next","tagName":"h2"},{"title":"React Native 0.63+​","type":1,"pageTitle":"React Native - Manual iOS Setup","url":"/docs/getting-started/react-native-ios/#react-native-063","content":"If using React Native 0.63 or later, your ios/Podfile should look like this: platform :ios, '10.0' require_relative '../node_modules/react-native/scripts/react_native_pods' require_relative '../node_modules/@react-native-community/cli-platform-ios/native_modules' target 'your-app-name' do config = use_native_modules! use_react_native!(path: config['reactNativePath']) # Enables Flipper. # # Note that if you have use_frameworks! enabled, Flipper will not work and # you should disable these next few lines. use_flipper!({'Flipper' =&gt; '0.58.0'}) # should match the version of your Flipper client app post_install do |installer| flipper_post_install(installer) end end  Install the dependencies by running cd ios &amp;&amp; pod install then continue to Initialization. ","version":"Next","tagName":"h3"},{"title":"React Native 0.62​","type":1,"pageTitle":"React Native - Manual iOS Setup","url":"/docs/getting-started/react-native-ios/#react-native-062","content":"In version 0.62, the setup includes a bit more code (which was moved to a helper in 0.63). Add all of the code below to your ios/Podfile: platform :ios, '9.0' def flipper_pods() flipperkit_version = '0.245.0' # should match the version of your Flipper client app pod 'FlipperKit', '~&gt;' + flipperkit_version, :configuration =&gt; 'Debug' pod 'FlipperKit/FlipperKitLayoutPlugin', '~&gt;' + flipperkit_version, :configuration =&gt; 'Debug' pod 'FlipperKit/SKIOSNetworkPlugin', '~&gt;' + flipperkit_version, :configuration =&gt; 'Debug' pod 'FlipperKit/FlipperKitUserDefaultsPlugin', '~&gt;' + flipperkit_version, :configuration =&gt; 'Debug' pod 'FlipperKit/FlipperKitReactPlugin', '~&gt;' + flipperkit_version, :configuration =&gt; 'Debug' end # Post Install processing for Flipper def flipper_post_install(installer) file_name = Dir.glob(&quot;*.xcodeproj&quot;)[0] app_project = Xcodeproj::Project.open(file_name) app_project.native_targets.each do |target| target.build_configurations.each do |config| cflags = config.build_settings['OTHER_CFLAGS'] || '$(inherited) ' unless cflags.include? '-DFB_SONARKIT_ENABLED=1' puts 'Adding -DFB_SONARKIT_ENABLED=1 in OTHER_CFLAGS...' cflags &lt;&lt; '-DFB_SONARKIT_ENABLED=1' end config.build_settings['OTHER_CFLAGS'] = cflags end app_project.save end installer.pods_project.save end target 'your-app-name' do ... # Replace the existing yoga import with the following (adding modular_headers): pod 'Yoga', :path =&gt; '../node_modules/react-native/ReactCommon/yoga', :modular_headers =&gt; true ... use_native_modules! # For enabling Flipper. # Note that if you use_framework!, flipper will not work. # Disable these lines if you are doing use_framework! flipper_pods() post_install do |installer| flipper_post_install(installer) end end  Install the dependencies by running cd ios &amp;&amp; pod install. You can now import and initialize Flipper in your AppDelegate. ","version":"Next","tagName":"h3"},{"title":"Initialization​","type":1,"pageTitle":"React Native - Manual iOS Setup","url":"/docs/getting-started/react-native-ios/#initialization","content":"The code below enables the following integrations: Layout InspectorNetworkShared PreferencesCrash Reporter ","version":"Next","tagName":"h2"},{"title":"React Native 0.68+​","type":1,"pageTitle":"React Native - Manual iOS Setup","url":"/docs/getting-started/react-native-ios/#react-native-068","content":"If using React Native 0.68 or later, your AppDelegate should include ... #import &lt;React/RCTAppSetupUtils.h&gt;  RCTAppSetupUtils takes care of initializing Flipper and the integrations mentioned above. ","version":"Next","tagName":"h3"},{"title":"React Native 0.67​","type":1,"pageTitle":"React Native - Manual iOS Setup","url":"/docs/getting-started/react-native-ios/#react-native-067","content":"iOSSwift ... #if DEBUG #ifdef FB_SONARKIT_ENABLED #import &lt;FlipperKit/FlipperClient.h&gt; #import &lt;FlipperKitLayoutPlugin/FlipperKitLayoutPlugin.h&gt; #import &lt;FlipperKitLayoutPlugin/SKDescriptorMapper.h&gt; #import &lt;FlipperKitNetworkPlugin/FlipperKitNetworkPlugin.h&gt; #import &lt;FlipperKitReactPlugin/FlipperKitReactPlugin.h&gt; #import &lt;FlipperKitUserDefaultsPlugin/FKUserDefaultsPlugin.h&gt; #import &lt;SKIOSNetworkPlugin/SKIOSNetworkAdapter.h&gt; #endif #endif @implementation AppDelegate - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [self initializeFlipper:application]; ... } - (void) initializeFlipper:(UIApplication *)application { #if DEBUG #ifdef FB_SONARKIT_ENABLED FlipperClient *client = [FlipperClient sharedClient]; SKDescriptorMapper *layoutDescriptorMapper = [[SKDescriptorMapper alloc] initWithDefaults]; [client addPlugin: [[FlipperKitLayoutPlugin alloc] initWithRootNode: application withDescriptorMapper: layoutDescriptorMapper]]; [client addPlugin: [[FKUserDefaultsPlugin alloc] initWithSuiteName:nil]]; [client addPlugin: [FlipperKitReactPlugin new]]; [client addPlugin: [[FlipperKitNetworkPlugin alloc] initWithNetworkAdapter:[SKIOSNetworkAdapter new]]]; [client start]; #endif #endif } @end  Lastly, open the Flipper desktop app, and run yarn ios in your terminal. ","version":"Next","tagName":"h3"},{"title":"Issues or questions​","type":1,"pageTitle":"React Native - Manual iOS Setup","url":"/docs/getting-started/react-native-ios/#issues-or-questions","content":"If you encounter any issues or have any questions, refer to the Troubleshooting section. ","version":"Next","tagName":"h2"},{"title":"Further Steps​","type":1,"pageTitle":"React Native - Manual iOS Setup","url":"/docs/getting-started/react-native-ios/#further-steps","content":"To create your own plugins and integrate with Flipper using JavaScript, check out our Building a React Native Plugin tutorial! ","version":"Next","tagName":"h2"},{"title":"Install iOS SDK","type":0,"sectionRef":"#","url":"/docs/getting-started/troubleshooting/install-ios-sdk/","content":"Install iOS SDK Make sure Xcode is installed. Launch Xcode. Launch XcodeAccept SDKs Agreement Select iOS platform and optionally otherClick Download &amp; Install Wait for SDK's to install Dismiss What's new in Xcode","keywords":"","version":"Next"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/internals/","content":"Introduction This part of the site is for those interested in how Flipper works 'under the hood'. 'Under the Hood' contains the following topics: Contributing to the Codebase - contains information that helps you make contributions to the Flipper codebase.Device Identifiers - details availabe methods for obtaining device identifiers.Linters - a list of Linters that are used to enforce sustainable coding practices within Flipper.Public Flipper Releases - the mechanism behind Flipper releases on GitHub.Testing React Native Changes - how to use the 'ReactNativeFlippeExample' app to test React Native changes.","keywords":"","version":"Next"},{"title":"Troubleshooting iOS Issues","type":0,"sectionRef":"#","url":"/docs/getting-started/troubleshooting/ios/","content":"","keywords":"","version":"Next"},{"title":"In-app diagnostics​","type":1,"pageTitle":"Troubleshooting iOS Issues","url":"/docs/getting-started/troubleshooting/ios/#in-app-diagnostics","content":"You'll need to manually add this ViewController to your app to see the in-app diagnostics. ","version":"Next","tagName":"h2"},{"title":"iOS device not showing up​","type":1,"pageTitle":"Troubleshooting iOS Issues","url":"/docs/getting-started/troubleshooting/ios/#ios-device-not-showing-up","content":"Make sure idb is installed and configured in the Flipper settings. ","version":"Next","tagName":"h2"},{"title":"iOS simulator device not showing up​","type":1,"pageTitle":"Troubleshooting iOS Issues","url":"/docs/getting-started/troubleshooting/ios/#ios-simulator-device-not-showing-up","content":"Ensure that your simulator is on the same version as selected in xcode-select. You can do that by checking that commands ps aux | grep CoreSimulator and xcode-select -p shows the same Xcode version. If not, update the xcode version by sudo xcode-select --switch &lt;Path to xcode&gt; ","version":"Next","tagName":"h2"},{"title":"iOS app connection error \"Connection failed. Failed to find device...\"​","type":1,"pageTitle":"Troubleshooting iOS Issues","url":"/docs/getting-started/troubleshooting/ios/#ios-app-connection-error-connection-failed-failed-to-find-device","content":"If during connecting iOS app to Flipper you see error message &quot;Connection failed. Failed to find device [device_id] while trying to connect app&quot; - try executing idb kill on a terminal and restarting Flipper as workaround to reset idb state. ","version":"Next","tagName":"h2"},{"title":"Contributing to the Codebase","type":0,"sectionRef":"#","url":"/docs/internals/contributing/","content":"","keywords":"","version":"Next"},{"title":"Changelog Entries​","type":1,"pageTitle":"Contributing to the Codebase","url":"/docs/internals/contributing/#changelog-entries","content":"A changelog dialog is displayed when a new version of Flipper is started for the first time. It can also be seen by clicking on the button next to the version number in the 'Welcome' screen.  The content is automatically generated during the release process. You should always include a changelog entry if there is a user-visible change in your commit. To contribute a message, include a note in the body of your commit like in example below. note Unlike other blocks that Phabricator expects (such as 'Summary' and 'Test Plan'), the changelog can only be a single line. The spelling is not case-sensitive. [layout] Add Unicorn support Summary: Finally, the moment we've all been waiting for: Unicorn support! Changelog: Unicorns can be inspected in the Layout Plugin Test Plan: ...  ","version":"Next","tagName":"h2"},{"title":"Implementation​","type":1,"pageTitle":"Contributing to the Codebase","url":"/docs/internals/contributing/#implementation","content":"You can find the code for the changelog generation in desktop/scripts/generate-changelog.js. ","version":"Next","tagName":"h3"},{"title":"Device Identifiers","type":0,"sectionRef":"#","url":"/docs/internals/device-identifiers/","content":"","keywords":"","version":"Next"},{"title":"How does Flipper map connecting apps to their respective devices?​","type":1,"pageTitle":"Device Identifiers","url":"/docs/internals/device-identifiers/#how-does-flipper-map-connecting-apps-to-their-respective-devices","content":"Over the years, for security reasons, both Apple and Google have locked down their APIs so that apps can't find any value that could be considered unique such as a MAC address or serial numbers. This means there's no OS API available. To obtain this device identifier, a two-way approached had to be used. ","version":"Next","tagName":"h2"},{"title":"Obtaining the device identifier​","type":1,"pageTitle":"Device Identifiers","url":"/docs/internals/device-identifiers/#obtaining-the-device-identifier","content":"From the Flipper Desktop side, connected devices are discovered and listed using idb or adb as mentioned above, by which it sees some TCP connections coming in from apps. It is during the certificate exchange process that we do the mapping from apps to device. In this process, an app creates and sends a Certificate Signing Request (CSR) to Flipper Desktop alongside some other data including the path in the application sandbox where this CSR was originally written. When Flipper Desktop is processing the request, it effectively lists all possible connected devices and proceeds to try and pull the CSR from each device. The CSR is then compared with the one sent by the client. If there's a match, we have successfully made the pairing and the device identifier is sent back to the client. The client receives the device identifier and uses this information for subsequent secure TCP connections. When a secure TCP connection is established, the device identifier is passed along and thus Flipper is able to map the connecting app to its running device. The following diagram depicts this process.  ","version":"Next","tagName":"h3"},{"title":"Troubleshooting React Native Issues","type":0,"sectionRef":"#","url":"/docs/getting-started/troubleshooting/react-native/","content":"","keywords":"","version":"Next"},{"title":"I don't see the 'React Native' device​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#i-dont-see-the-react-native-device","content":"Make sure that the Metro server is running.Make sure you are on React Native 0.62 or higher.Verify that the @react-native-community/cli version is 0.47.0 or higher (using yarn why @react-native-community/cli). ","version":"Next","tagName":"h3"},{"title":"I see my device / emulator, but I can't see the app​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#i-see-my-device--emulator-but-i-cant-see-the-app","content":"Make sure you are running a debug build. Flipper only supports debug builds.If you are upgraded from RN &lt; 0.62.2, make sure you've updated all the dependencies and build related files according to the upgrade helper. For example: https://react-native-community.github.io/upgrade-helper/?from=0.61.4&amp;to=0.62.2If you upgraded, make sure you made a clean build: cd android &amp;&amp; ./gradlew clean, cd iOS &amp;&amp; pod install --repo-update.For iOS, make sure it works on a simulator first.(Unconfirmed) check the deployment info target in the XCode project settings. Target should be iOS 9.0. ","version":"Next","tagName":"h3"},{"title":"I'm seeing \"certificate verify failed, type = SSL error\" in the logs​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#im-seeing-certificate-verify-failed-type--ssl-error-in-the-logs","content":"Ensure that your device is set to the correct time and time zone for TLS verification to work. ","version":"Next","tagName":"h3"},{"title":"I see my app, but I don't see the external plugins I've installed​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#i-see-my-app-but-i-dont-see-the-external-plugins-ive-installed","content":"Make sure you've installed the desktop part of the plugin (usually through 'Manage plugins' in Flipper). If no plugins show up under 'Manage plugins' &gt; 'Status' make sure you've selected your running device in the Flipper toolbar (and not 'React Native').Make sure you've installed the app part of the plugin. Typically, the installation instructions of the plugin itself need to be followed here.Make sure you've installed the latest version of react-native-flipper in your app, and run pod install in the iOS dir afterwards.Make sure you've restarted both Flipper and your app. ","version":"Next","tagName":"h3"},{"title":"On iOS it seems that the Flipper dependencies are compiled when making a release build​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#on-ios-it-seems-that-the-flipper-dependencies-are-compiled-when-making-a-release-build","content":"That is correct. The dependencies won't be included in the release (when using react-native-flipper &gt; 0.45) and can't be excluded from the build process. ","version":"Next","tagName":"h3"},{"title":"The React DevTools don't seem to connect​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#the-react-devtools-dont-seem-to-connect","content":"Make sure there are no other instances of the React DevTools are running (such as a stand-alone version). Restart Flipper if needed after closing other tools.Make sure you have only one device running to connect to. If there are multiple devices, close them and try again (restart Flipper if needed).Make sure there is only one RN app running on the device. ","version":"Next","tagName":"h3"},{"title":"Cannot inspect an element in the React DevTools: \"Could not inspect element with id ...\"​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#cannot-inspect-an-element-in-the-react-devtools-could-not-inspect-element-with-id-","content":"On selecting a specific element in the React DevTools, the &quot;Could not inspect element with id XXX&quot; appears when the version of the DevTools shipped in Flipper is incompatible with the react-devtools-core package used by the React Native application. Flipper supports using a globally installed react-devtools (after using npm install -g react-devtools@x.x.x) instead of the embedded one. This should help with any compatibility issues. Another way to fix this is to set the resolutions field in the package.json of the app to force a specific version and then run yarn install, for example: &quot;resolutions&quot;: { &quot;react-devtools-core&quot;: &quot;4.13.2&quot; }  ","version":"Next","tagName":"h3"},{"title":"How to select a specific element in the React DevTools?​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#how-to-select-a-specific-element-in-the-react-devtools","content":"Trigger the debug menu on your RN app (you can use the button in the Flipper toolbar).Use Show Inspector. Flipper now follows the selection on your device. ","version":"Next","tagName":"h3"},{"title":"The Hermes Debugger does not connect​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#the-hermes-debugger-does-not-connect","content":"Make sure the Hermes engine is enabled.Make sure only one device with React Native is running.Make sure there is only one RN app running on the device.Make sure the React Native app is not in debug mode already (trigger dev menu, and make sure that Remote JS Debugging is not enabled). ","version":"Next","tagName":"h3"},{"title":"iOS Build errors in React Native​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#ios-build-errors-in-react-native","content":"First, make sure your cocoapods is up to date (sudo gem install cocoapods), and that you are using the latest FlipperKit. For inexplainable build errors, clone and verify if our reference project builds and runs locally. If it does, it's recommended to compare the package.json and ios/Podfile files with yours. If that doesn't yield anything, compare the ios/Podfile.lock as well to verify any transitive pod dependencies need updating. ","version":"Next","tagName":"h3"},{"title":"YogaKit.modulemap not found​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#yogakitmodulemap-not-found","content":"Make sure you are opening the .xcodeworkspace dir when building from XCode, not the project file. Pods based projects should always be opened this way.Make sure you've run cd ios &amp;&amp; pod install.Restarting your machine seems to magically fix the issue for quite some people. This might especially be needed after doing an XCode upgrade.Make sure that the simulators are spawned by your current Xcode version. Force quite all simulators, run sudo xcode-select --switch /Applications/Xcode.app (update path were necessary) and start simulators &amp; Flipper again.Make sure the iOS build target version aligns with the podfile and target iOS 11 (see the following Example).Verify XCode has enough permissions.More solutions might be found in this thread. ","version":"Next","tagName":"h3"},{"title":"Swift errors​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#swift-errors","content":"If you experience errors such as Undefined symbol: associated type descriptor for FloatLiteralType or Undefined symbol: __swift_FORCE_LOAD_$_swiftCompatibility50 after going through the Getting Started page, do the following: Open your project in Xcode. Click in your project's name on the left side. Make sure that you choose your project under PROJECT on the screen that has been opened. Go to the tab Build Settings. Search for LD_RUNPATH_SEARCH_PATHS (make sure that All is selected). Double-click Runpath Search Paths and, in the dialog that opens, click on the plus button at the bottom-left corner and paste /usr/lib/swift $(inherited) there. Now search for LIBRARY_SEARCH_PATHS. Double-click Library Search Paths and, in the dialog that opens, add the following items. &quot;$(TOOLCHAIN_DIR)/usr/lib/swift/$(PLATFORM_NAME)&quot; &quot;$(TOOLCHAIN_DIR)/usr/lib/swift-5.0/$(PLATFORM_NAME)&quot; &quot;$(inherited)&quot; note All of them should be added as non-recursive (the default). In the end it should look as follows: Now you can run your build normally. ","version":"Next","tagName":"h3"},{"title":"Opting out from Flipper (iOS)​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#opting-out-from-flipper-ios","content":"Comment out the relevant lines in ios/Podfile and run cd ios &amp;&amp; pod install again:  # use_flipper! # post_install do |installer| # flipper_post_install(installer) # end  ","version":"Next","tagName":"h2"},{"title":"Disable Flipper on CI builds (iOS)​","type":1,"pageTitle":"Troubleshooting React Native Issues","url":"/docs/getting-started/troubleshooting/react-native/#disable-flipper-on-ci-builds-ios","content":"To speed up CI builds, Flipper can be disabled on CI environments by making the Flipper SDK inclusion conditional (this works on most CI providers, feel free to customize the environment variable):  if !ENV['CI'] use_flipper! post_install do |installer| flipper_post_install(installer) end end  ","version":"Next","tagName":"h2"},{"title":"Flipper Docs Standards","type":0,"sectionRef":"#","url":"/docs/internals/documentation-standards/","content":"","keywords":"Flipper docs standards Flipper docs rules","version":"Next"},{"title":"Key standards​","type":1,"pageTitle":"Flipper Docs Standards","url":"/docs/internals/documentation-standards/#key-standards","content":"The Flipper Docs team is committed to writing docs that serve users. To measure and maintain satisfactory documentation quality, the following key standards are used: Completeness\tDiscoverability\tAccessibility\tAccuracyIs the information sufficient to give the reader a good understanding or to provide a solid solution to a problem?\tIf the information exists, is it easy to find?\tIs the information accessible to readers of different capability?\tIs the information accurate and up to date? To help you achieve each of these standards, several points for consideration are listed in the following sub-sections (or you can select a column header to link to its sub-section). ","version":"Next","tagName":"h2"},{"title":"Completeness​","type":1,"pageTitle":"Flipper Docs Standards","url":"/docs/internals/documentation-standards/#completeness","content":"Completeness is determined by how many questions, and the type of questions, the reader may have after reading your document. For example, if after reading a Flipper document on 'getting help and providing feedback', the reader asked the question &quot;Where do I go if I'm a noob?&quot; then the document might not be complete. To increase your document's completeness, consider the following: Limit Assumptions.Trade-offs and limitations of APIs and approaches should be discussed openly.Where possible, describe alternatives to what you're describing: understanding the available options empowers people to feel confident in their choices.Give tips you think are particularly useful.The user shouldn't have to navigate to different documentation sources (such as Wiki pages and posts) to gain a core understanding.Explain what success looks like.The discussion of a technical topic shouldn't be in the 'Getting Started' section.Is each step explained, or does it rely on other knowledge?Empathize with the reader. Consider questions such as: &quot;Are they trying to learn how to do something?&quot; and &quot;Has something gone wrong and they're trying to figure out if a solution is possible?&quot; ","version":"Next","tagName":"h3"},{"title":"Discoverability​","type":1,"pageTitle":"Flipper Docs Standards","url":"/docs/internals/documentation-standards/#discoverability","content":"Discoverability is the degree to which a piece of information (instruction, guideline, code snippet, and so on) can be found within the Flipper Documentation website. To improve your document's discoverability, consider the following: Add appropriate keywords to your file. The keywords are used by Static Doc's search tool.Is the information easy to find. Test for keyword searches to see if and where in the result list your documentation is listed.Consider the placement of the file (if you're adding a new one). ","version":"Next","tagName":"h3"},{"title":"Accessibility​","type":1,"pageTitle":"Flipper Docs Standards","url":"/docs/internals/documentation-standards/#accessibility","content":"Accessibility is the measure of how easy it is for users of different capability to read, understand and navigate your documentation. To improve your document's accessibility, think about the following: Is non-standard terminology fully defined before being used (this includes the use of abbreviations).Is it easy to understand and apply the documented information?The most effective medium (words, diagrams, images, videos, examples, or a combination). ","version":"Next","tagName":"h3"},{"title":"Accuracy​","type":1,"pageTitle":"Flipper Docs Standards","url":"/docs/internals/documentation-standards/#accuracy","content":"Accuracy is determined by how relevant, correct, and up to date the content of your documentation is. To ensure your document's accuracy, think about the following: Ensure that all 'Live' code samples are relevant to the topic being covered and provide appropriate output.Explain the relevant aspects of the snippet functionality clearly.When making any changes to procedure, architecture, or code, make the documentation of those changes part of the change request. ","version":"Next","tagName":"h3"},{"title":"Writing Guide","type":0,"sectionRef":"#","url":"/docs/internals/documentation-writing-guide/","content":"","keywords":"flipper website writing tips flipper docs writing tips flipper documentation guidelines","version":"Next"},{"title":"Why Documentation Is Needed​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#why-documentation-is-needed","content":"Some of the benefits of documentation include: Immediate availability - from the easily accessible Flipper Documentation websiteFewer support requests - the more information that's available online, the fewer the number of support requests. Also, colleagues that raise requests can be directed to the documentation website, which frees up the time of the person being asked.Knowledge base - provides a permanent record of Flipper knowledge, rather than it being isolated to one or more specialists. By making documentation part of your work routine, it becomes less of a burden: the more you write, the easier it gets. ","version":"Next","tagName":"h2"},{"title":"Adding or editing content​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#adding-or-editing-content","content":"You may be creating content for a new document or updating the content of an existing document. Whatever the reason, there are two key points to consider before you make any changes: Tone of voice - this is the 'voice style' used to communicate the content to the reader.Documentation style - this is the tools used to communicate the content to the reader, such as bullet points, images, tables, bold text, headers, videos, and so on. The trick is knowing when to use them and how to use them effectively. Both of these key points are detailed in the following sub-sections. ","version":"Next","tagName":"h2"},{"title":"Tone of voice​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#tone-of-voice","content":"Important The content of any material you create for any aspect of Meta's documentation must fully comply with Meta's values, policies, and initiatives, and must incorporate Meta's principles of diversity, equity and inclusion. For details, see the following: Meta People Portal.Building Better: The Meta Code of Conduct. Consider how you'd explain a work-related task to a colleague; the words you'd use and the manner in which you'd say them. Following are some points to consider, which will help you to adopt the write 'tone of voice' in your documentation: Semi-formal - imagine talking to a colleague whom you've just met in the workplace. When explaining something to them, you wouldn't want to be too formal, but you'd also like to appear friendly.Professional - all communication must follow Meta company guidelines and policies and incorporate the principles of diversity, equity and inclusion.Descriptive - don't go off-topic: keep to the topic that is relevant to the page/section. Textual information should be well-explained but not excessive. Lists, images and videos can be used to reduce large blocks of text (see Markdown Formatting).Engaging - the correct use of pronouns can aid comprehension and help to keep the reader engaged and comprehension (see below). ","version":"Next","tagName":"h2"},{"title":"The magic of pronouns​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#the-magic-of-pronouns","content":"The correct use of pronouns can increase the reader's engagement, enjoyment, and comprehension of the information in your documentation. Following are some guidelines on when to use particular pronouns (it does matter): Use the pronouns 'You', 'Your', and 'Yours' - the main benefit of using them is that it increases the reader's sense of involvement in the content and promotes a friendly tone by addressing the reader directly (think about how you'd explain something complex to your colleague). As a result, your page's reader will find the content more engaging, easier to remember, and easier to understand. These pronouns are especially useful when you want to detail a series of steps that the reader must follow.Use the pronouns 'We' and 'Our' - the main reason for their use is that they emphasise the reader's team or organisation, which gives the reader a sense of community and team spirit. These pronouns are especially useful when you want to describe something that involves the Flipper team, such as the reasons for the decision to use a particular technology or how the reader's actions can benefit the team.Don't use the pronouns 'I' and 'My' - the main reason is that it emphasizes the writer rather than the reader. Also, it may cause confusion, reduce engagement, or be the source of annoyance as the reader may not know the identity of the writer. ","version":"Next","tagName":"h3"},{"title":"Spelling and grammar​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#spelling-and-grammar","content":"Bad spelling and grammar can have a negative effect on the tone of voice in your document (making it irritating to read and difficult to understand). The problem is that we all make unintentional spelling and grammar errors when writing. Fortunately, there are three steps you can take to reduce (or, hopefully, remove all) those errors: Read it - when you think you've finished, read though the content and make the appropriate corrections.MS Word it - use the spelling and grammar checker to identify any errors.Review it - before your page is published, it will be reviewed as part of its Diff lifecycle. Make sure you consider all of the changes suggested by the Reviewers. This is not going to be 100% effective every time, but it will definitely help to get as close to 100% as possible. ","version":"Next","tagName":"h3"},{"title":"Documentation style​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#documentation-style","content":"Documentation style involves two areas of interest: Structural Format - this includes the format of the page title and the headers and includes topics such as: How many words to use.How to capitalise.How to improve the discoverability of the content. Documentation Tools - this includes the following: When and how to use the available tools (such as bullet points, tables images, videos, and much more).How to format the content for the selected tool. ","version":"Next","tagName":"h2"},{"title":"Structural format​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#structural-format","content":"","version":"Next","tagName":"h2"},{"title":"Page title​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#page-title","content":"The title provides an at-a-glance summary of a page's content. It is also used in the SideBar so assists with navigation of the Flipper Documentation website. Consider the following guidelines before choosing a page title. Short but descriptive - the title should be short but also descriptive enough to convey the main topic of the page's content.Capitalization - use the 'Title' case associated with the Chicago Manual of Style (17th edition). For details of a helpful online tool, see Header and title capitalization tool, below.Titles should be unique - use a title that is not used elsewhere within the Flipper Documentation website. ","version":"Next","tagName":"h3"},{"title":"Headers​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#headers","content":"Good documentation is split into a series of sections that are logically structured and cover the subject matter. Headings are used for the document's Table of Contents, which provide the reader with an outline of the document and assists with navigation. Headers indicate document structure - start each main section with a level 2 header. Sub-sections (header levels 3 to 5) should follow a hierarchical structure and be associated with, or relevant to, their parent header.Keep headers short - while keeping your headers as short as possible, make sure they contain enough words to indicate the information contained within the section/sub-section.Keep Headers unique - consider how a header will be listed in the result set of a search from the Static Docs website.Capitalisation of headers - use the 'Sentence' case associated with the Chicago Manual of Style (17th edition). For details of a helpful online tool, see Header and title capitalization tool, below.Use Blank Lines - make sure there is one blank line between a heading and the text in its section/sub-section. Header and title capitalization tool​ To assist with the capitalization of your page's title and headers, go to the online tool Capitalize My Title, then: For the title - select the 'Chicago' tab and click the 'Title Case' option.For headers - select the 'Chicago' tab and click the 'Sentence case' option. As you enter the title/header, the tool automatically converts it to the selected style, which you can then copy/paste into your editor. Markdown code​ For examples of using Markdown for headers, see Markdown Formatting ","version":"Next","tagName":"h3"},{"title":"Markdown tools​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#markdown-tools","content":"","version":"Next","tagName":"h2"},{"title":"Code snippets​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#code-snippets","content":"Code examples are one of the best ways to help your readers take their understanding to the next level by providing them with something they can actually view and experiment with on their own. note Remember that a snippet is 'a small part or piece of a thing' so keep your snippet as short as possible and relevant to the section in which it's located. When providing code snippets, first create an example in the Flipper shell and then directly reference that example in your documentation. This enables the Flipper website to ensure that code in its documentation always stays up-to-date and functional Make sure there is one blank line between the code snippet and any surrounding text. Markdown code​ For an example of using Markdown for code snippets, see Markdown Formatting ","version":"Next","tagName":"h3"},{"title":"Images​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#images","content":"Images includes pictures, diagrams, and screenshots. The well-known adage &quot;A picture is worth a thousand words.&quot; is true but must be accompanied by knowledge of the best way to use images, and an awareness of their limitations. Following are guidelines for the use of images in your documentation: No sensitive or personal data - if you're taking a screenshot that features data, ensure it is test or sample data.Use a lossless format - PNG and SVG files are ideal for websites and PDFs, other formats may look blurred.Use a transparent background - by using a transparent background, you avoid potential color clashes and unwanted image borders caused by your reader's use of a colored or themed background.Avoid colored borders and shadows - a colored border or a shadow might look great against the color you are using but could look ugly against a differently colored background.Consider dark mode backgrounds - when relevant, test your image using light and dark mode; as a result, you may need to replace black/dark grey colors with pastel-colored alternatives (note: this does not apply to screenshots).Size for readability: There's little purpose in using any type of image if the text within it can't be read or needs a magnifying glass.If your image is large, consider splitting into two or more images and show how they are connected.If using a screenshot, zoom in on a specific area of the screen and provide context rather than capturing the whole screen. Be consistent - use the same color and style for callouts and annotations throughout your documentation.Refer to the image - mention the image within the accompanying text. Such as &quot;As shown in the following image...&quot;, or &quot;The image below provides an overview of...&quot; tip Keep in mind that images are meant to complement text, not replace it. Though a picture may be worth a thousand words, the reader still needs the detail contained within the text. ","version":"Next","tagName":"h3"},{"title":"Latin abbreviations​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#latin-abbreviations","content":"The use of some Latin abbreviations (such as 'e.g.', 'etc.', 'i.e.', 'et al.', and so on) should be avoided for the following reasons: Readers of the documentation may not use English as their 'first' language and may be unaware of the meaning of Latin abbreviations.Often, when used, Latin abbreviations are not correctly punctuated, which detracts from the professional tone of the page's content. When tempted to use the Latin abbreviations shown in the following table, consider using the English equivalent. Latin\tEnglish Equivalente.g.\tfor example et al.\tand colleagues / associates / team members etc.\tand so on / and the rest i.e.\tthat is N.B.\tNote note Key point: whenever possible, use plain, easy-to-understand English in your documentation. ","version":"Next","tagName":"h3"},{"title":"Links​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#links","content":"Within Flipper Docs, links are usually text-based and can be used to navigate your readers to several types of link targets, such as the following 'good' links: For information on the type of links to avoid, see Bad links, below.For examples of using Markdown for headers, see the Markdown Formatting page.To learn all about Litho, see the Litho Documentation website. As can be seen in the link examples above, a link consists of the parts shown in the following table (but not necessarily in the same order). Link part\tUsing the first example, aboveLeading Phrase\t&quot;For information on the type of links to avoid, see&quot; Target description\t[Bad links] (Optional) Location\t&quot;, below&quot; or &quot;website&quot; Target\t(#bad-links) or a URL Tips Navigation - tell your readers where they are going, especially if the link takes them away from the Flipper Docs website (see Bad links, below).Test - check that your links do reach the expected target.Access - keep in mind that some readers may not have access to certain pages or domains.Backticks - don't use backticks in links as it changes the link's appearance. It has to look like a link for the user to know they can click on it. Bad links​ It's worth remembering that the reader won't know beforehand where a link is taking them unless it's stated (or at least suggested) in the 'Target description' or the 'Location'. Therefore, it's not a good idea to use links such as the following: For information on the type of links to avoid, see below.Click here to see examples of using Markdown for headers.To learn all about Litho, click here. 'Bad' links could lead to navigation confusion, frustration, and loss of comprehension. Markdown code​ For additional guidelines on using Markdown for links, see Markdown Formatting. ","version":"Next","tagName":"h3"},{"title":"Lists​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#lists","content":"If the information you wish to communicate involves a series of steps, follows a defined procedure, or indicates preference or ranking, use a numbered list, which is also known as an 'ordered' list. If the order of items in the list is irrelevant, use bullet points, which are known collectively as an 'unordered list'. Bullet Points​ Be concise but effective - use as few words as possible but make sure the meaning is not lost.Capitalise the first word - do this for each bullet.One sentence per bullet point - try to stick to one sentence per bullet point.Use emphasis - where possible, emphasize the beginning of each bullet point to give the reader the chance to skim through easily but still get a basic understanding of the content of the list.Use sentences or fragments, not both - within a single list, avoid using bullets that are full sentences mixed with other bullets that are just sentence fragments, phrases, or names.Punctuate consistently: If at least one bullet is a sentence, end all bullets with a full stop. Don't end a bullet with a semicolon (;).If all bullets are phrases, or fragments, use no end punctuation. Use Blank Lines - make sure there is one blank line above and below the list. Numbered List​ Be clear - keep each item in the list to a specific topic or instruction.Be logical - the items in the list should follow a logical flow, which guides the reader though the content in a manner that makes sense.Keep the structure simple - if your list is getting a bit complex in structure or stretches over several pages, consider breaking it up into a series of sub-sections.Punctuate consistently - each item in the list should end with a full stop, unless the item contains bullet points.Use Blank Lines - make sure there is one blank line above and below the numbered list. Example lists​ The bullet points used throughout this page provide examples of the style to be used. note Sometimes, it might not be possible to use an emphasized phrase (the part that is in bold) for each bullet. In such cases, try to apply the other bullet point guidelines to your list. ","version":"Next","tagName":"h3"},{"title":"Tabs​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#tabs","content":"Since Flipper supports multiple platforms, you may need to provide information that is specific to each platform. The Tab tool provides an excellent way of this information via use of the CodeLanguageTabs component. Tabs provide your reader with an easy method of switching from one platform (or process) to another without having to scroll up and down the page. Markdown code​ For an example of using Markdown for tabs, see Markdown Formatting ","version":"Next","tagName":"h3"},{"title":"Videos​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#videos","content":"Videos are an effective method of presenting a lot of information to the reader. However, just like images, the use of videos must be accompanied by knowledge of how to use them effectively. Following are guidelines for the use of video in your documentation: Watch the video - before you use the video in your documentation, watch it to check that its good quality, relevant to the section in which it's located, and provides sufficient information.Keep the content concise: The content of the video should be limited to the specific purpose for which it is being used.For example, if a video is being used to illustrate configuration of a component, it should contain just that process. Refer to the video - mention the video within the section in which it's being used.State the length of the video: If the length of the video is not shown in the video object, state it in the text.For example, &quot;The following 11-second video demonstrates the slightly different 'Hg: Show Head Changes' command&quot;. tip When deciding to use a video, keep in mind that it takes much more time to produce a video than to change some text. A small change to a UI or a process is relatively easy to change in text. The same change in a video may mean it needs to be replaced or removed, which, ultimately, involves much more work. ","version":"Next","tagName":"h3"},{"title":"Resources​","type":1,"pageTitle":"Writing Guide","url":"/docs/internals/documentation-writing-guide/#resources","content":"For additional information, see the following resources: Writing Tips and Recommendations - a wiki for Engineers.Doc Tips &amp; Best Practices Video (18 min) - a video presentation made by Infrastructure Documentation Engineer.Documentation Toolkit - 'Better Engineering' documentation resources.Style your doc with Markdown - information on Markdown Frontmatter and referencing other documents. ","version":"Next","tagName":"h2"},{"title":"Markdown Formatting","type":0,"sectionRef":"#","url":"/docs/internals/documentation-formatting/","content":"","keywords":"flipper website formatting flipper docs formatting","version":"Next"},{"title":"Structural format​","type":1,"pageTitle":"Markdown Formatting","url":"/docs/internals/documentation-formatting/#structural-format","content":"","version":"Next","tagName":"h2"},{"title":"Headers​","type":1,"pageTitle":"Markdown Formatting","url":"/docs/internals/documentation-formatting/#headers","content":"Start each main section with a level 2 header.Sub-sections should follow a hierarchical structure and should use header levels 3 to 5. Markdown Example: The following example Markdown shows how to use headers. ## Level 2 header ### Level 3 header #### Level 4 header ##### Level 5 header  ","version":"Next","tagName":"h3"},{"title":"Markdown tools​","type":1,"pageTitle":"Markdown Formatting","url":"/docs/internals/documentation-formatting/#markdown-tools","content":"","version":"Next","tagName":"h2"},{"title":"Backticks​","type":1,"pageTitle":"Markdown Formatting","url":"/docs/internals/documentation-formatting/#backticks","content":"Use Markdown backticks ( ` ), to provide emphasis for items such as file names, classes, methods, parameters, and expressions. Let's use the `TestComponent`, which has one direct child, `InnerComponent`, and one non-direct child, `Text`.  Result: Let's use the TestComponent, which has one direct child, InnerComponent, and one non-direct child, Text. ","version":"Next","tagName":"h3"},{"title":"Code Snippets​","type":1,"pageTitle":"Markdown Formatting","url":"/docs/internals/documentation-formatting/#code-snippets","content":"For code snippets, remember to add the language tag (javascript is used in the following example). ```javascript import {addPlugin} from &quot;react-native-flipper&quot; addPlugin({ getId() { return 'ReactNativeExamplePlugin'; }, onConnect(connection) { mammmals.forEach(({ title, pictureUrl }, index) =&gt; { connection.send('newRow', { id: index, title, url: pictureUrl }) }) }, onDisconnect() { } })  Result: import {addPlugin} from &quot;react-native-flipper&quot; addPlugin({ getId() { return 'ReactNativeExamplePlugin'; }, onConnect(connection) { mammmals.forEach(({ title, pictureUrl }, index) =&gt; { connection.send('newRow', { id: index, title, url: pictureUrl }) }) }, onDisconnect() { } })  For more code blocks features, such as line highlighting, see the Docusaurus Code blocks document. ","version":"Next","tagName":"h2"},{"title":"Links​","type":1,"pageTitle":"Markdown Formatting","url":"/docs/internals/documentation-formatting/#links","content":"Avoid using bare URLs in your documentation. Instead, use referenced hyperlinks, as shown in the following table. Type\tCode\tDisplays asBare URL\tUpload the video to Pixelcloud at https://www.internalfb.com/intern/px/search\tUpload the video to Pixelcloud at https://www.internalfb.com/intern/px/search Referenced\tUpload the video to [Pixelcloud](https://www.internalfb.com/intern/px/search)\tUpload the video to Pixelcloud tip Notice the use of square brackets around 'PixelCloud' in the referenced hyperlink. ","version":"Next","tagName":"h3"},{"title":"Tabs​","type":1,"pageTitle":"Markdown Formatting","url":"/docs/internals/documentation-formatting/#tabs","content":"To organize content in tabs, Docusaurus provides the Tabs React component: import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem'; &lt;Tabs groupId=&quot;platform&quot; defaultValue=&quot;kotlin&quot; values={[ {label: 'Kotlin', value: 'kotlin'}, {label: 'Java', value: 'java'}, ]}&gt; &lt;TabItem value=&quot;kotlin&quot;&gt; Information about using Kotlin with Flipper. &lt;/TabItem&gt; &lt;TabItem value=&quot;java&quot;&gt; Information about using Java with Flipper. &lt;/TabItem&gt; &lt;/Tabs&gt;  Result: KotlinJava Information about using Kotlin with Flipper. tip To sync several Tabs components on the website set the same groupId for them. More info in Docusaurus Tabs Syncing docs. ","version":"Next","tagName":"h3"},{"title":"Resources​","type":1,"pageTitle":"Markdown Formatting","url":"/docs/internals/documentation-formatting/#resources","content":"For additional information, see the following resources: StaticDocs Markdown featuresDocusaurus Markdown features ","version":"Next","tagName":"h2"},{"title":"Linters","type":0,"sectionRef":"#","url":"/docs/internals/linters/","content":"","keywords":"","version":"Next"},{"title":"Specific Linters​","type":1,"pageTitle":"Linters","url":"/docs/internals/linters/#specific-linters","content":"This section contains an incomplete list of unusual linters we deploy, why we use them, and how to fix them (where relevant). ","version":"Next","tagName":"h2"},{"title":"promise/no-nesting​","type":1,"pageTitle":"Linters","url":"/docs/internals/linters/#promiseno-nesting","content":"Summary - avoid nested then() or catch() statements. For more details, see no-nesting.md on GitHub.Why - nested promise chains can be difficult to read and understand. Often, you can achieve the same result by either returning the promise and handling them on a higher level or converting them to an async function. Example​ Before private pushFileToiOSDevice( udid: string, bundleId: string, destination: string, filename: string, contents: string, ): Promise&lt;void&gt; { return tmpDir({unsafeCleanup: true}).then((dir) =&gt; { const filePath = path.resolve(dir, filename); promisify(fs.writeFile)(filePath, contents).then(() =&gt; iosUtil.push( udid, filePath, bundleId, destination, this.config.idbPath, ), ); }); }  After async pushFileToiOSDevice( udid: string, bundleId: string, destination: string, filename: string, contents: string, ): Promise&lt;void&gt; { const dir = await tmpDir({unsafeCleanup: true}); const filePath = path.resolve(dir, filename); await fs.writeFile(filePath, contents); return iosUtil.push( udid, filePath, bundleId, destination, this.config.idbPath, ); }  In addition to less indentation, you also maintain the promise chain here, meaning that you can handle potential errors on the call-side. ","version":"Next","tagName":"h3"},{"title":"flipper/no-console-error-without-context​","type":1,"pageTitle":"Linters","url":"/docs/internals/linters/#flipperno-console-error-without-context","content":"Summary - avoid 'naked' console.error calls. Prefer console.error(&quot;Failed to connect open iOS connection socket&quot;, e) to console.error(e).Why - we create error tasks internally for every console.error call. It can be hard to find the origin of the error without context. Example​ Before try { // ... } catch (e) { console.error(e); }  After try { // ... } catch (e) { console.error(`Failed to connect to paste host ${hostname}`, e); }  ","version":"Next","tagName":"h3"},{"title":"promise/catch-or-return​","type":1,"pageTitle":"Linters","url":"/docs/internals/linters/#promisecatch-or-return","content":"Summary - ensure that each time a then() is applied to a promise, a catch() is applied as well. Exceptions are made if you are returning that promise. For more details, see catch-or-return.md on GitHub.Why: Unhandled exceptions have no stack trace and will just show up as &quot;Unhandled promise rejection&quot;, making them very hard to triage and reproduce. By always ensuring that promises are returned (ensuring they are a chain) or explicitly catching errors, we can improve the user experience by acting more quickly on errors. Example​ Before function request() { // If fetch() fails, the exception will bubble to the top. fetch(&quot;https://example.com&quot;).then(res =&gt; { doSomethingWith(res); }); }  After // Option 1 function request() { fetch(&quot;https://example.com&quot;).then(res =&gt; { doSomethingWith(res); }).catch((e) =&gt; { console.error(&quot;Failed to fetch from example.com&quot;, e); }); } // Option 2 function request() { // Allow the call-site to handle the error. return fetch(&quot;https://example.com&quot;).then(res =&gt; { doSomethingWith(res); }); }  ","version":"Next","tagName":"h3"},{"title":"communist-spelling/communist-spelling​","type":1,"pageTitle":"Linters","url":"/docs/internals/linters/#communist-spellingcommunist-spelling","content":"Summary - we try to avoid using British spellings for identifiers.Why - this is clearly controversial, but it's very inconvenient when you have to bridge American and British APIs. const greyColour = COLORS.GRAY; is something nobody should have to read or write. Example​ Before const GreyedOutOverlay = initialiseComponent();  After const GrayedOutOverlay = initializeComponent();  ","version":"Next","tagName":"h3"},{"title":"node/no-sync​","type":1,"pageTitle":"Linters","url":"/docs/internals/linters/#nodeno-sync","content":"Summary: Use asynchronous methods wherever possible. More details.Why: Synchronous method calls block the event loop. Even innocuous calls like fs.existsSync() can cause frame drops for users or even long stalls.How to fix it: We have fs-extra as a dependency, which provides Promise-based alternatives for all fs functions. Most often, replacing a sync call with an async call and adding an await is all that's needed. Before import fs from 'fs'; function ensureCertsExist() { if ( !( fs.existsSync(serverKey) &amp;&amp; fs.existsSync(serverCert) &amp;&amp; fs.existsSync(caCert) ) ) { return generateServerCertificate(); } }  After import fsExtra from 'fs-extra'; async function ensureCertsExist() { const allExist = Promise.all([ fsExtra.exists(serverKey), fsExtra.exists(serverCert), fsExtra.exists(caCert), ]).then((exist) =&gt; exist.every(Boolean)); if (!allExist) { return this.generateServerCertificate(); } }  ","version":"Next","tagName":"h3"},{"title":"Crash Reporter Plugin Setup","type":0,"sectionRef":"#","url":"/docs/setup/plugins/crash-reporter/","content":"","keywords":"","version":"Next"},{"title":"Android​","type":1,"pageTitle":"Crash Reporter Plugin Setup","url":"/docs/setup/plugins/crash-reporter/#android","content":"Instantiate and add the plugin in FlipperClient. import com.facebook.flipper.plugins.crashreporter.CrashReporterPlugin; client.addPlugin(CrashReporterPlugin.getInstance());  Use the following API to trigger your custom crash notification. import com.facebook.flipper.plugins.crashreporter.CrashReporterPlugin; CrashReporterPlugin.getInstance().sendExceptionMessage(Thread.currentThread(), error);  ","version":"Next","tagName":"h2"},{"title":"Databases Plugin Setup","type":0,"sectionRef":"#","url":"/docs/setup/plugins/databases/","content":"","keywords":"","version":"Next"},{"title":"Android​","type":1,"pageTitle":"Databases Plugin Setup","url":"/docs/setup/plugins/databases/#android","content":"To use the Databases plugin, instantiate and add it in FlipperClient, as shown in the following code: import com.facebook.flipper.plugins.databases.DatabasesFlipperPlugin; client.addPlugin(new DatabasesFlipperPlugin(context));  By default, it will list all Sqlite databases returned by the context. If you are storing a Sqlite database somewhere else, you can specify a File to it: client.addPlugin(new DatabasesFlipperPlugin(new SqliteDatabaseDriver(context, new SqliteDatabaseProvider() { @Override public List&lt;File&gt; getDatabaseFiles() { List&lt;File&gt; databaseFiles = new ArrayList&lt;&gt;(); for (String databaseName : context.databaseList()) { databaseFiles.add(context.getDatabasePath(databaseName)); } databaseFiles.add(&quot;...path_to_your_db...&quot;); return databaseFiles; } })));  If you use a different type of database other than Sqlite, you can implement a driver to be able to access it via Flipper: client.addPlugin(new DatabasesFlipperPlugin(new DatabaseDriver(context) { @Override public List getDatabases() { return null; } @Override public List&lt;String&gt; getTableNames(DatabaseDescriptor databaseDescriptor) { return null; } @Override public DatabaseGetTableDataResponse getTableData(DatabaseDescriptor databaseDescriptor, String table, String order, boolean reverse, int start, int count) { return null; } @Override public DatabaseGetTableStructureResponse getTableStructure(DatabaseDescriptor databaseDescriptor, String table) { return null; } @Override public DatabaseExecuteSqlResponse executeSQL(DatabaseDescriptor databaseDescriptor, String query) { return null; } }));  ","version":"Next","tagName":"h2"},{"title":"LeakCanary Plugin Setup","type":0,"sectionRef":"#","url":"/docs/setup/plugins/leak-canary/","content":"LeakCanary Plugin Setup To setup the LeakCanary plugin, take the following steps: Ensure that you have an explicit dependency in your application's build.gradle including the plugin dependency, such as is shown in the following snippet: dependencies { debugImplementation 'com.facebook.flipper:flipper-leakcanary2-plugin:0.245.0' debugImplementation 'com.squareup.leakcanary:leakcanary-android:2.8.1' } Update your the onCreate method in you Application to add the LeakCanary2 plugin to Flipper and the Flipper listener to LeakCanary: import com.facebook.flipper.plugins.leakcanary2.FlipperLeakEventListener import com.facebook.flipper.plugins.leakcanary2.LeakCanary2FlipperPlugin ... override fun onCreate() { super.onCreate() /* set the flipper listener in leak canary config */ LeakCanary.config = LeakCanary.config.run { copy(eventListeners = eventListeners + FlipperLeakEventListener()) } SoLoader.init(this, false) if (BuildConfig.DEBUG &amp;&amp; FlipperUtils.shouldEnableFlipper(this)) { val client = AndroidFlipperClient.getInstance(this) /* add leak canary plugin to flipper */ client.addPlugin(LeakCanary2FlipperPlugin()) client.start() } } ","keywords":"","version":"Next"},{"title":"Images Plugin Setup","type":0,"sectionRef":"#","url":"/docs/setup/plugins/fresco/","content":"","keywords":"","version":"Next"},{"title":"Fresco and Android​","type":1,"pageTitle":"Images Plugin Setup","url":"/docs/setup/plugins/fresco/#fresco-and-android","content":"The Fresco Images plugin is shipped as a separate Maven artifact: dependencies { debugImplementation 'com.facebook.flipper:flipper-fresco-plugin:0.30.1' }  After including the plugin in your dependencies, you can add it to the client: import com.facebook.flipper.plugins.fresco.FrescoFlipperPlugin; client.addPlugin(new FrescoFlipperPlugin());  The FrescoFlipperPlugin constructor offers a range of configuration options that can be useful if you have an advanced setup of Fresco in your application: FrescoFlipperPlugin( DebugImageTracker imageTracker, PlatformBitmapFactory bitmapFactory, @Nullable FlipperObjectHelper flipperObjectHelper, DebugMemoryManager memoryManager, FlipperPerfLogger perfLogger, @Nullable FrescoFlipperDebugPrefHelper debugPrefHelper, @Nullable CloseableReferenceLeakTracker closeableReferenceLeakTracker) { ... }  ","version":"Next","tagName":"h2"},{"title":"Leak Tracking​","type":1,"pageTitle":"Images Plugin Setup","url":"/docs/setup/plugins/fresco/#leak-tracking","content":"The Flipper plugin can help you track down CloseableReferences that have not had close() called on them. However, this can have a negative impact on the performance of your application. To enable this functionality, you need to create a CloseableReferenceLeakTracker and set it in both your ImagePipelineConfig for Fresco and the FrescoPluginPlugin on creation: import com.facebook.imagepipeline.debug.FlipperCloseableReferenceLeakTracker; // ... FlipperCloseableReferenceLeakTracker leakTracker = new FlipperCloseableReferenceLeakTracker(); new ImagePipelineConfig.Builder() // ... .setCloseableReferenceLeakTracker(leakTracker) .build(); client.addPlugin(new FrescoFlipperPlugin( new FlipperImageTracker(), Fresco.getImagePipelineFactory().getPlatformBitmapFactory(), null, new NoOpDebugMemoryManager(), new NoOpFlipperPerfLogger(), null, leakTracker));  ","version":"Next","tagName":"h3"},{"title":"Attribution​","type":1,"pageTitle":"Images Plugin Setup","url":"/docs/setup/plugins/fresco/#attribution","content":"In order to annotate images with the context they are used in, you have to set a caller context when loading the image. This can be any object; for the simplest case, a String will suffice, as shown below: String callerContext = &quot;my_feature&quot;; // For DraweeViews: draweeView.setImageURI(uri, callerContext); // For prefetching: ImagePipeline imagePipeline = Fresco.getImagePipeline(); imagePipeline.prefetchToDiskCache(imageRequest, callerContext); // For manually fetching an image: DataSource&lt;CloseableReference&lt;CloseableImage&gt;&gt; dataSource = imagePipeline.fetchDecodedImage(imageRequest, callerContext);  If a caller context is supplied, the image will be properly attributed in the Flipper image plugin. ","version":"Next","tagName":"h3"},{"title":"Layout Plugin Setup","type":0,"sectionRef":"#","url":"/docs/setup/plugins/inspector/","content":"","keywords":"","version":"Next"},{"title":"Android​","type":1,"pageTitle":"Layout Plugin Setup","url":"/docs/setup/plugins/inspector/#android","content":"","version":"Next","tagName":"h2"},{"title":"Standard Android view only​","type":1,"pageTitle":"Layout Plugin Setup","url":"/docs/setup/plugins/inspector/#standard-android-view-only","content":"import com.facebook.flipper.plugins.inspector.DescriptorMapping; import com.facebook.flipper.plugins.inspector.InspectorFlipperPlugin; final DescriptorMapping descriptorMapping = DescriptorMapping.withDefaults(); client.addPlugin(new InspectorFlipperPlugin(mApplicationContext, descriptorMapping));  ","version":"Next","tagName":"h3"},{"title":"With Litho Support​","type":1,"pageTitle":"Layout Plugin Setup","url":"/docs/setup/plugins/inspector/#with-litho-support","content":"Litho support is provided via an optional plugin. You also need to compile in the litho-annotations package, as Flipper reflects on them at runtime. So ensure to not just include them as compileOnly in your gradle configuration: dependencies { debugImplementation 'com.facebook.flipper:flipper-litho-plugin:0.245.0' debugImplementation 'com.facebook.litho:litho-annotations:0.19.0' // ... }  If you want to enable Litho support in the layout inspector, you need to augment the descriptor with Litho-specific settings and add some addition dependencies. import com.facebook.litho.config.ComponentsConfiguration; import com.facebook.flipper.plugins.inspector.DescriptorMapping; import com.facebook.flipper.plugins.inspector.InspectorFlipperPlugin; import com.facebook.flipper.plugins.litho.LithoFlipperDescriptors; // Instead of hard-coding this setting, it's a good practice to tie // this to a BuildConfig flag, that you only enable for debug builds // of your application. ComponentsConfiguration.isDebugModeEnabled = true; final DescriptorMapping descriptorMapping = DescriptorMapping.withDefaults(); // This adds Litho capabilities to the layout inspector. LithoFlipperDescriptors.add(descriptorMapping); client.addPlugin(new InspectorFlipperPlugin(mApplicationContext, descriptorMapping));  ","version":"Next","tagName":"h3"},{"title":"Blocking fullscreen views (Android only)​","type":1,"pageTitle":"Layout Plugin Setup","url":"/docs/setup/plugins/inspector/#blocking-fullscreen-views-android-only","content":"There is an issue that if you have a view that occupies a big part of the screen but draws nothing, and its Z-position is higher than your main content, then selecting view/component through the Layout Inspector doesn't function as you intended. This is because it always hits that transparent view, therefore, you need to manually navigate to the view you need: this is time-consuming and should not be necessary. Add the following tag to your view to skip it from Flipper's view picker. The view is still shown in the layout hierarchy but is selected while using the view picker: view.setTag(R.id.flipper_skip_view_traversal, true);  ","version":"Next","tagName":"h3"},{"title":"Blocking empty view groups (Android only)​","type":1,"pageTitle":"Layout Plugin Setup","url":"/docs/setup/plugins/inspector/#blocking-empty-view-groups-android-only","content":"If you have a ViewGroup that only occasionally has visible children, you may find it helpful to block its traversal when it's empty or has no visible children. For example, you might have a FragmentContainerView that currently has no visible fragment. Add the following tag to your view group to skip it from Flipper's view picker only when it has zero children, or none of its children are currently visible. The views will still be shown in the layout hierarchy, but they will not be selected while using the view picker. viewGroup.setTag(R.id.flipper_skip_empty_view_group_traversal, true);  ","version":"Next","tagName":"h3"},{"title":"iOS​","type":1,"pageTitle":"Layout Plugin Setup","url":"/docs/setup/plugins/inspector/#ios","content":"","version":"Next","tagName":"h2"},{"title":"Standard UIView Only​","type":1,"pageTitle":"Layout Plugin Setup","url":"/docs/setup/plugins/inspector/#standard-uiview-only","content":"To debug layout using Flipper, add the following pod: pod 'FlipperKit/FlipperKitLayoutPlugin', '~&gt;' + flipperkit_version  Once you have added the pod, initialise the plugin and add it to the FlipperClient as follows. iOSSwift #import &lt;FlipperKitLayoutPlugin/FlipperKitLayoutPlugin.h&gt; SKDescriptorMapper *mapper = [[SKDescriptorMapper alloc] initWithDefaults]; [client addPlugin:[[FlipperKitLayoutPlugin alloc] initWithRootNode:context.application withDescriptorMapper:mapper]];  ","version":"Next","tagName":"h3"},{"title":"With ComponentKit Support​","type":1,"pageTitle":"Layout Plugin Setup","url":"/docs/setup/plugins/inspector/#with-componentkit-support","content":"If you want to enable ComponentKit support in the Layout Inspector, you need to add FlipperKit/FlipperKitLayoutComponentKitSupport to your Podfile: pod 'FlipperKit/FlipperKitLayoutComponentKitSupport', '~&gt;' + flipperkit_version  Once you have added the pod you will then need to augment the descriptor with Componentkit-specific settings as shown below. iOSSwift #import &lt;FlipperKitLayoutPlugin/FlipperKitLayoutPlugin.h&gt; #import &lt;FlipperKitLayoutComponentKitSupport/FlipperKitLayoutComponentKitSupport.h&gt; SKDescriptorMapper *layoutDescriptorMapper = [[SKDescriptorMapper alloc] initWithDefaults]; [FlipperKitLayoutComponentKitSupport setUpWithDescriptorMapper: layoutDescriptorMapper]; [client addPlugin: [[FlipperKitLayoutPlugin alloc] initWithRootNode: application withDescriptorMapper: layoutDescriptorMapper]];  ","version":"Next","tagName":"h3"},{"title":"Shared Preferences Viewer Plugin Setup","type":0,"sectionRef":"#","url":"/docs/setup/plugins/preferences/","content":"","keywords":"","version":"Next"},{"title":"Android​","type":1,"pageTitle":"Shared Preferences Viewer Plugin Setup","url":"/docs/setup/plugins/preferences/#android","content":"import com.facebook.flipper.plugins.sharedpreferences.SharedPreferencesFlipperPlugin; client.addPlugin( new SharedPreferencesFlipperPlugin(context, &quot;my_shared_preference_file&quot;));  ","version":"Next","tagName":"h2"},{"title":"iOS​","type":1,"pageTitle":"Shared Preferences Viewer Plugin Setup","url":"/docs/setup/plugins/preferences/#ios","content":"If you want to use the Shared Preferences plugin, you need to add FlipperKit/FlipperKitUserDefaultsPlugin to your Podfile. pod 'FlipperKit/FlipperKitUserDefaultsPlugin', '~&gt;' + flipperkit_version  Initialize the plugin in the following way: iOSSwift #import &lt;FlipperKitUserDefaultsPlugin/FKUserDefaultsPlugin.h&gt; [client addPlugin:[[FKUserDefaultsPlugin alloc] initWithSuiteName:@&quot;your_suitename&quot;]];  ","version":"Next","tagName":"h2"},{"title":"Network Plugin Setup","type":0,"sectionRef":"#","url":"/docs/setup/plugins/network/","content":"","keywords":"","version":"Next"},{"title":"Android​","type":1,"pageTitle":"Network Plugin Setup","url":"/docs/setup/plugins/network/#android","content":"The network plugin is shipped as a separate Maven artifact, as follows: dependencies { debugImplementation 'com.facebook.flipper:flipper-network-plugin:0.245.0' }  Once added to your dependencies, you can instantiate the plugin and add it to the client: import com.facebook.flipper.plugins.network.NetworkFlipperPlugin; NetworkFlipperPlugin networkFlipperPlugin = new NetworkFlipperPlugin(); new NetworkingModule.CustomClientBuilder() { @Override public void apply(OkHttpClient.Builder builder) { builder.addNetworkInterceptor(new FlipperOkhttpInterceptor(networkFlipperPlugin)); } }); client.addPlugin(networkFlipperPlugin);  ","version":"Next","tagName":"h2"},{"title":"OkHttp Integration​","type":1,"pageTitle":"Network Plugin Setup","url":"/docs/setup/plugins/network/#okhttp-integration","content":"If you are using the popular OkHttp library, you can use the Interceptors system to automatically hook into your existing stack, as shown in the following snippet: import com.facebook.flipper.plugins.network.FlipperOkhttpInterceptor; new OkHttpClient.Builder() .addNetworkInterceptor(new FlipperOkhttpInterceptor(networkFlipperPlugin)) .build();  As interceptors can modify the request and response, add the Flipper interceptor after all others to get an accurate view of the network traffic. ","version":"Next","tagName":"h3"},{"title":"Protobuf / Retrofit Integration​","type":1,"pageTitle":"Network Plugin Setup","url":"/docs/setup/plugins/network/#protobuf--retrofit-integration","content":"If you are using Retrofit with Protobuf request or response types, you can setup automatic decoding so that the network inspector can display a human readable payload. First you must add the separate dependency: dependencies { debugImplementation 'com.facebook.flipper:flipper-retrofit2-protobuf-plugin:0.91.2' }  Then call SendProtobufToFlipperFromRetrofit for each service class: import com.facebook.flipper.plugins.retrofit2protobuf.SendProtobufToFlipperFromRetrofit SendProtobufToFlipperFromRetrofit(&quot;https://baseurl.com/&quot;, MyApiService::class.java)  ","version":"Next","tagName":"h3"},{"title":"iOS​","type":1,"pageTitle":"Network Plugin Setup","url":"/docs/setup/plugins/network/#ios","content":"To enable network inspection, add the following pod to your Podfile: pod 'FlipperKit/SKIOSNetworkPlugin', '~&gt;' + flipperkit_version  Initialize the plugin in the following way by updating AppDelegate.m: ObjCSwift #import &lt;FlipperKitNetworkPlugin/FlipperKitNetworkPlugin.h&gt; [[FlipperClient sharedClient] addPlugin: [[FlipperKitNetworkPlugin alloc] initWithNetworkAdapter:[SKIOSNetworkAdapter new]]];  ","version":"Next","tagName":"h2"},{"title":"Protobuf + Retrofit Setup​","type":1,"pageTitle":"Network Plugin Setup","url":"/docs/setup/plugins/network/#protobuf--retrofit-setup","content":"","version":"Next","tagName":"h2"},{"title":"Gradle Dependencies​","type":1,"pageTitle":"Network Plugin Setup","url":"/docs/setup/plugins/network/#gradle-dependencies","content":"Ensure that you already have an explicit dependency in your application's build.gradle including the plugin dependency, as shown in the following example: dependencies { implementation &quot;com.squareup.retrofit2:retrofit:2.9.0&quot; implementation &quot;com.squareup.retrofit2:converter-protobuf:2.9.0&quot; // update version below to match latest Flipper client app debugImplementation &quot;com.facebook.flipper:flipper-retrofit2-protobuf-plugin:0.84.0&quot; }  ","version":"Next","tagName":"h3"},{"title":"Sending Retrofit Service​","type":1,"pageTitle":"Network Plugin Setup","url":"/docs/setup/plugins/network/#sending-retrofit-service","content":"If you have a Retrofit service interface PersonService which has Protobuf body or return types then at the time you create your implementation, call the plugin with your baseURL and service class, as follows: import com.facebook.flipper.plugins.retrofit2protobuf.SendProtobufToFlipperFromRetrofit ... val personService = retrofit.create(PersonService::class.java) SendProtobufToFlipperFromRetrofit(baseUrl, PersonService::class.java)  ","version":"Next","tagName":"h3"},{"title":"Navigation Plugin Setup","type":0,"sectionRef":"#","url":"/docs/setup/plugins/navigation/","content":"","keywords":"","version":"Next"},{"title":"Android​","type":1,"pageTitle":"Navigation Plugin Setup","url":"/docs/setup/plugins/navigation/#android","content":"First, add the Navigation plugin to your Flipper client instance: import com.facebook.flipper.android.AndroidFlipperClient; import com.facebook.flipper.plugins.navigation.NavigationFlipperPlugin; final FlipperClient client = AndroidFlipperClient.getInstance(this); client.addPlugin(NavigationFlipperPlugin.getInstance());  Navigation events in the app can then be recorded by calling sendNavigationEvent method of the NavigationFlipperPlugin instance from anywhere in the app. This enables the Navigation Plugin to be integrated into existing navigation frameworks. ","version":"Next","tagName":"h2"},{"title":"Using Android deep links​","type":1,"pageTitle":"Navigation Plugin Setup","url":"/docs/setup/plugins/navigation/#using-android-deep-links","content":"The Navigation Plugin can be used with built-in Deep Links for Android. To deep link to an activity, edit the AndroidManifest.xml and add the intent filter for the given activity, as follows: &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt; &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt; &lt;data android:scheme=&quot;flipper&quot; android:host=&quot;deep_link_activity&quot; /&gt; &lt;/intent-filter&gt;  This enables the user to jump to flipper://deep_link_activity within Flipper. To log that navigation event in flipper, you can send the navigation event in the Activity's onCreate method, as follows: public class DeepLinkActivity extends AppCompatActivity { @Override protected void onCreate(final Bundle savedInstanceState) { super.onCreate(savedInstanceState); NavigationFlipperPlugin.getInstance().sendNavigationEvent(&quot;flipper://deep_link_activity/&quot;); ...  ","version":"Next","tagName":"h3"},{"title":"Third party solutions​","type":1,"pageTitle":"Navigation Plugin Setup","url":"/docs/setup/plugins/navigation/#third-party-solutions","content":"The Navigation Plugin can easily be integrated into a third-party navigation framework. AirBnB deep link dispatch​ DeepLinkDispatch will work out of the box with Flipper for navigating to links, including support for url parameters. To add logging, simply add a BroadcastReceiver to your app that is called on any incoming deep links: public class DeepLinkReceiver extends BroadcastReceiver { private static final String TAG = &quot;DeepLinkReceiver&quot;; @Override public void onReceive(Context context, Intent intent) { String deepLinkUri = intent.getStringExtra(DeepLinkHandler.EXTRA_URI); if (intent.getBooleanExtra(DeepLinkHandler.EXTRA_SUCCESSFUL, false)) { NavigationFlipperPlugin.getInstance().sendNavigationEvent(deepLinkUri); } } } public class DeepLinkApplication extends Application { @Override public void onCreate() { super.onCreate(); IntentFilter intentFilter = new IntentFilter(DeepLinkHandler.ACTION); LocalBroadcastManager.getInstance(this).registerReceiver(new DeepLinkReceiver(), intentFilter); } }  ","version":"Next","tagName":"h3"},{"title":"Sandbox Plugin Setup","type":0,"sectionRef":"#","url":"/docs/setup/plugins/sandbox/","content":"","keywords":"","version":"Next"},{"title":"Android​","type":1,"pageTitle":"Sandbox Plugin Setup","url":"/docs/setup/plugins/sandbox/#android","content":"import com.facebook.flipper.plugins.sandbox.SandboxFlipperPlugin; import com.facebook.flipper.plugins.sandbox.SandboxFlipperPluginStrategy; final SandboxFlipperPluginStrategy strategy = getStrategy(); // Your strategy goes here client.addPlugin(new SandboxFlipperPlugin(strategy));  ","version":"Next","tagName":"h2"},{"title":"Stetho Guidance","type":0,"sectionRef":"#","url":"/docs/stetho/","content":"Stetho Guidance In 2015, Facebook (now Meta) introduced Stetho, an Android debugging bridge built on top of Chrome DevTools. While it was a valuable tool to members of the community, it was felt that it was limited in what could be achieved with it. Stetho is Android-only and while Chrome DevTools (which was built for Web Developers) provides a nice foundation to build upon, their capability was also limited. Flipper has been built as a standalone app that provides functionality such as handling adb connections and supporting iOS, which weren't easily achievable with Stetho. Flipper has been built to create a platform that provides all the flexibility needed to build more advanced features and support for iOS. One of Flipper's core concepts is its extensibility using plugins. Plugins are written in React and provide a set of ready-to-use UI components that allow Developers to build great plugin UIs with a few lines of code. While offering many new features, Flipper also already covers most of the features provided by Stetho, such network and layout inspection and an advanced log viewer. Meta is committed to continuously improving Flipper with new features and plugins. Meta is aware that not all Stetho features are currently supported by Flipper. If you are using a particular feature of Stetho which isn't supported by Flipper, please post details of your use case in the Flipper Support Workplace group. Meta is confident that Flipper will work well for most use cases and are more than happy to accept contributions from the open-source community. Stetho will continue to be used, enabling you to choose the tool that fits your needs best.","keywords":"","version":"Next"},{"title":"Introduction","type":0,"sectionRef":"#","url":"/docs/tutorial/intro/","content":"Introduction Flipper was designed with extensibility in mind to enable Engineers to quickly build quality, easy-to-use tools for their own needs and applications. In addition to building plugins for the existing platforms, you can also extend the capabilities of Flipper to other platforms by conforming to the FlipperClient API. After this, you can make use of the existing desktop plugins by writing client plugins that conform to the same API. In this tutorial, you'll learn how easy it is to build a Flipper plugin for Android and iOS that extracts data from your native application and displays it in a desktop app. You'll then be guided through the process of converting a basic table plugin into a full plugin with custom UI components. At the end of the tutorial, you'll have created a plugin that looks like the following screenshot example. Before you get started, here are two terms you'll see frequently throughout this tutorial: Desktop app - Web Application and underlying Flipper runtime which you run on your desktop.Mobile client - mobile app running most likely on a phone or other mobile device: it connects to the desktop app.","keywords":"","version":"Next"},{"title":"Building an Android Plugin","type":0,"sectionRef":"#","url":"/docs/tutorial/android/","content":"","keywords":"","version":"Next"},{"title":"Creating a Plugin​","type":1,"pageTitle":"Building an Android Plugin","url":"/docs/tutorial/android/#creating-a-plugin","content":"On Android, a Flipper plugin is a class that implements the FlipperPlugininterface. The interface consists of the following four methods: getId() -&gt; String - specify a unique string so the JavaScript side knows where to talk to. This must match the name attribute in the package.json, which is examined later in this tutorial.onConnect(FlipperConnection) - this method is called when the desktop app connects to the mobile client and is ready to receive or send data.onDisconnect() - sets the connection to nil.runInBackground() -&gt; Boolean - unless this is true, only the currently selected plugin in the Flipper UI can communicate with the device. The following code shows the implementation of these methods for the Sea-mammals app: import com.facebook.flipper.core.FlipperConnection import com.facebook.flipper.core.FlipperObject import com.facebook.flipper.core.FlipperPlugin import com.facebook.flipper.sample.tutorial.MarineMammals class SeaMammalFlipperPlugin : FlipperPlugin { private var connection: FlipperConnection? = null override fun getId(): String = &quot;sea-mammals&quot; override fun onConnect(connection: FlipperConnection?) { this.connection = connection MarineMammals.list.mapIndexed { index, (title, picture_url) -&gt; FlipperObject.Builder() .put(&quot;id&quot;, index) .put(&quot;title&quot;, title) .put(&quot;url&quot;, picture_url).build() }.forEach(this::newRow) } override fun onDisconnect() { connection = null } override fun runInBackground(): Boolean = false private fun newRow(row: FlipperObject) { connection?.send(&quot;newRow&quot;, row) } }  See SeaMammalFlipperPlugin.kt The two interesting items here are onConnect and newRow, which sends a message to the desktop app and is identified with the same name 'newRow'. For the sea-mammals app, there is a static data source. However, in real life, you'll likely dynamically receive new data as the user interacts with the app. So, while in the Sea-mammals app, the data is sent all at once with onConnect, in real life, you'd set up a listener to call newRow as new data arrives. You may have notices that rather than sending random Objects over the wire, FlipperObjects are used. A FlipperObject works similar to a JSON dictionary and has a limited set of supported types like strings, integers and arrays. note Before sending an object from your native app to the desktop, you first need to break it down into FlipperObject-serializable parts. ","version":"Next","tagName":"h2"},{"title":"Registering your plugin​","type":1,"pageTitle":"Building an Android Plugin","url":"/docs/tutorial/android/#registering-your-plugin","content":"Now, all you need to do is let Flipper know about your new plugin. You do this by calling addPlugin on your FlipperClient, which is normally created at application startup. val flipperClient = AndroidFlipperClient.getInstance(this) // Add all sorts of other amazing plugins here ... flipperClient.addPlugin(SeaMammalFlipperPlugin()) flipperClient.start()  See TutorialApplication.kt ","version":"Next","tagName":"h2"},{"title":"Next step​","type":1,"pageTitle":"Building an Android Plugin","url":"/docs/tutorial/android/#next-step","content":"When starting your application, Flipper tells the desktop application about the plugin it supports (including 'Sea-mammals') and looks for a corresponding JavaScript plugin by that name. ","version":"Next","tagName":"h2"},{"title":"Building an iOS Plugin","type":0,"sectionRef":"#","url":"/docs/tutorial/ios/","content":"","keywords":"","version":"Next"},{"title":"Creating a plugin​","type":1,"pageTitle":"Building an iOS Plugin","url":"/docs/tutorial/ios/#creating-a-plugin","content":"On iOS, a Flipper plugin is a class that implements the FlipperPlugin interface. The interface consists of four methods: (NSString *)identifier - specify a unique string so the JavaScript side knows where to talk to. This must match the name attribute in the package.json, which is examined later in the tutorial.(void)didConnect:(id&lt;FlipperConnection&gt;)connection - this method is called when the desktop client connects and is ready to receive or send data.(void)didDisconnect - sets connection to nil.(BOOL)runInBackground - unless this is true, only the currently selected plugin in the Flipper UI can communicate with the device. Its an optional method which you can override. The default value used is false. The following code shows the implementation of these methods for the Sea-mammals app: import Foundation import FlipperKit class SeaMammalsPlugin: NSObject, FlipperPlugin { var connection: FlipperConnection? = nil let mammals: [MarineMammal] init(_ marineMammals: [MarineMammal]) { mammals = marineMammals } func identifier() -&gt; String! { return &quot;Sea-mammals&quot; } func didConnect(_ connection: FlipperConnection!) { self.connection = connection for (index, mammal) in mammals.enumerated() { connection.send(&quot;newRow&quot;, withParams: [&quot;id&quot;: index, &quot;title&quot;: mammal.name, &quot;url&quot;: mammal.image.absoluteString]) } } func didDisconnect() { connection = nil; } }  There are two items of interest here: didConnect and connection.send, which sends a message to the desktop app and is identified with the name newRow. For the Sea-mammals app, there is a static data source. However, in real life, you'll likely dynamically receive new data as the user interacts with the app. So, while in the Sea-mammals app, the data is sent all at once with didConnect, in real life, you'd set up a listener to call connection.send(&quot;newRow&quot;, params) as the dynamic data arrives. note In the above code, the withParams are just dictionary that contains the data that Sea-mammals sends over the wire to the desktop app. ","version":"Next","tagName":"h2"},{"title":"Registering your plugin​","type":1,"pageTitle":"Building an iOS Plugin","url":"/docs/tutorial/ios/#registering-your-plugin","content":"Now all you need to do is let Flipper know about your new plugin. You do this by calling add on your FlipperClient, which is normally created at application startup: let client = FlipperClient.shared() // Add all sorts of other amazing plugins here ... client?.add(SeaMammalsPlugin(MarineMammal.defaultList)) client?.start()  ","version":"Next","tagName":"h2"},{"title":"What next?​","type":1,"pageTitle":"Building an iOS Plugin","url":"/docs/tutorial/ios/#what-next","content":"When starting your application, Flipper tells the desktop application about the plugin it supports (including 'Sea-mammals') and looks for a corresponding JavaScript plugin by the same name. ","version":"Next","tagName":"h2"},{"title":"Building a JavaScript (Browser) Plugin","type":0,"sectionRef":"#","url":"/docs/tutorial/javascript/","content":"","keywords":"","version":"Next"},{"title":"Step 1 - install Flipper JavaScript SDK​","type":1,"pageTitle":"Building a JavaScript (Browser) Plugin","url":"/docs/tutorial/javascript/#step-1---install-flipper-javascript-sdk","content":"Add the Flipper client to your web application. Run npm install js-flipper (yarn add js-flipper) ","version":"Next","tagName":"h2"},{"title":"Step 2 - start the Flipper client​","type":1,"pageTitle":"Building a JavaScript (Browser) Plugin","url":"/docs/tutorial/javascript/#step-2---start-the-flipper-client","content":"danger Do not start the Flipper client in production! Preferably, do not even include Flipper in your production builds! Use the following to start the Flipper client: // We want to import and start flipper client only in development and test modes let flipperClientPromise: Promise&lt;FlipperClient&gt; | undefined; if (process.env.NODE_ENV !== 'production') { flipperClientPromise = import('js-flipper').then(({flipperClient}) =&gt; { flipperClient.start('React Tic-Tac-Toe'); return flipperClient; }); }  ","version":"Next","tagName":"h2"},{"title":"Step 3 - call addPlugin to add your plugin​","type":1,"pageTitle":"Building a JavaScript (Browser) Plugin","url":"/docs/tutorial/javascript/#step-3---call-addplugin-to-add-your-plugin","content":"To register a new plugin with Flipper, call flipperClient.addPlugin and pass your plugin as an object. Your plugin must conform to the following interface: export interface FlipperPlugin { /** * @return The id of this plugin. This is the namespace which Flipper desktop plugins will call * methods on to route them to your plugin. This should match the id specified in your React * plugin. */ getId(): string; /** * Called when a connection has been established. The connection passed to this method is valid * until {@link FlipperPlugin#onDisconnect()} is called. */ onConnect(connection: FlipperPluginConnection): void; /** * Called when the connection passed to `FlipperPlugin#onConnect(FlipperConnection)` is no * longer valid. Do not try to use the connection in or after this method has been called. */ onDisconnect(): void; /** * Returns true if the plugin is meant to be run in background too, otherwise it returns false. */ runInBackground?(): boolean; }  The onConnect and onDisconnect events, featured in the above snippet, are triggered every time the plugin becomes (in)active in the Flipper desktop application. If the plugin is a background plugin, these events are triggered typically only once (they might be triggered never if the Desktop user didn't enable the plugin, or multiple times if they enabled or disabled the plugin a few times). The onConnect callback receive a connection which can be used to communicate with the backend: // TicTacToe game status const [status, setStatus] = useState('Waiting for Flipper Desktop Player...'); // TicTacToe game state const [gameState, setGameState] = useState&lt;GameState&gt;({ cells: [], turn: ' ', winner: ' ', }); // Flipper connection instance const [connection, setConnection] = useState&lt;FlipperPluginConnection&gt;(); useEffect(() =&gt; { flipperClientPromise?.then(flipperClient =&gt; { flipperClient.addPlugin({ getId() { // Name of the plugin return 'ReactNativeTicTacToe'; }, onConnect(connection) { // Once we connected, we display it to the user setStatus('Desktop player present'); // And stash the connection object setConnection(connection); // We start listening to updates from Flipper Desktop connection.receive('SetState', (gameState: GameState) =&gt; { if (gameState.winner !== ' ') { setStatus( `Winner is ${gameState.winner}! Waiting for a new game...`, ); } else { setStatus( gameState.turn === 'X' ? 'Your turn...' : 'Awaiting desktop players turn...', ); } setGameState(gameState); }); // We also request the initial state of the game from Flipper Desktop connection.send('GetState'); }, onDisconnect() { // When Flipper Desktop disconnects, we show it to the user setConnection(undefined); setStatus('Desktop player gone...'); }, }); }); }, []);  You might want to store the connection somewhere to be able to send more events as long as onDisconnect event hasn't been fired. The connection object can also be used to listen to messages coming from the Desktop plugin. See Client Plugin API for details. ","version":"Next","tagName":"h2"},{"title":"Live demo​","type":1,"pageTitle":"Building a JavaScript (Browser) Plugin","url":"/docs/tutorial/javascript/#live-demo","content":"An example plugin to play a little Tic-Tac-Toe between the Flipper Desktop and a React app can be found inside this repository as well (run yarn &amp;&amp; yarn start in js/react-flipper-example to start the test project): The React plugin implementation - FlipperTicTacToe.tsxThe Flipper Desktop plugin implementation - rn-tic-tac-toe/index.tsx ","version":"Next","tagName":"h2"},{"title":"Building a Desktop Plugin - Setup","type":0,"sectionRef":"#","url":"/docs/tutorial/js-setup/","content":"","keywords":"","version":"Next"},{"title":"Scaffolding a new Desktop plugin​","type":1,"pageTitle":"Building a Desktop Plugin - Setup","url":"/docs/tutorial/js-setup/#scaffolding-a-new-desktop-plugin","content":"A new Flipper Desktop plugin can be scaffolded by running npx flipper-pkg init in the directory where you want to store the plugin sources. danger Don't run this command inside the Flipper repository!. Before running this command, make sure Flipper is closed. The following snippet shows an example: mkdir ~/FlipperPlugins cd ~/FlipperPlugins npx flipper-pkg init  Add the directory (shown in the snippet) to the Flipper watch folder if asked. In this tutorial, you'll be creating a client plugin. device plugins are only used when creating plugins that don't connect to a specific application. Take the following steps for npx: The npx tool asks you to provide the 'id' and 'title' for your plugin. For the sake of this tutorial, use 'sea-mammals' as 'id' and 'Sea Mammals' as the 'title'.The npx tool creates two files in the directory: package.json and src/index.tsx.After the process has finished, use yarn watch in the generated directory to start compiling the plugin on the fly. Now that the package has been set up, you are ready to build a UI for your plugin. This can be achieved either by using a standardized table-based plugin, or by creating a custom UI. For more background on the generated files and overall plugin structure, see the Plugin Structure page. ","version":"Next","tagName":"h2"},{"title":"Marketplace","type":0,"sectionRef":"#","url":"/docs/tutorial/marketplace/","content":"","keywords":"","version":"Next"},{"title":"Plugin discovery​","type":1,"pageTitle":"Marketplace","url":"/docs/tutorial/marketplace/#plugin-discovery","content":"Plugins which are supported by currently connected app/device, will be listed under &quot;Detected in app&quot; section in sidebar. This significantly help users to discover useful plugins for their app.  ","version":"Next","tagName":"h3"},{"title":"Plugin auto-update​","type":1,"pageTitle":"Marketplace","url":"/docs/tutorial/marketplace/#plugin-auto-update","content":"Once plugin is installed, it will also keep updating to latest version. ","version":"Next","tagName":"h3"},{"title":"Enable markektplace​","type":1,"pageTitle":"Marketplace","url":"/docs/tutorial/marketplace/#enable-markektplace","content":"","version":"Next","tagName":"h2"},{"title":"Setup server​","type":1,"pageTitle":"Marketplace","url":"/docs/tutorial/marketplace/#setup-server","content":"Instead of hosting plugins on npm server, we need to provide custom server, which will provide a list of internal plugins. It is recommended to connect this server with internal package registry (to allow providing latest version). Here is a example implementation of server using Verdaccio as package registry: marketplace-server-example. ","version":"Next","tagName":"h3"},{"title":"Enable marketplace​","type":1,"pageTitle":"Marketplace","url":"/docs/tutorial/marketplace/#enable-marketplace","content":"Open Flipper settings and enter the URL to your Flipper marketplace server. It is also adviced to toggle ON the Enable auto update.  ","version":"Next","tagName":"h3"},{"title":"Publishing Your Plugin","type":0,"sectionRef":"#","url":"/docs/tutorial/js-publishing/","content":"","keywords":"","version":"Next"},{"title":"Installing Plugins​","type":1,"pageTitle":"Publishing Your Plugin","url":"/docs/tutorial/js-publishing/#installing-plugins","content":"Once your plugin is published you can find it, alongside other available Flipper plugins, by clicking on 'Manage Plugins...' in the bottom of the left sidebar and selecting the 'Install Plugins' tab. It may take a few moments for the search index to update and your plugin to appear.  ","version":"Next","tagName":"h2"},{"title":"Native Distribution​","type":1,"pageTitle":"Publishing Your Plugin","url":"/docs/tutorial/js-publishing/#native-distribution","content":"Depending on whether the client-side part of your plugin targets Android, iOS or React Native, it's recommended you use the standard package distribution mechanism for the platform. This may be Maven Central, JCenter or GitHub Packages for Android, CocoaPods for iOS and npm or GitHub Packages for React Native. Make sure to leave setup instructions in the README of your npm package. ","version":"Next","tagName":"h2"},{"title":"Marketplace​","type":1,"pageTitle":"Publishing Your Plugin","url":"/docs/tutorial/js-publishing/#marketplace","content":"When developing plugins intended only for internal use (within certaing organisation/group), we might not want to expose those plugins to public. By default Flipper plugins will be published to npmjs.com. Thus anyone can try install&amp;use this plugin. To keep plugin private, we can provide a .tar.gz archive with pluginc code and user can manually install the plugin. This is quite troublesome for most users and also does not provide a way to automatically update when new version is released. Flipper provides a marketplace feature, which does help with discovery of plugins within organisation and also keeps the plugins private. To read more details on how marketplace works and how it can be integrated, please read this document: Marketplace. ","version":"Next","tagName":"h2"},{"title":"Building a Desktop Plugin - Showing a Table","type":0,"sectionRef":"#","url":"/docs/tutorial/js-table/","content":"","keywords":"","version":"Next"},{"title":"Building a Table​","type":1,"pageTitle":"Building a Desktop Plugin - Showing a Table","url":"/docs/tutorial/js-table/#building-a-table","content":"One of the best ways to understand how your app works is to get access to its underlying data, which are used to display items on screen. An efficient way of achieving this is by showing the data in a table. The data for Sea-mammals has been optimized for easy display in a table, which you can sort, filter and select items for more detailed information.  In this section of the tutorial, you'll be editing the index.tsx file that was generated in the previous scaffolding step. ","version":"Next","tagName":"h2"},{"title":"Row Types​","type":1,"pageTitle":"Building a Desktop Plugin - Showing a Table","url":"/docs/tutorial/js-table/#row-types","content":"Start off by defining what your table rows look like: type Row = { id: number, title: string, url: string, };  note It's important that you have some unique identifier for every row so that you know when something new was added to the table; the 'id' field is sufficient ","version":"Next","tagName":"h3"},{"title":"Columns​","type":1,"pageTitle":"Building a Desktop Plugin - Showing a Table","url":"/docs/tutorial/js-table/#columns","content":"Define which columns to show and how to display them: import {DataTableColumn} from 'flipper-plugin'; const columns: DataTableColumn&lt;Row&gt;[] = [ { key: 'title', width: 150, }, { key: 'url', title: 'URL', }, ];  The keys used here will show up again in the next step when building your rows, so keep them consistent. The title defined for each column will show up as the header at the top of the table and will be default to the key value if omitted. For the width, you can either choose a fixed number (pixels), a percentage, or leave it out to distribute the remaining available space. ","version":"Next","tagName":"h3"},{"title":"Configuring the table​","type":1,"pageTitle":"Building a Desktop Plugin - Showing a Table","url":"/docs/tutorial/js-table/#configuring-the-table","content":"You now have a Row type that describes the data you'll be storing and a description of the columns to display. With these components it's a trivial task to get a table showing data, including search / sort and a details view, as shown in the following code snippet: import {DataTableColumn, createTablePlugin} from 'flipper-plugin'; const {plugin, Component} = createTablePlugin&lt;Row&gt;({ columns, method: 'newRow', key: 'id', }); export {plugin, Component};  The above code snippet has the following properties: method - refers to the method that should be listened to to fill the table with data.'newRow' - refers back to the identifier used with connection.send to send the data to the Flipper desktop application in the previous step.key - [optional] - but by setting this property, the 'id' field is used as an identifier. As a result, once a newRow message arrives with an existing id, it will overwrite the old entry, rather than appending a new one. The createTablePlugin API supports more options, which are documented in the Dektop Plugin API page. And that's all there is to it! Starting Flipper will now compile your plugin and connect to the native side. It's a good idea to start Flipper from the command line to see any potential errors. The console in the DevTools is a great source of information if something doesn't work as expected, too. The final result of this step can be seen at index_table.tsx. ","version":"Next","tagName":"h3"},{"title":"What next?​","type":1,"pageTitle":"Building a Desktop Plugin - Showing a Table","url":"/docs/tutorial/js-table/#what-next","content":"You now have an interactive table that you can sort, filter and use to get additional information about the data you see on screen. The createTablePlugin is a high-level abstraction that takes care of both connection management and a standardized UI for the most common scenario. For many cases, this is all you need. However, sometimes you may want to build something a bit more custom, which is covered in the Desktop Plugin - Custom UI page ","version":"Next","tagName":"h2"},{"title":"Building a React Native Plugin","type":0,"sectionRef":"#","url":"/docs/tutorial/react-native/","content":"Building a React Native Plugin caution This section of the tutorial requires React Native 0.62 or higher. Once you've connected Flipper to a React Native application, writing your own Flipper plugin can be done without reaching into the native world. To expose Flipper to the JavaScript world, the React Native module react-native-flipper needs to be installed in the hosting application by running yarn add react-native-flipper and cd ios &amp;&amp; pod install. If you are developing a plugin that is distributed as NPM package, make sure to add this to the installation instruction of your package as well! Registering a new plugin is done by importing addPlugin from react-native-flipper and providing it an object that at least implements the method getId (the plugin id that should be used in the desktop plugin as well to make the connection) and two event handlers for the onConnect and onDisconnect events. The onConnect and onDisconnect events are triggered every time the plugin becomes (in)active in the Flipper desktop application. If the plugin is a background plugin, the events are triggered typically only once (they might be triggered never, if the Desktop user didn't enable the plugin, or multiple times if they enabled or disabled the plugin a few times). The onConnect callback receive a connection which can be used to communicate with the backend: import {addPlugin} from &quot;react-native-flipper&quot; addPlugin({ getId() { return 'ReactNativeExamplePlugin'; }, onConnect(connection) { mammmals.forEach(({ title, pictureUrl }, index) =&gt; { connection.send('newRow', { id: index, title, url: pictureUrl }) }) }, onDisconnect() { } }) You may want to store the connection somewhere to be able to send more events as long as onDisconnect event hasn't been fired. The connection object can also be used to listen to messages coming from the Desktop plugin. See Client Plugin API for details. An example plugin to play a little Tic-Tac-Toe between the Flipper Desktop and a React Native app can be found inside this repository as well (run yarn &amp;&amp; yarn android in react-native/ReactNativeFlipperExample to start the test project): The React Native JavaScript based plugin implementation - FlipperTicTacToe.jsThe Flipper Desktop plugin implementation - rn-tic-tac-toe/index.tsx","keywords":"","version":"Next"},{"title":"Building A Desktop Plugin - Custom UI","type":0,"sectionRef":"#","url":"/docs/tutorial/js-custom/","content":"","keywords":"","version":"Next"},{"title":"Replacing the table​","type":1,"pageTitle":"Building A Desktop Plugin - Custom UI","url":"/docs/tutorial/js-custom/#replacing-the-table","content":"In the following scenario, instead of just listing the mammals as image URLs (as shown in Desktop Plugin - Table page), the images are rendered inside little cards, as shown in the following screenshots.  When any of the cards is selected, the relevant mammal's details are displayed in the sidebar. ","version":"Next","tagName":"h2"},{"title":"Overview of the steps to create a Custom UI​","type":1,"pageTitle":"Building A Desktop Plugin - Custom UI","url":"/docs/tutorial/js-custom/#overview-of-the-steps-to-create-a-custom-ui","content":"The following steps provide an overview of the differences between creating a standard Table UI and a Custom UI. For a standard Table, the default export in index.tsx is from createTablePlugin. For a Custom UI, this is replaced with a custom React component by using the more flexible APIs exposed by the flipper-plugin.Replace the usual createTablePlugin (for a Table UI) with both a plugin definition and a Component definition which is used for rendering. Separating those two concepts helps with testing and maintaining state when the user switches plugins. ","version":"Next","tagName":"h2"},{"title":"Example Custom UI​","type":1,"pageTitle":"Building A Desktop Plugin - Custom UI","url":"/docs/tutorial/js-custom/#example-custom-ui","content":"note The code for the example custom UI (shown below) contains numbered comments (such as '// (1)'), which are referenced in the following sections. import React from 'react'; import {PluginClient, createState} from 'flipper-plugin'; // (3) type Row = { id: number; title: string; url: string; }; // (2) type Events = { newRow: Row; }; // (1) export function plugin(client: PluginClient&lt;Events, {}&gt;) { // (5) const rows = createState&lt;Record&lt;string, Row&gt;&gt;({}, {persist: 'rows'}); const selectedID = createState&lt;string | null&gt;(null, {persist: 'selection'}); // (6) client.onMessage('newRow', (row) =&gt; { rows.update((draft) =&gt; { draft[row.id] = row; }); }); function setSelection(id: number) { selectedID.set('' + id); } // (4) return { rows, selectedID, setSelection, }; } export function Component() { return &lt;h1&gt;Sea Mammals plugin&lt;/h1&gt;; }  ","version":"Next","tagName":"h2"},{"title":"The plugin declaration​","type":1,"pageTitle":"Building A Desktop Plugin - Custom UI","url":"/docs/tutorial/js-custom/#the-plugin-declaration","content":"Key points regarding the above Example Custom UI code: The implementation of the plugin is driven by the named and exported function plugin, as defined at (1).The plugin method is called upon instantiating the plugin and receives one argument, client, that which provides all APIs needed to both interact with the Flipper desktop and the plugin loaded into the client application.The PluginClient types all available APIs and takes two generic arguments.The first Events describes all possible events that can be sent from the client plugin to the desktop plugin and determines the events available for client.onMessage (see below).In the above code, only one event can occur, newRow, as defined at (2). However, in the real world, there are typically more events.The data provided by this newRow event is described with the Row type, as defined at (3).The event names and data structures should correspond with the data that is sent using connection.send from the client.The plugin function has to return an object that captures the entire API you want to expose from the plugin to your UI components and unit tests. In this case, it returns the state atoms rows and selectedID, and expose the setSelection method ((see (4))). ","version":"Next","tagName":"h2"},{"title":"Writing plugin logic​","type":1,"pageTitle":"Building A Desktop Plugin - Custom UI","url":"/docs/tutorial/js-custom/#writing-plugin-logic","content":"Since the plugin function will execute only once during the entire lifecycle of the plugin, you can use local variables in the function body to preserve state. In the example Custom UI, above, there are two pieces of state (see (5)): The set of rows available, rows.The current selection: selectionID. For larger data collections, it's strongly recommended to leverage the better optimized createDataSource. But, in this tutorial example, createState is sufficient for a small data set. It's possible to store state directly in let declarations, but createState creates a storage container that gives you a few advantages: Most importantly, state created using createState can be subscribed to by the UI components using the useValue hook.State created with createState can be made part of Flipper imports / exports. This feature can be used by providing a unique persist key. The current value of the container can be read using .get(), and .set() or .update() can be used to replace the current value.The client can be used to receive and send information to the client plugin. With client.send, you can invoke methods on the plugin.With client.onMessage (see (6)) you can subscribe to the specific events as specified with the Events type (see (2)). In the event handler, you can update some pieces of state, using the .set method to replace state, or the .update method to immutably update the state using Immer.In the Example Custom UI, the received row is added to the rows state under its own id.Finally, (see (7)), you can create (and expose at (4)) a utility to update the selection, which is used in the Building a User Interface for the plug section, below. note No state should be stored outside the plugin definition; multiple invocations of plugin can be 'alive' if multiple connected apps are using the plugin. Storing the state inside the closure ensures no state is mixed up. ","version":"Next","tagName":"h3"},{"title":"Testing plugin logic​","type":1,"pageTitle":"Building A Desktop Plugin - Custom UI","url":"/docs/tutorial/js-custom/#testing-plugin-logic","content":"note This section features a scenario where unit tests are always written before creating a Custom UI for a plugin. Unit tests will be picked automatically by Jest if they are named like __tests__/*.spec.tsx, so create a file called __tests__/seamammals.spec.tsx and start the test runner by running yarn test --watch in your plugin root. Here is the Initial Unit Test code: // (1) import {TestUtils} from 'flipper-plugin'; // (2) import * as MammalsPlugin from '..'; test('It can store rows', () =&gt; { // (3) const {instance, sendEvent} = TestUtils.startPlugin(MammalsPlugin); expect(instance.rows.get()).toEqual({}); expect(instance.selectedID.get()).toBeNull(); // (4) sendEvent('newRow', { id: 1, title: 'Dolphin', url: 'http://dolphin.png', }); sendEvent('newRow', { id: 2, title: 'Turtle', url: 'http://turtle.png', }); // (5) expect(instance.rows.get()).toMatchInlineSnapshot(` Object { &quot;1&quot;: Object { &quot;id&quot;: 1, &quot;title&quot;: &quot;Dolphin&quot;, &quot;url&quot;: &quot;http://dolphin.png&quot;, }, &quot;2&quot;: Object { &quot;id&quot;: 2, &quot;title&quot;: &quot;Turtle&quot;, &quot;url&quot;: &quot;http://turtle.png&quot;, }, } `); });  note The code for the Initial Unit Test (shown above) contains numbered comments (such as '// (1)'), which are referenced in the following information. Key points regarding the Initial Unit Test code: Testing utilities for plugins are shipped as part of flipper-plugin, so can be imported directly (see (1)).You directly import the above plugin implementation into your unit test.By using as, you put the entire implementation into one object, which is the format in which your utilities expect them ((2)).Using TestUtils.startPlugin ((3)) instantiates the plugin in a fully mocked environment where the plugin can do everything except for actually rendering, which makes this operationally inexpensive.From the startPlugin, you get back an instance, which corresponds to the object returned from the plugin implementation (see (4) in the example Custom UI, above). You also get a bunch of utilities to interact with the plugin. The full list is documented Desktop Plugin API page. However, for this test, the sole concern is with sendEvent. By using sendEvent, you can mimic the client plugin sending events to your plugin (4). Similarly, you can emulate all other possible events, such as the initial connection setup with (.connect()), the user (de)selecting the plugin (.activate() / deactivate()), or a deeplink being triggered (.triggerDeepLink), and so on.After the events have been sent, it's expected the internal state of the plugin should have been updated; this is asserted at point (5). The assertions are provided by Jest. Particularly useful is toMatchInlineSnapshot, which generates the initial snapshot during the first run of the unit tests, saving a lot of effort. ","version":"Next","tagName":"h2"},{"title":"Building a User Interface for the plugin​","type":1,"pageTitle":"Building A Desktop Plugin - Custom UI","url":"/docs/tutorial/js-custom/#building-a-user-interface-for-the-plugin","content":"So far, in index.tsx, the Component hasn't yet done anything useful. This section explains how to build an effective and nice-looking UI. Flipper leverages Ant design, so any official Ant component can be used in Flipper plugins. The styling system used by Flipper can be found at the style guide, where the the different Layout elements are documented. import React, {memo} from 'react'; import {Typography, Card} from 'antd'; import { Layout, PluginClient, usePlugin, createState, useValue, theme, styled, DataInspector, DetailSidebar } from 'flipper-plugin'; // (1) export function Component() { // (2) const instance = usePlugin(plugin); // (3) const rows = useValue(instance.rows); const selectedID = useValue(instance.selectedID); // (4) return ( &lt;&gt; &lt;Layout.ScrollContainer vertical style={{background: theme.backgroundWash}}&gt; &lt;Layout.Horizontal gap pad style={{flexWrap: 'wrap'}}&gt; {Object.entries(rows).map(([id, row]) =&gt; ( &lt;MammalCard row={row} onSelect={instance.setSelection} selected={id === selectedID} key={id} /&gt; ))} &lt;/Layout.Horizontal&gt; &lt;/Layout.ScrollContainer&gt; &lt;DetailSidebar&gt; {selectedID &amp;&amp; renderSidebar(rows[selectedID])} &lt;/DetailSidebar&gt; &lt;/&gt; ); } function renderSidebar(row: Row) { return ( &lt;Layout.Container gap pad&gt; &lt;Typography.Title level={4}&gt;Extras&lt;/Typography.Title&gt; &lt;DataInspector data={row} expandRoot={true} /&gt; &lt;/Layout.Container&gt; ); }  note The above User Interface code contains numbered comments (such as '// (1)') that are referenced in the following information. Key points regarding the above User Interface code: A plugin module can have many components but should always export one component named Component, which is used as the root component for the plugin rendering. The component mustn't take any props and will be mounted by Flipper when the user selects the plugin (see (1)).Inside the component, you can grab the relevant instance of the plugin by using the usePlugin hook (see (2)). This returns the instance API returned in the Example Custom UI at the end of the plugin function. The original plugin definition is passed to the usePlugin as argument: this is done to get the typings of instance correct and should always be done.With the useValue hook ((3)), you can grab the current value from the states created earlier using createState. The benefit of useValue(instance.rows) overusing rows.get(), is that the first will automatically subscribe your component to any future updates to the state, causing the component to re-render when new rows arrive.Since both usePlugin and useValue are hooks, they usual React rules for them apply; they need to be called unconditionally. So, it's recommended to put them at the top of your component body. Both hooks can not only be used in the root Component, but also in any other component in your plugin component tree. So, it's not necessary to grab all the data at the root and pass it down using props. Using useValue as deep in the component tree as possible will benefit performance.Finally, the data is rendered and returned (see (4)). The details have been left out here, as from this point it's just idiomatic React code. rmation The source of the other MammalCard component is located in GitHub. note It's recommended to keep components outside of the entry file as much as possible because components defined outside the index.tsx file will benefit from fast refresh. ","version":"Next","tagName":"h2"},{"title":"Unit testing the User Interface​","type":1,"pageTitle":"Building A Desktop Plugin - Custom UI","url":"/docs/tutorial/js-custom/#unit-testing-the-user-interface","content":"You can lower the chances of regression in the UI by adding another unit test to the seamammals.spec.tsx file and asserting that the rendering is correct and interactive. The following code provides an example: test('It can have selection and render details', async () =&gt; { // (1) const { instance, renderer, act, sendEvent, exportState, } = TestUtils.renderPlugin(MammalsPlugin); // (2) sendEvent('newRow', { id: 1, title: 'Dolphin', url: 'http://dolphin.png', }); sendEvent('newRow', { id: 2, title: 'Turtle', url: 'http://turtle.png', }); // (3) Dolphin card should now be visible expect(await renderer.findByTestId('Dolphin')).not.toBeNull(); // (4) Let's assert the structure of the Turtle card as well expect(await renderer.findByTestId('Turtle')).toMatchInlineSnapshot(` &lt;div class=&quot;css-ok7d66-View-FlexBox-FlexColumn&quot; data-testid=&quot;Turtle&quot; &gt; &lt;div class=&quot;css-vgz97s&quot; style=&quot;background-image: url(http://turtle.png);&quot; /&gt; &lt;span class=&quot;css-8j2gzl-Text&quot; &gt; Turtle &lt;/span&gt; &lt;/div&gt; `); // (5) Nothing selected, so we should not have a sidebar expect(renderer.queryAllByText('Extras').length).toBe(0); act(() =&gt; { instance.setSelection(2); }); // Sidebar should be visible now expect(await renderer.findByText('Extras')).not.toBeNull(); // (6) Verify export expect(exportState()).toEqual({ rows: { '1': { id: 1, title: 'Dolphin', url: 'http://dolphin.png', }, '2': { id: 2, title: 'Turtle', url: 'http://turtle.png', }, }, selection: '2', }); });  note The above User Interface Unit Test code contains numbered comments (such as '// (1)') that are referenced in the following information. As in the Initial Unit Test, you can use TestUtils to start your plugin. But rather than using startPlugin, you now use renderPlugin, which has the same functionality but also renders the component in memory, using the React Testing Library, this enables you to interact with DOM. Key points regarding the above User Interface Unit Test code: You start the UI test by sending some events to the plugin (see (2)). After which (see (3)), the new data should be reflected in the DOM.Since you used &lt;Card data-testid={row.title} in the component implementation (not shown above), you can search in the DOM based on that test-id to find the correct element. It is also possible to search for other entities, such as a specific classname. The available queries are documented in the React Testing Library.Rather than just checking that the rendering isn't null, you can also take a snapshot of the DOM and assert that it doesn't change accidentally in the future. Jest's toMatchInlineSnapshot (see (4)) is quite useful for that. However, don't overuse it as large snapshots are pretty useless and just create a maintenance burden without catching much.At point (5), the code simulates updating the selection from code and asserts that the sidebar has become visible. Note that the update is wrapped in act, which is recommended as it makes sure that updates are flushed to the DOM before you make queries and assertions on the DOM (the earlier sendEvent does apply act automatically and doesn't need wrapping) Alternatively, you could have emulated actually clicking a DOM element, by using fireEvent.click(renderer.findByTestId('dolphin')) (for details, see Firing Events in the docs of the React Testing Library) Finally (see (6)), the test grabs the final state of the plugin state by using the exportState utility. It returns all the persistable state of the plugin, based on the persist keys that were passed to createState in the Example Custom UI code.You now assert that the plugin ends up in the desired state. ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}